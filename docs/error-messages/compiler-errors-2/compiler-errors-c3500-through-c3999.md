---
title: Erros do compilador C3500 a C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446942"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Erros do compilador C3500 a C3999

Os artigos nesta seção da documentação explicam um subconjunto das mensagens de erro geradas pelo compilador.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Mensagens de erro

|Error|Mensagem|
|-----------|-------------|
|[Erro do compilador C3500](compiler-error-c3500.md)|ProgID '*ProgID*' inválido|
|[Erro do compilador C3501](compiler-error-c3501.md)|Não há TypeLib registrado para ProgID '*ProgID*'|
|Erro do compilador C3502|Não é possível obter LIBID para ProgID '*ProgID*'|
|Erro do compilador C3503|o caractere ' 0x*Value*' não é permitido em um literal de cadeia de caracteres bruta|
|Erro do compilador C3504|Não é possível criar GUID da cadeia de caracteres '*String*'|
|[Erro do compilador C3505](compiler-error-c3505.md)|Não é possível carregar a biblioteca de tipos '*library*'|
|[Erro do compilador C3506](compiler-error-c3506.md)|Não há TypeLib registrado para o LIBID '*library*'|
|[Erro do compilador C3507](compiler-error-c3507.md)|um ProgID pode ter no máximo 39 caracteres '*ProgID*'; Nem conter nenhuma pontuação, além de '. '; nem começar com um dígito|
|[Erro do compilador C3508](compiler-error-c3508.md)|'*Type*': não é um tipo de automação válido|
|[Erro do compilador C3509](compiler-error-c3509.md)|'*Type*': tipo de retorno de automação inválido; Quando um parâmetro é marcado como ' retval ', o tipo de retorno deve ser ' void ', ' HRESULT ' ou ' SCODE '|
|[Erro do compilador C3510](compiler-error-c3510.md)|Não é possível localizar *biblioteca* de bibliotecas de tipos dependentes|
|Erro do compilador C3511|'*Identifier*': uma chamada para um construtor de delegação deve ser o único inicializador de membro|
|Erro do compilador C3512|a sequência de caracteres de delimitação para um literal de cadeia de caracteres bruta deve ter no máximo 16 caracteres|
|Erro do compilador C3513|'*String*': caractere delimitador de literal de cadeia de caracteres bruta sem suporte|
|Erro do compilador C3514|'*Character*' (*valor*): caractere delimitador de literal de cadeia de caracteres bruta sem suporte|
|Erro do compilador C3515|se um argumento para uma especialização parcial de modelo de classe for uma expansão de pacote, ele deverá ser o último argumento|
|Erro do compilador C3516|fim de arquivo inesperado encontrado ao processar o literal de cadeia de caracteres bruta; a sequência de delimitador '*String*' não foi correspondida|
|Erro do compilador C3517|'*Identifier*' uma declaração de alias não pode ter um tipo que contenha ' auto '|
|Erro do compilador C3518|'*Identifier*': em um contexto de inicialização de lista direta, o tipo de '*Type*' só pode ser deduzido a partir de uma expressão de inicializador único|
|[Erro do compilador C3519](compiler-error-c3519.md)|'*Parameter*': parâmetro inválido para embedded_idl atributo|
|Erro do compilador C3520|'*Identifier*': o pacote de parâmetros deve ser expandido neste contexto|
|Erro do compilador C3521|'*Identifier*' não é um pacote de parâmetros|
|Erro do compilador C3522|'*Type*': o pacote de parâmetros não pode ser expandido neste contexto|
|Erro do compilador C3523|' sizeof... ' requer como argumento um pacote de parâmetros não expandido|
|Erro do compilador C3524|'*Identifier*': ' sizeof ' não pode ser aplicado a um pacote de parâmetros. Você quis dizer usar ' sizeof... '?|
|Erro do compilador C3525|'*Parameter*': se um modelo de classe tiver um pacote de parâmetros de template, ele deverá aparecer no final da lista de parâmetros do modelo|
|Erro do compilador C3526|'...' Não pode ser aplicado a ' this '|
|Erro do compilador C3527|'*Identifier*' não é um operando válido para ' sizeof... '. Você quis dizer usar ' sizeof '?|
|Erro do compilador C3528|'*identifier1*': o número de elementos nesta expansão de pacote não corresponde ao número de elementos em '*identifier2*'|
|Erro do compilador C3529|'*Parameter*': um pacote de parâmetros de template não pode ter um argumento padrão|
|[Erro do compilador C3530](compiler-error-c3530.md)|'*Type*' não pode ser combinado com nenhum outro especificador de tipo|
|[Erro do compilador C3531](compiler-error-c3531.md)|'*Identifier*': um símbolo cujo tipo contém '*Type*' deve ter um inicializador|
|[Erro do compilador C3532](compiler-error-c3532.md)|o tipo de elemento de uma matriz não pode ser um tipo que contenha '*Type*'|
|[Erro do compilador C3533](compiler-error-c3533.md)|um parâmetro não pode ter um tipo que contenha '*Type*'|
|Erro do compilador C3534|Obsoleto.|
|[Erro do compilador C3535](compiler-error-c3535.md)|Não é possível deduzir o tipo para '*type1*' de '*type2*'|
|[Erro do compilador C3536](compiler-error-c3536.md)|'*Identifier*': não pode ser usado antes de ser inicializado|
|[Erro do compilador C3537](compiler-error-c3537.md)|Não é possível converter em um tipo que contém '*Type*'|
|[Erro do compilador C3538](compiler-error-c3538.md)|em uma lista de declaradores, '*Type*' deve sempre deduzir para o mesmo tipo|
|[Erro do compilador C3539](compiler-error-c3539.md)|um argumento de template não pode ser um tipo que contém '*Type*'|
|[Erro do compilador C3540](compiler-error-c3540.md)|sizeof não pode ser aplicado a um tipo que contém '*Type*'|
|[Erro do compilador C3541](compiler-error-c3541.md)|typeid não pode ser aplicado a um tipo que contém '*Type*'|
|Erro do compilador C3542|'*Identifier*': uma função membro virtual não deve ter um tipo de retorno que contenha '*Type*'|
|Erro do compilador C3543|'*Type*': não contém um pacote de parâmetros|
|Erro do compilador C3544|'*Parameter*': o pacote de parâmetros espera um argumento de modelo de tipo|
|Erro do compilador C3545|'*Parameter*': o pacote de parâmetros espera um argumento de modelo sem tipo|
|Erro do compilador C3546|'... ': não há pacotes de parâmetros disponíveis para expandir|
|Erro do compilador C3547|o parâmetro de modelo '*Parameter*' não pode ser usado porque segue um pacote de parâmetros de template e não pode ser deduzido dos parâmetros de função de '*Function*'|
|Erro do compilador C3548|'*Identifier*': o pacote de parâmetros não pode ser usado neste contexto|
|Erro do compilador C3549|'*Value*': um pacote de parâmetros de função não pode ter um argumento padrão|
|[Erro do compilador c3550](compiler-error-c3550.md)|somente ' decltype (auto) ' simples é permitido neste contexto|
|[Erro do compilador C3551](compiler-error-c3551.md)|se um tipo de retorno à direita for usado, o tipo de retorno à esquerda deverá ser o especificador de tipo único ' auto ' (não '*Type*')|
|[Erro do compilador C3552](compiler-error-c3552.md)|' decltype (auto) ' esperado|
|[Erro do compilador C3553](compiler-error-c3553.md)|decltype espera que uma expressão não seja um tipo|
|[Erro do compilador C3554](compiler-error-c3554.md)|'*Type*' não pode ser combinado com nenhum outro especificador de tipo|
|[Erro do compilador C3555](compiler-error-c3555.md)|argumento incorreto para ' decltype '|
|[Erro do compilador C3556](compiler-error-c3556.md)|'*expression*': argumento incorreto para ' decltype '|
|Erro do compilador C3557|Obsoleto.|
|Erro do compilador C3558|Obsoleto.|
|Erro do compilador C3559|chamada recursiva para '*Function*': a recursão é detectada ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3560|'*Function*': Il não está disponível ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3561|a operação de barreira de bloco foi encontrada no fluxo de controle que não é um bloco uniforme ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3562|a função intrínseca '*Function*' está limitada a não ter mais do que parâmetros *numéricos*|
|Erro do compilador C3563|Loop infinito detectado ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3564|lendo o valor não inicializado ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3565|A quantidade total de tile_static memória (*número* bytes) excede o limite de bytes *numéricos* ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each|
|Erro do compilador C3566|blocos com efeitos colaterais aninhados muito profundamente ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3567|divisão ou Mod por zero detectado ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3568|a soma dos registros excede o limite de *número* ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each. Simplifique seu programa|
|Erro do compilador C3569|condição de corrida detectada ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3570|uso ilegal do escopo restrito de amp ao compilar com/CLR|
|Erro do compilador C3571|'*Type*': argumento de domínio de computação ilegal; Não é um tipo de classe|
|Erro do compilador C3572|'*Type*': argumento de domínio de computação ilegal; membro público ausente: ' static const int Rank ' ou valor de classificação é não positivo|
|Erro do compilador C3573|O número de instâncias de Concurrency:: Graphics:: amostra passado para Concurrency::p arallel_for_each não pode exceder o *número*|
|Erro do compilador C3574|'*Type*': extensões de bloco ilegais: devem ser positivas e (1) Z < = *Number*; (2) Z*Y*X < = *número*|
|Erro do compilador C3575|'*Type*': argumento de domínio de computação ilegal; membro público ausente: ' Concurrency:: index <*número*> _map_index (const Concurrency:: index <*Number*> &) Restrict (amp) '|
|Erro do compilador C3576|"*Type*": concurrency::d etalhes:: _Parallel_for_each argumento #*Number* tem um tipo sem suporte|
|Erro do compilador C3577|simultaneidade::p arallel_for_each argumento de kernel é ilegal: não é possível resolver a chamada para o membro ' void Operator () (*Type*) Restrict (amp) '|
|Erro do compilador C3578|O tamanho do objeto de função passado para Concurrency::p arallel_for_each não pode exceder o *número* de bytes|
|Erro do compilador C3579|O número de instâncias somente leitura de Concurrency:: array e Concurrency:: Graphics:: Texture passado para Concurrency::p arallel_for_each não pode exceder o *número*|
|Erro do compilador C3580|O número de instâncias graváveis de Concurrency:: array e Concurrency:: Graphics:: Texture passado para Concurrency::p arallel_for_each não pode exceder o *número*|
|Erro do compilador C3581|'*Type*': tipo sem suporte no código de amp restrito|
|Erro do compilador C3582|Obsoleto.|
|Erro do compilador C3583|'*Identifier*': o tamanho da variável (*número* bytes) é maior do que o tamanho máximo (*número* de bytes) com suporte no código de amp restrito|
|Erro do compilador C3584|uso sem suporte de tile_static em '*Identifier*'|
|Erro do compilador C3585|'*Identifier*' tem uma classe de armazenamento sem suporte no código de amp restrito|
|Erro do compilador C3586|'*Identifier*': não há suporte para o uso de variáveis globais ou estáticas no código de amp restrito|
|Erro do compilador C3587|Não há suporte para dynamic_cast no código de amp restrito|
|Erro do compilador C3588|Não há suporte para a conversão de '*type1*' em '*type2*' no código de amp restrito|
|Erro do compilador C3589|'*String*': uso sem suporte de literais de cadeia de caracteres no código de amp restrito|
|Erro do compilador C3590|'*token*': a captura por referência ou ' this ' não será suportada se o lambda for amp Restricted|
|Erro do compilador C3591|operador de typeid não é suportado no código de amp restrito|
|Erro do compilador C3592|O assembly nativo embutido (' __asm ') não tem suporte no código de amp restrito|
|Erro do compilador C3593|' GoTo ' não é suportado no código de amp restrito|
|Erro do compilador C3594|a manipulação de exceção (try, catch, throw etc.) não é suportada no código de amp restrito|
|Erro do compilador C3595|o valor constante está fora do intervalo com suporte no código de amp restrito|
|Erro do compilador C3596|"*Parameter*" ("*Type*"): a variável capturada por lambda tem um tipo sem suporte no código de amp restrito|
|Erro do compilador C3597|"*Parameter*": "*Identifier*" não pode ser capturado por valor se o lambda for amp Restricted|
|Erro do compilador C3598|instrução de rótulo não é suportada no código de amp restrito|
|Erro do compilador C3599|'*Operator*': não é possível executar aritmética de ponteiro em ponteiro para bool no código de amp restrito|
|Erro do compilador C3600|'*Function*': uso de bloco\_memória estática detectada ao compilar o grafo de chamada para a simultaneidade sem divisão::p arallel\_for_each em: '*Function*'|
|Erro do compilador C3601|'*Type*': é um tipo de argumento inválido para a função de diagnóstico amp '*Function*'|
|Erro do compilador C3602|Fluxo de controle sem suporte detectado ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|[Erro do compilador C3603](compiler-error-c3603.md)|'*Symbol*': tipo '*Type*' ainda não suportado|
|Erro do compilador C3604|'*Identifier*': só é possível criar um objeto gerenciado no heap de GC|
|Erro do compilador C3605|O número total de amostras (*número* capturado e *número* predefinido) excede o *número* ao compilar o grafo de chamada para a simultaneidade::p arallel_for_each em: '*Function*'|
|Erro do compilador C3606|Obsoleto.|
|Erro do compilador C3607|Obsoleto.|
|Erro do compilador C3608|Obsoleto.|
|[Erro do compilador C3609](compiler-error-c3609.md)|'*Identifier*': uma função ' sealed/final ' deve ser virtual|
|[Erro do compilador C3610](compiler-error-c3610.md)|'*Identifier*': tipo de valor deve ser ' Boxed ' antes que o método '*Method*' possa ser chamado|
|[Erro do compilador C3611](compiler-error-c3611.md)|'*Identifier*': uma função sealed não pode possuir um especificador puro|
|[Erro do compilador C3612](compiler-error-c3612.md)|'*Identifier*': uma classe sealed não pode possuir métodos virtuais puros|
|Erro do compilador C3613|tipo de retorno ausente após "->" ("int" assumido)|
|Erro do compilador C3614|Valores diferentes para o tamanho do pacote na mesma classe; anterior era '*Value*', o novo valor é '*Value*'|
|[Erro do compilador C3615](compiler-error-c3615.md)|a função constexpr '*Function*' não pode resultar em uma expressão constante|
|Erro do compilador C3616|Obsoleto.|
|Erro do compilador C3617|Obsoleto.|
|[Erro do compilador C3618](compiler-error-c3618.md)|'*declaração*': um método marcado como DllImport não pode ser definido|
|[Erro do compilador C3619](compiler-error-c3619.md)|um modelo não pode ser declarado dentro de um tipo gerenciado/WinRT|
|Erro do compilador C3620|'*Type*': a definição do alinhamento não é permitida em tipos de WinRT|
|Erro do compilador C3621|'*Type*': somente o valor de empacotamento padrão (*Number*) é permitido para tipos de WinRT|
|[Erro do compilador C3622](compiler-error-c3622.md)|*tipo*': uma classe declarada como '*palavra-chave*' não pode ser instanciada|
|[Erro do compilador C3623](compiler-error-c3623.md)|'*Identifier*': não há suporte para campos de bits em tipos gerenciados/WinRT|
|[Erro do compilador C3624](compiler-error-c3624.md)|'*Type*': o uso deste tipo requer uma referência ao assembly/módulo '*Identifier*'|
|[Erro do compilador C3625](compiler-error-c3625.md)|'*Class*': um tipo nativo não pode derivar de um tipo gerenciado/WinRT '*Type*'|
|[Erro do compilador C3626](compiler-error-c3626.md)|'*Identifier*': palavra-chave '*keyword*' só pode ser usada em interfaces com, funções de membro e membros de dados que são ponteiros para delegados|
|[Erro do compilador C3627](compiler-error-c3627.md)|Somente um tipo Value pode ser Boxed|
|[Erro do compilador C3628](compiler-error-c3628.md)|"*Class*": classes Managed/WinRT suportam apenas herança pública|
|Erro do compilador C3629|'*token*': um padrão de captura só pode aparecer no início de uma lista de captura de lambda|
|[Erro do compilador C3630](compiler-error-c3630.md)|erro ao processar o token '*token*'|
|[Erro do compilador C3631](compiler-error-c3631.md)|'*Event*': não é possível sobrecarregar eventos gerenciados/WinRT|
|[Erro do compilador C3632](compiler-error-c3632.md)|'*Event*': estilo inválido de evento para *Construct*|
|[Erro do compilador C3633](compiler-error-c3633.md)|Não é possível definir '*Identifier*' como um membro de '*Class*' gerenciado|
|[Erro do compilador C3634](compiler-error-c3634.md)|'*Member*': não é possível definir um método abstract de uma classe Managed/WinRT|
|Erro do compilador C3635|'*Identifier*': não pode ser aplicado a uma classe gerenciada/WinRT (use '*Identifier*' em vez disso)|
|Erro do compilador C3636|'*Identifier*': não pode ser aplicado a este tipo|
|[Erro do compilador C3637](compiler-error-c3637.md)|'*Function*': uma definição de função Friend não pode ser uma especialização de um template de função/genérico|
|[Erro do compilador C3638](compiler-error-c3638.md)|'*Operator*': os operadores de conversão boxing e unboxing padrão não podem ser redefinidos|
|Erro do compilador C3639|Obsoleto.|
|[Erro do compilador c3640](compiler-error-c3640.md)|'*Member*': uma função de membro referenciada ou virtual de uma classe local deve ser definida|
|[Erro do compilador C3641](compiler-error-c3641.md)|'*Function*': Convenção de chamada inválida '*Convenção*' para função compilada com/CLR: pure ou/CLR: safe|
|[Erro do compilador C3642](compiler-error-c3642.md)|'*Function*': não é possível chamar uma função com __clrcall Convenção de chamada a partir de código nativo|
|Erro do compilador C3643|Obsoleto.|
|[Erro do compilador C3644](compiler-error-c3644.md)|'*Function*': não é possível compilar a função para gerar código gerenciado|
|[Erro do compilador C3645](compiler-error-c3645.md)|'*Function*': __clrcall não pode ser usado em funções compiladas para código nativo|
|[Erro do compilador C3646](compiler-error-c3646.md)|'*Identifier*': especificador de substituição desconhecido|
|Erro do compilador C3647|Obsoleto.|
|[Erro do compilador C3648](compiler-error-c3648.md)|essa sintaxe de substituição explícita não tem suporte para tipos gerenciados|
|Erro do compilador C3649|essa sintaxe de substituição explícita não é permitida com/ZW|
|[Erro do compilador C3650](compiler-error-c3650.md)|'*Member*': não pode ser usado como uma substituição explícita, deve ser uma função membro virtual de uma classe base|
|[Erro do compilador C3651](compiler-error-c3651.md)|'*Member*': não pode ser usado como uma substituição explícita, deve ser um membro de uma classe base|
|[Erro do compilador C3652](compiler-error-c3652.md)|'*Member*': uma função que substitui explicitamente deve ser virtual|
|[Erro do compilador C3653](compiler-error-c3653.md)|'*Identifier*': não pode ser usado como uma substituição nomeada: uma função que está sendo substituída não encontrada; Você esqueceu de nomear a função explicitamente, usando um operador::?|
|[Erro do compilador C3654](compiler-error-c3654.md)|'*token*': erro de sintaxe em substituição explícita|
|[Erro do compilador C3655](compiler-error-c3655.md)|'*Member*': função já substituída explicitamente|
|[Erro do compilador C3656](compiler-error-c3656.md)|'*keyword*': o especificador de substituição não pode ser repetido|
|[Erro do compilador C3657](compiler-error-c3657.md)|um destruidor/finalizador não pode substituir explicitamente ou ser explicitamente substituído|
|Erro do compilador C3658|Obsoleto.|
|Erro do compilador C3659|'*Member*': não há suporte para o especificador de substituição '*keyword*'|
|Erro do compilador C3660|'*member1*': oculta o membro herdado '*membro2*'|
|[Erro do compilador C3661](compiler-error-c3661.md)|a lista de substituição explícita não encontrou nenhum método para substituir|
|[Erro do compilador C3662](compiler-error-c3662.md)|'*Member*': especificador de substituição '*keyword*' permitido somente em funções membro de classes Managed/WinRT|
|Erro do compilador C3663|Obsoleto.|
|Erro do compilador C3664|'*Member*': não pode ser usado como uma substituição explícita, deve ter acessibilidade ' pública ' ou ' protegida '|
|[Erro do compilador C3665](compiler-error-c3665.md)|'*Member*': especificador de substituição '*keyword*' não permitido em um destruidor/finalizador|
|[Erro do compilador C3666](compiler-error-c3666.md)|'*constructor*': especificador de substituição '*keyword*' não permitido em um construtor|
|Erro do compilador C3667|'*Attribute*': atributo não oferece suporte à expansão de pacote|
|[Erro do compilador C3668](compiler-error-c3668.md)|'*Member*': o método com o especificador de substituição ' override ' não substituiu nenhum método de classe base|
|[Erro do compilador C3669](compiler-error-c3669.md)|'*Member*': especificador de substituição ' override ' não permitido em funções membro static ou construtores|
|[Erro do compilador C3670](compiler-error-c3670.md)|'*Member*': não é possível substituir o método de classe base inacessível '*Member*'|
|[Erro do compilador C3671](compiler-error-c3671.md)|'*Member*': a função não substitui '*Member*'|
|[Erro do compilador C3672](compiler-error-c3672.md)|a expressão pseudo destruidor só pode ser usada como parte de uma chamada de função|
|[Erro do compilador C3673](compiler-error-c3673.md)|'*Class*': a classe não tem um construtor de cópia|
|Erro do compilador C3674|Não foi possível encontrar o módulo de biblioteca padrão '*Module*'|
|[Erro do compilador C3675](compiler-error-c3675.md)|'*Function*': é reservado porque '*Property*' está definido|
|Erro do compilador C3676|'*Class*': classe ref e classe base têm atributos incompatíveis ' [*Attribute*] '|
|Erro do compilador C3677|o literal de cadeia após ' operator ' não pode ter um prefixo de codificação|
|Erro do compilador C3678|o literal de cadeia após ' operator ' deve ser a cadeia de caracteres vazia ' "" "" '|
|Erro do compilador C3679|esperado um identificador de sufixo literal após "Operator" "" ""|
|Erro do compilador C3680|Não é possível concatenar literais de cadeia de caracteres definidos pelo usuário com identificadores de sufixo literal incompatíveis|
|Erro do compilador C3681|' fallthrough ': o atributo só pode aparecer em uma instrução switch delimitadora|
|Erro do compilador C3682|' *identificador*do operador ': o modelo de operador literal/literal não pode ser declarado como tendo ' C vínculo '|
|Erro do compilador C3683|Não é possível definir o operador literal bruto e o modelo de operador literal com o mesmo identificador de sufixo literal|
|Erro do compilador C3684|' *identificador*do operador ': a declaração do operador literal tem uma lista de parâmetros inválida|
|Erro do compilador C3685|' *identificador*do operador ': o modelo de operador literal não pode ter parâmetros de função|
|Erro do compilador C3686|' *identificador*do operador ': o modelo de operador literal deve ter exatamente um parâmetro de modelo que seja um pacote de parâmetros|
|Erro do compilador C3687|" *identificador*do operador": o modelo de operador literal deve ter um parâmetro de modelo sem tipo de tipo "char"|
|Erro do compilador C3688|sufixo literal inválido '*suffix*'; operador literal ou modelo de operador literal ' *identificador*de operador ' não encontrado|
|Erro do compilador C3689|' *identificador*do operador ': o modelo de operador literal/literal deve estar em um escopo global ou de namespace|
|Erro do compilador C3690|esperado um literal de cadeia de caracteres, mas foi encontrado um literal de cadeia de caracteres definido pelo usuário|
|Erro do compilador C3691|prefixo literal inválido '*prefix*'|
|Erro do compilador C3692|Obsoleto.|
|Erro do compilador C3693|Obsoleto.|
|Erro do compilador C3694|Obsoleto.|
|Erro do compilador C3695|Obsoleto.|
|Erro do compilador C3696|'*keyword*': não é possível usar este qualificador em '% '|
|[Erro do compilador C3697](compiler-error-c3697.md)|'*keyword*': não é possível usar este qualificador em ' ^ '|
|[Erro do compilador C3698](compiler-error-c3698.md)|'*Type*': não é possível usar este tipo como argumento de '*Operator*'|
|[Erro do compilador C3699](compiler-error-c3699.md)|'*Operator*': não é possível usar esta indireção no tipo '*Type*'|
|Erro do compilador C3700|Obsoleto.|
|[Erro do compilador C3701](compiler-error-c3701.md)|'*Function*': a origem do evento não tem eventos|
|[Erro do compilador C3702](compiler-error-c3702.md)|A ATL é necessária para eventos COM|
|[Erro do compilador C3703](compiler-error-c3703.md)|'*event_handler*': um método de manipulador de eventos deve ter a mesma classe de armazenamento que o '*Event*' de origem|
|[Erro do compilador C3704](compiler-error-c3704.md)|'*Member*': um método vararg não pode acionar eventos|
|[Erro do compilador C3705](compiler-error-c3705.md)|'*Function*': não é possível encontrar a interface de eventos|
|[Erro do compilador C3706](compiler-error-c3706.md)|'*Function*': deve ser uma interface com para disparar eventos com|
|[Erro do compilador C3707](compiler-error-c3707.md)|'*Member*': método de dispinterface deve ter um DISPID|
|[Erro do compilador C3708](compiler-error-c3708.md)|'*Function*': uso inadequado de '*palavra-chave*'; deve ser um membro de uma fonte de eventos compatível|
|[Erro do compilador C3709](compiler-error-c3709.md)|'*Function*': sintaxe inadequada para especificar o evento em __hook/__unhook|
|[Erro do compilador C3710](compiler-error-c3710.md)|'*Function*': sintaxe inadequada para especificar o manipulador de eventos no __hook/__unhook|
|[Erro do compilador C3711](compiler-error-c3711.md)|'*Event*': um método de origem de evento não gerenciado deve retornar um tipo void ou integral|
|[Erro do compilador C3712](compiler-error-c3712.md)|'*event_handler*': um método de manipulador de eventos deve retornar o mesmo tipo que o '*Event*' de origem|
|[Erro do compilador C3713](compiler-error-c3713.md)|'*event_handler*': um método de manipulador de eventos deve ter os mesmos parâmetros de função que o '*evento*' de origem|
|[Erro do compilador C3714](compiler-error-c3714.md)|'*event_handler*': um método de manipulador de eventos deve ter a mesma convenção de chamada que o '*evento*' de origem|
|[Erro do compilador C3715](compiler-error-c3715.md)|'*pointer*': deve ser um ponteiro para '*Type*'|
|Erro do compilador C3716|Obsoleto.|
|[Erro do compilador C3717](compiler-error-c3717.md)|'*Member*': um método que dispara eventos não pode ser definido|
|[Erro do compilador C3718](compiler-error-c3718.md)|Só é possível chamar ' _ only*palavra-chave*' no contexto de uma função membro da classe receptora|
|[Erro do compilador C3719](compiler-error-c3719.md)|'*Member*': uma fonte de eventos baseada em interface só pode ser usada para eventos com|
|Erro do compilador C3720|'*Type*': só é possível implementar IDispatch em duas ou dispinterface|
|[Erro do compilador C3721](compiler-error-c3721.md)|'*Signature*': assinatura incompatível para o evento|
|[Erro do compilador C3722](compiler-error-c3722.md)|um evento genérico não é permitido|
|[Erro do compilador C3723](compiler-error-c3723.md)|'*Function*': não foi possível resolver o evento|
|[Erro do compilador C3724](compiler-error-c3724.md)|é necessário #include \<Windows. h > para usar multithreading com eventos|
|Erro do compilador C3725|Obsoleto.|
|Erro do compilador C3726|Obsoleto.|
|[Erro do compilador C3727](compiler-error-c3727.md)|'*Event*': um evento gerenciado deve ser uma função membro ou um membro de dados que seja um ponteiro para um delegado|
|[Erro do compilador C3728](compiler-error-c3728.md)|'*Event*': o evento não tem um método Raise|
|Erro do compilador C3729|Obsoleto.|
|Erro do compilador C3730|Obsoleto.|
|[Erro do compilador C3731](compiler-error-c3731.md)|evento incompatível '*Event*' e handler '*event_handler*'; a origem do evento e o manipulador de eventos devem ter o mesmo tipo de evento|
|[Erro do compilador C3732](compiler-error-c3732.md)|'*interface*': uma interface personalizada que dispara eventos com não pode herdar de IDispatch|
|[Erro do compilador C3733](compiler-error-c3733.md)|'*Event*': sintaxe inadequada para especificar um evento com; Você esqueceu ' __interface '?|
|[Erro do compilador C3734](compiler-error-c3734.md)|'*Class*': uma classe Managed/WinRT não pode ser uma coclass|
|Erro do compilador C3735|Obsoleto.|
|[Erro do compilador C3736](compiler-error-c3736.md)|'*Member*': deve ser um método ou, no caso de eventos gerenciados, opcionalmente um membro de dados|
|[Erro do compilador C3737](compiler-error-c3737.md)|'*Identifier*': um delegado não pode ter uma Convenção de chamada explícita|
|[Erro do compilador C3738](compiler-error-c3738.md)|'*Convention*': a Convenção de chamada da instanciação explícita deve corresponder à do modelo que está sendo instanciado|
|[Erro do compilador C3739](compiler-error-c3739.md)|'*Class*': há suporte para sintaxe somente quando o parâmetro ' layout\_dependente ' de event_receiver é verdadeiro|
|[Erro do compilador C3740](compiler-error-c3740.md)|'*Template*': modelos não podem originar ou receber eventos|
|[Erro do compilador C3741](compiler-error-c3741.md)|'*Class*': deve ser uma coclass quando o parâmetro ' layout\_dependente ' de event_receiver é verdadeiro|
|Erro do compilador C3742|'*token1*': sequência de token desbalanceada no argumento de atributo de '*Attribute*', esperado '*token2*'|
|[Erro do compilador C3743](compiler-error-c3743.md)|Só é possível conectar/desvincular uma interface inteira quando o parâmetro ' layout_dependent ' de event_receiver é verdadeiro|
|[Erro do compilador C3744](compiler-error-c3744.md)|__unhook deve ter pelo menos 3 argumentos para eventos gerenciados|
|[Erro do compilador C3745](compiler-error-c3745.md)|'*Function*': somente um evento pode ser ' disparado '|
|Erro do compilador C3746|o atributo padrão '*Identifier*' pode aparecer no máximo uma vez em uma lista de atributos|
|[Erro do compilador C3747](compiler-error-c3747.md)|modelo padrão/parâmetro genérico ausente: *número* de parâmetro|
|[Erro do compilador C3748](compiler-error-c3748.md)|'*interface*': interfaces não gerenciadas podem não disparar eventos|
|[Erro do compilador C3749](compiler-error-c3749.md)|'*Attribute*': um atributo personalizado não pode ser usado dentro de uma função|
|Erro do compilador C3750|'*token*': token inesperado na lista de atributos|
|Erro do compilador C3751|'*Identifier*': identificador inesperado na lista de atributos|
|[Erro do compilador C3752](compiler-error-c3752.md)|'*Attribute*': não é possível classificar atributo; '*keyword*' não deve ser usado neste contexto|
|[Erro do compilador C3753](compiler-error-c3753.md)|uma propriedade genérica não é permitida|
|[Erro do compilador C3754](compiler-error-c3754.md)|Construtor delegate: a função membro '*Member*' não pode ser chamada em uma instância do tipo '*Type*'|
|[Erro do compilador C3755](compiler-error-c3755.md)|'*Identifier*': um delegado não pode ser definido|
|Erro do compilador C3756|Obsoleto.|
|Erro do compilador C3757|'*Type*': tipo não permitido para a função ' constexpr '|
|Erro do compilador C3758|'*Member*': a função virtual não pode ser declarada ' constexpr '|
|Erro do compilador C3759|'*Member*': a função membro do tipo não literal não pode ser declarada ' constexpr '|
|Erro do compilador C3760|Use __property palavra-chave para declarar a propriedade em '*classe*' gerenciada/WinRT|
|[Erro do compilador C3761](compiler-error-c3761.md)|'*Function*': ' retval ' só pode aparecer no último argumento de uma função|
|[Erro do compilador C3762](compiler-error-c3762.md)|Não é possível processar o atributo '*Attribute*'|
|[Erro do compilador C3763](compiler-error-c3763.md)|'*Type*': ' retval ' e ' out ' só podem aparecer em um tipo de ponteiro de dados|
|[Erro do compilador C3764](compiler-error-c3764.md)|'*Member*': não é possível substituir o método de classe base '*Member*'|
|[Erro do compilador C3765](compiler-error-c3765.md)|'*Event*': não é possível definir um evento em uma classe/struct '*Type*' marcada como um event_receiver|
|[Erro do compilador C3766](compiler-error-c3766.md)|'*Type*' deve fornecer uma implementação para o método de interface '*Function*'|
|[Erro do compilador C3767](compiler-error-c3767.md)|'*Function*': funções candidatas não acessíveis|
|[Erro do compilador C3768](compiler-error-c3768.md)|Não é possível obter o endereço de uma função virtual vararg em código gerenciado puro|
|[Erro do compilador C3769](compiler-error-c3769.md)|'*Identifier*': uma classe aninhada não pode ter o mesmo nome que a classe de circunscrição imediata|
|Erro do compilador C3770|'*Type*': não é uma classe base válida|
|[Erro do compilador C3771](compiler-error-c3771.md)|'*Identifier*': declaração Friend não pode ser encontrada no escopo de namespace mais próximo|
|[Erro do compilador C3772](compiler-error-c3772.md)|'*Identifier*': declaração de modelo Friend inválida|
|Erro do compilador C3773|Use a opção de compilador/Await para habilitar as corrotinas|
|Erro do compilador C3774|Não é possível localizar o '*escopo*::*identificador*': incluir cabeçalho de *cabeçalho*|
|Erro do compilador C3775|o tipo de retorno de '*Function*' não deve ser '*Type*'|
|Erro do compilador C3776|Não é possível retornar um converter na expressão do tipo void em uma corrotina com tipo de retorno eventual não nulo|
|Erro do compilador C3777|'*Function*': uma corrotina não pode usar uma lista de argumentos variáveis|
|Erro do compilador C3778|alloca: não pode ser usado em uma corrotina|
|Erro do compilador C3779|'*Function*': uma função que retorna '*Type*' não pode ser usada antes de ser definida|
|Erro do compilador C3780|'*Function*': uma função de conversão que retorna '*Type*' não pode ser usada antes de ser definida|
|Erro do compilador C3781|'*keyword*': não pode ser usado em uma corrotina do tipo '*Type*'. A *palavra-chave* ou palavra *-chave* deve estar presente no promise_type associado|
|Erro do compilador C3782|*tipo*: a promessa de uma corrotina não pode conter a *palavra-chave* e a *palavra-chave*|
|Erro do compilador C3783|'*Identifier*': não pode ser uma corrotina|
|Erro do compilador C3784|expressão de *palavra-chave* não pode aparecer neste contexto|
|Erro do compilador C3785|o primeiro argumento de modelo para ' std:: integer_sequence ' deve ser um tipo inteiro|
|Erro do compilador C3786|o segundo argumento de modelo para ' std:: make_integer_sequence ' deve ser uma constante de inteiro maior ou igual a zero|
|Erro do compilador C3787|Não é possível deduzir o tipo de retorno desta corrotina|
|Erro do compilador C3788|Obsoleto.|
|Erro do compilador C3789|Obsoleto.|
|Erro do compilador C3790|Obsoleto.|
|Erro do compilador C3791|Obsoleto.|
|Erro do compilador C3792|Obsoleto.|
|Erro do compilador C3793|Obsoleto.|
|Erro do compilador C3794|Obsoleto.|
|Erro do compilador C3795|Obsoleto.|
|Erro do compilador C3796|Obsoleto.|
|[Erro do compilador C3797](compiler-error-c3797.md)|'*keyword*': a declaração de evento não pode ter um especificador de substituição (deve ser colocado nos métodos Add/Remove/raise do evento)|
|[Erro do compilador C3798](compiler-error-c3798.md)|'*keyword*': declaração de propriedade não pode possuir especificador de substituição (deve ser colocado em vez dos métodos get/set de propriedade)|
|[Erro do compilador C3799](compiler-error-c3799.md)|a propriedade indexada não pode ter uma lista de parâmetros vazia|
|[Erro do compilador C3800](compiler-error-c3800.md)|'*declaração*': não é possível misturar Propriedades e eventos|
|Erro do compilador C3801|'*Attribute*': atributo não pode ter uma cláusula de argumento|
|Erro do compilador C3802|Obsoleto.|
|[Erro do compilador C3803](compiler-error-c3803.md)|'*Property*': a propriedade tem um tipo que é incompatível com um dos seus*acessadores de acessadores*'|
|[Erro do compilador C3804](compiler-error-c3804.md)|'*Member*': os métodos de acessador de uma propriedade devem ser todos estáticos ou todos não estáticos|
|[Erro do compilador C3805](compiler-error-c3805.md)|'*token*': token inesperado, esperado '} ' ou ', '|
|Erro do compilador C3806|'*token*': token inesperado, esperado um ' {' ou um inicializador de membro|
|[Erro do compilador C3807](compiler-error-c3807.md)|'*Type*': uma classe com o atributo ComImport não pode derivar de '*Type*', somente implementação de interface é permitida|
|[Erro do compilador C3808](compiler-error-c3808.md)|'*Type*': uma classe com o atributo ComImport não pode definir membro '*Member*', somente funções abstract ou DllImport são permitidas|
|[Erro do compilador C3809](compiler-error-c3809.md)|'*Type*': um tipo gerenciado/WinRT não pode ter funções/classes/interfaces Friend|
|Erro do compilador C3810|Obsoleto.|
|Erro do compilador C3811|Obsoleto.|
|[Erro do compilador C3812](compiler-error-c3812.md)|' __property ' deve ser o primeiro token em uma declaração de propriedade|
|[Erro do compilador C3813](compiler-error-c3813.md)|uma declaração de propriedade só pode aparecer dentro da definição de um tipo gerenciado/WinRT|
|Erro do compilador C3814|Obsoleto.|
|[Erro do compilador C3815](compiler-error-c3815.md)|o tipo de retorno do método '*Member*' deve corresponder ao tipo do último parâmetro de um setter|
|[Erro do compilador C3816](compiler-error-c3816.md)|"classe/ *membro*de struct" foi declarado anteriormente ou definido com um modificador gerenciado/WinRT diferente|
|[Erro do compilador C3817](compiler-error-c3817.md)|'*declaração*': a propriedade só pode ser aplicada a uma função|
|[Erro do compilador C3818](compiler-error-c3818.md)|a declaração de propriedade de matriz '*Property*' não deve sobrecarregar uma propriedade de índice '*Property*'|
|Erro do compilador C3819|Obsoleto.|
|[Erro do compilador C3820](compiler-error-c3820.md)|'*Identifier*': inicializadores devem ser gerenciados|
|[Erro do compilador C3821](compiler-error-c3821.md)|'*Function*': tipo ou função gerenciados não podem ser usados em uma função não gerenciada|
|Erro do compilador C3822|Obsoleto.|
|Erro do compilador C3823|Obsoleto.|
|[Erro do compilador C3824](compiler-error-c3824.md)|'*Type*': este tipo não pode aparecer neste contexto (parâmetro de função, tipo de retorno ou um membro estático)|
|[Erro do compilador C3825](compiler-error-c3825.md)|'*Type*': uma classe gerenciada/winrt só pode dar suporte a eventos gerenciados/winrt|
|Erro do compilador C3826|Obsoleto.|
|Erro do compilador C3827|o atributo padrão ' preterido ' pode não ter nenhum argumento ou um literal de cadeia de caracteres que descreva o motivo|
|[Erro do compilador C3828](compiler-error-c3828.md)|Não é possível especificar argumentos de posicionamento para uma expressão '*keyword*' para o tipo '*Type*'|
|Erro do compilador C3829|o atributo padrão ' noreturn ' só pode ser aplicado a funções|
|[Erro do compilador C3830](compiler-error-c3830.md)|'*type1*': não é possível herdar de '*type2*', tipos Value só podem herdar de classes de interface|
|[Erro do compilador C3831](compiler-error-c3831.md)|"*Identifier*": "*Type*" não pode ter um membro de dados fixado ou uma função de membro retornando um ponteiro de fixação|
|[Erro do compilador C3832](compiler-error-c3832.md)|'*TypeLib*': a biblioteca de tipos parece como se foi criada para ponteiros de 32 bits; Altere o qualificador ' ptrsize '|
|[Erro do compilador C3833](compiler-error-c3833.md)|'*Type*': tipo de destino inválido para *identificador*|
|[Erro do compilador C3834](compiler-error-c3834.md)|conversão explícita inválida para um ponteiro de fixação; em vez disso, use uma variável local fixa|
|Erro do compilador C3835|Obsoleto.|
|[Erro do compilador C3836](compiler-error-c3836.md)|um construtor estático não pode ter uma lista de inicializadores de membros|
|Erro do compilador C3837|atributos não são permitidos neste contexto|
|[Erro do compilador C3838](compiler-error-c3838.md)|Não é possível herdar de '*Type*'|
|[Erro do compilador C3839](compiler-error-c3839.md)|Não é possível alterar o alinhamento em um tipo gerenciado/WinRT|
|Erro do compilador C3840|Obsoleto.|
|Erro do compilador C3841|Obsoleto.|
|[Erro do compilador C3842](compiler-error-c3842.md)|'*Identifier*': não há suporte para qualificadores ' const ' e ' volatile ' em funções membro de tipos gerenciados/WinRT|
|Erro do compilador C3843|'*Identifier*': não há suporte para qualificadores de referência em funções membro de tipos gerenciados/WinRT|
|Erro do compilador C3844|'*Identifier*': não é possível importar o símbolo de '*Source*': já existe um '*Identifier*' no escopo atual|
|Erro do compilador C3845|Obsoleto.|
|[Erro do compilador C3846](compiler-error-c3846.md)|'*Identifier*': não é possível importar o símbolo de '*Source*': como '*Identifier*' já foi importado de outro assembly '*assembly*'|
|Erro do compilador C3847|Obsoleto.|
|[Erro do compilador C3848](compiler-error-c3848.md)|expressão com tipo '*Type*' perderia alguns qualificadores const-volatile para chamar '*Identifier*'|
|[Erro do compilador C3849](compiler-error-c3849.md)|a chamada function-Style em uma expressão do tipo '*Type*' perderia qualificadores const e/ou voláteis para todas as sobrecargas de operador disponíveis para todos os *números*|
|[Erro do compilador C3850](compiler-error-c3850.md)|'*token*': um nome de caractere universal especifica um caractere inválido|
|[Erro do compilador C3851](compiler-error-c3851.md)|'*token*': um nome de caractere universal não pode designar um caractere no conjunto de caracteres básico|
|[Erro do compilador C3852](compiler-error-c3852.md)|'*Member*' com tipo '*Type*': a inicialização de agregação não pôde inicializar este membro|
|[Erro do compilador C3853](compiler-error-c3853.md)|' = ': reinicializar uma referência ou atribuição por meio de uma referência a função é inválida|
|[Erro do compilador C3854](compiler-error-c3854.md)|a expressão à esquerda de ' = ' é avaliada como uma função. Não é possível atribuir a uma função (uma função não é um l-Value)|
|[Erro do compilador C3855](compiler-error-c3855.md)|'*Function*': modelo/parâmetro genérico '*Identifier*' é incompatível com a declaração|
|[Erro do compilador C3856](compiler-error-c3856.md)|'*Class*': classe não é um template de classe/genérico|
|[Erro do compilador C3857](compiler-error-c3857.md)|'*Template*': várias listas de parâmetros de modelo/genéricos não são permitidas|
|[Erro do compilador C3858](compiler-error-c3858.md)|'*Identifier*': não pode ser declarado novamente no escopo atual|
|[Erro do compilador C3859](compiler-error-c3859.md)|intervalo de memória virtual para PCH excedido; Recompile com uma opção de linha de comando de '-ZM*Number*' ou superior|
|[Erro do compilador C3860](compiler-error-c3860.md)|lista de argumentos de modelo/genérico a seguir template de classe/nome genérico deve listar parâmetros na ordem usada no modelo/lista de parâmetros genéricos|
|[Erro do compilador C3861](compiler-error-c3861.md)|'*Identifier*': identificador não encontrado|
|[Erro do compilador C3862](compiler-error-c3862.md)|'*Function*': não é possível compilar uma função não gerenciada com/CLR: pure ou/CLR: safe|
|Erro do compilador C3863|o tipo de matriz '*Type*' não pode ser atribuído|
|Erro do compilador C3864|Obsoleto.|
|[Erro do compilador C3865](compiler-error-c3865.md)|'*keyword*': só pode ser usado em funções membro nativas|
|[Erro do compilador C3866](compiler-error-c3866.md)|lista de argumentos ausente na chamada destruidor/finalizador|
|[Erro do compilador C3867](compiler-error-c3867.md)|'*Function*': sintaxe não padrão; Use ' & ' para criar um ponteiro para membro|
|[Erro do compilador C3868](compiler-error-c3868.md)|'*Type*': restrições no parâmetro genérico '*Parameter*' diferem das na declaração|
|[Erro do compilador C3869](compiler-error-c3869.md)|a restrição de gcnew está faltando na lista de parâmetros vazia ' () '|
|Erro do compilador C3870|'*Parameter*': ' __declspec (*especificador*) ' só pode ser aplicado a parâmetros de tipo integral|
|Erro do compilador C3871|"*Parameter*": "__declspec (Guard (overflow))" tem suporte apenas nos primeiros parâmetros 64 de uma função|
|[Erro do compilador C3872](compiler-error-c3872.md)|' 0x*Value*': este caractere não é permitido em um identificador|
|[Erro do compilador C3873](compiler-error-c3873.md)|' 0x*Value*': este caractere não é permitido como primeiro caractere de um identificador|
|[Erro do compilador C3874](compiler-error-c3874.md)|o tipo de retorno de '*Identifier*' deve ser '*type1*' em vez de '*type2*'|
|Erro do compilador C3875|chamada de função de membro não estática ausente na lista de argumentos|
|Erro do compilador C3876|Obsoleto.|
|Erro do compilador C3877|Obsoleto.|
|Erro do compilador C3878|Obsoleto.|
|Erro do compilador C3879|'*Member*': não pode ser um membro de dados InitOnly|
|[Erro do compilador C3880](compiler-error-c3880.md)|'*Member*': não pode ser um membro de dados literal|
|Erro do compilador C3881|Só é possível herdar o construtor da base direta|
|Erro do compilador C3882|'*Class*': o Construtor já foi herdado de '*Class*'|
|Erro do compilador C3883|'*Member*': um membro de dados InitOnly static deve ser inicializado|
|Erro do compilador C3884|'*Type*': uma matriz de tamanho desconhecido não pode ser inicializada por valor|
|Erro do compilador C3885|'*Type*': uma matriz de tamanho desconhecido não pode ser inicializada com uma lista de inicializador vazia|
|[Erro do compilador C3886](compiler-error-c3886.md)|'*Member*': um membro de dados literal deve ser inicializado|
|[Erro do compilador C3887](compiler-error-c3887.md)|'*Member*': o inicializador para um membro de dados literal deve ser uma expressão constante|
|[Erro do compilador C3888](compiler-error-c3888.md)|'*Member*': a expressão const associada a este membro de dados literal não é suportada por C++/CLI|
|Erro do compilador C3889|Obsoleto.|
|[Erro do compilador C3890](compiler-error-c3890.md)|'*Member*': não é possível obter o endereço de um membro de dados literal|
|[Erro do compilador C3891](compiler-error-c3891.md)|'*Member*': um membro de dados literal não pode ser usado como um l-Value|
|[Erro do compilador C3892](compiler-error-c3892.md)|'*Variable*': não é possível atribuir a uma variável que seja const|
|[Erro do compilador C3893](compiler-error-c3893.md)|'*Member*': o uso de l-Value de membro de dados InitOnly só é permitido em um construtor de instância da classe '*Class*'|
|[Erro do compilador C3894](compiler-error-c3894.md)|'*Member*': o uso de l-Value de membro de dados InitOnly static só é permitido no construtor de classe da classe '*Class*'|
|[Erro do compilador C3895](compiler-error-c3895.md)|'*Member*': *tipos* de membros de dados não podem ser ' volatile '|
|[Erro do compilador C3896](compiler-error-c3896.md)|'*Member*': inicializador inadequado: Este membro de dados literal só pode ser inicializado com ' nullptr '|
|Erro do compilador C3897|Obsoleto.|
|[Erro do compilador C3898](compiler-error-c3898.md)|'*Member*': *tipos* membros de dados só podem ser membros de tipos gerenciados|
|[Erro do compilador C3899](compiler-error-c3899.md)|'*Member*': o uso de l-Value de membro de dados InitOnly não é permitido diretamente dentro de uma região Parallel na classe '*Class*'|
|[Erro do compilador C3900](compiler-error-c3900.md)|'*Member*': não permitido no escopo atual|
|[Erro do compilador C3901](compiler-error-c3901.md)|'*Function*': deve possuir tipo de retorno '*Type*'|
|[Erro do compilador C3902](compiler-error-c3902.md)|'*Function*': o tipo do último parâmetro deve ser '*Type*'|
|[Erro do compilador C3903](compiler-error-c3903.md)|'*Property*': não tem o método set ou Get|
|[Erro do compilador C3904](compiler-error-c3904.md)|'*Property*': deve especificar parâmetro (s) de *número*|
|Erro do compilador C3905|Não há suporte para acessos não alinhados para o tipo intrínseco '*Type*'|
|Erro do compilador C3906|o tipo intrínseco '*Type*' não é um tipo de argumento ou retorno com suporte para funções vararg ou sem protótipo|
|Erro do compilador C3907|Obsoleto.|
|[Erro do compilador C3908](compiler-error-c3908.md)|nível de acesso menos restritivo do que o de '*identificador*'|
|[Erro do compilador C3909](compiler-error-c3909.md)|uma declaração de evento gerenciado/WinRT deve ocorrer em um tipo gerenciado/WinRT|
|[Erro do compilador C3910](compiler-error-c3910.md)|'*Event*': deve definir o membro '*Member*'|
|[Erro do compilador C3911](compiler-error-c3911.md)|'*Member*': função deve possuir tipo '*Type*'|
|[Erro do compilador C3912](compiler-error-c3912.md)|'*Event*': tipo de evento deve ser um tipo delegate|
|[Erro do compilador C3913](compiler-error-c3913.md)|uma propriedade padrão deve ser indexada|
|[Erro do compilador C3914](compiler-error-c3914.md)|uma propriedade padrão não pode ser estática|
|[Erro do compilador C3915](compiler-error-c3915.md)|'*Identifier*' não tem propriedade indexada padrão (indexador de classe)|
|Erro do compilador C3916|Obsoleto.|
|[Erro do compilador C3917](compiler-error-c3917.md)|'*token*': estilo de declaração de *construção* obsoleto (você quis dizer usar ' [' '] ' em vez disso?)|
|[Erro do compilador C3918](compiler-error-c3918.md)|uso requer que '*Identifier*' seja um membro de dados|
|[Erro do compilador C3919](compiler-error-c3919.md)|'*Function*': função deve possuir o tipo '*return_type* (*Type*) '|
|[Erro do compilador C3920](compiler-error-c3920.md)|'*Operator*': não é possível definir um operador de CLR/de decréscimo de sufixo/Winrt que chama o operador CLR/winrt de sufixo chama o prefixo correspondente de CLR/winrt (op_Increment/op_Decrement), mas com semântica de sufixo|
|Erro do compilador C3921|Obsoleto.|
|Erro do compilador C3922|Obsoleto.|
|[Erro do compilador C3923](compiler-error-c3923.md)|'*Member*': as definições de classe local, struct ou Union não são permitidas em uma função membro de uma classe gerenciada/WinRT|
|Erro do compilador C3924|erro no argumento #*número* de '*Construtor*' de chamada de construtor delegado:|
|Erro do compilador C3925|esperado um loop (for, while ou do) após a diretiva '*diretivo*'|
|Erro do compilador C3926|constante inválida na diretiva ' Parallel '|
|Erro do compilador C3927|'-> ': o tipo de retorno à direita não é permitido após um Declarador de não função|
|Erro do compilador C3928|'-> ': o tipo de retorno à direita não é permitido após um Declarador entre parênteses|
|Erro do compilador C3929|Obsoleto.|
|Erro do compilador C3930|'*Function*': nenhuma função sobrecarregada tem especificadores de restrição que são compatíveis com o contexto de ambiente '*Context*'|
|Erro do compilador C3931|'*Type*': não é possível chamar uma função que tem especificadores de restrição que são incompatíveis com o contexto de ambiente|
|Erro do compilador C3932|Obsoleto.|
|Erro do compilador C3933|'*Class*': especificadores de restrição do destruidor devem cobrir a União de restrições em todos os construtores|
|Erro do compilador C3934|uma função que está em qualquer forma de ' Main ' não pode ter especificadores de restrição diferentes de restrict (CPU)|
|Erro do compilador C3935|'*identificador*': redefinição; sobrepondo especificadores de restrição|
|Erro do compilador C3936|'*Identifier*': especificador de restrição não reconhecido|
|Erro do compilador C3937|especificador de restrição vazio não é permitido|
|Erro do compilador C3938|'*Identifier*': não há suporte para especificadores de várias restrições em funções \042C\042 externas|
|Erro do compilador C3939|'*Identifier*': ponteiro para funções membro, ponteiros de função, referências a funções com especificador de restrição ' amp ' não são permitidas|
|Erro do compilador C3940|'*Identifier*': identificador não encontrado-possível incompatibilidade entre versões de biblioteca e compilador. Verifique a correspondência de vccorlib. h/. lib, vccorlib120. dll e c1xx. dll|
|Erro do compilador C3941|'*Condition*': requer a opção de linha de comando '/CLR '|
|Erro do compilador C3942|Obsoleto.|
|Erro do compilador C3943|Obsoleto.|
|Erro do compilador C3944|Obsoleto.|
|Erro do compilador C3945|'*Type*': não é possível lançar ou capturar um objeto winrt que não deriva da plataforma:: Exception|
|Erro do compilador C3946|'*Type*': typeid não pode ser aplicado a este tipo|
|Erro do compilador C3947|'*typeid*': typeid não pode ser aplicado a uma expansão de pacote|
|Erro do compilador C3948|'*keyword*': uma expansão de pacote não pode aparecer neste contexto|
|Erro do compilador C3949|uma expansão de pacote, '... ', não pode aparecer em um Declarador abstrato entre parênteses|
|Erro do compilador C3950|Obsoleto.|
|Erro do compilador C3951|Não é possível usar o ponteiro para membro no tipo de WinRT projetado '*Type*'. Em vez disso, use um delegado.|
|Erro do compilador C3952|'*Type*': WinRT não oferece suporte a matrizes ' in/out '. Use ' const array\<T > ^ ' para ' in ' e ' WriteOnlyArray\<T > ' ou ' array\<T > ^ * ' para ' out ' em APIs públicas|
|Erro do compilador C3953|Não é possível usar a classe gerenciada '*Type*' no módulo WinRT.|
|Erro do compilador C3954|'*Type*': uma matriz retornada de um método publicado em um tipo WinRT deve usar o formato ' array\<t > ^ '|
|Erro do compilador C3955|'*Type*': um construtor público não pode conter um parâmetro ' out ' ou ' WriteOnlyArray\<t > '|
|Erro do compilador C3956|'*Type*': o tipo está marcado como exclusivo para '*Type*' e não pode ser usado como uma base de '*derived_type*'|
|Erro do compilador C3957|'*Type*': não é possível usar ' New ' em um tipo de WinRT; em vez disso, use ' ref New '|
|Erro do compilador C3958|'*Type*': não é possível usar ' gcnew ' em um tipo de WinRT; em vez disso, use ' ref New '|
|Erro do compilador C3959|' ref New ' só pode ser usado para criar um objeto com o tipo WinRT|
|Erro do compilador C3960|Obsoleto.|
|Erro do compilador C3961|Não há suporte para o construtor estático|
|Erro do compilador C3962|classe genérica sem suporte|
|Erro do compilador C3963|Não há suporte para a matriz multidimensional|
|Erro do compilador C3964|Não há suporte para a matriz denteada|
|Erro do compilador C3965|Não há suporte para a matriz de parâmetros|
|Erro do compilador C3966|'*Function*': não há suporte para a função genérica|
|Erro do compilador C3967|erro ao importar '*identificador*' do módulo '*módulo*'|
|Erro do compilador C3968|o token '*token*' não é válido como separador de nome de módulo; Use o período ('. ') em vez disso|
|Erro do compilador C3969|nomes de módulo inconsistentes: '*Module1*' e '*Module1*'|
|Erro do compilador C3970|'*Identifier*': '*palavra-chave*' só pode ser aplicada a ' ref class ' ou ' ref struct ' no escopo global ou escopo de namespace|
|Erro do compilador C3971|'*Type*': a definição parcial não pode aparecer após a definição completa|
|Erro do compilador C3972|'*Type*': ' partial ' só pode ser aplicado a declarações de classe ou definições|
|Erro do compilador C3973|Obsoleto.|
|Erro do compilador C3974|Obsoleto.|
|Erro do compilador C3975|" *identificador*de classe/struct" foi declarado anteriormente ou definido com um modificador diferente|
|Erro do compilador C3976|'*identifier1*' deve ser declarado como ' Public ' para usar '*identifier2*'|
|Erro do compilador C3977|O uso requer uma referência a um assembly que define '*Identifier*'|
|Erro do compilador C3978|'*Identifier*': uma propriedade estática não é permitida como um membro de uma interface do WinRT ou tipo de valor|
|Erro do compilador C3979|'*Type*': usar atributo '*Attribute*' em vez de '*Value*'|
|Erro do compilador C3980|'*Type*' não pode ser emitido em metadados|
|Erro do compilador C3981|'*Type*': um tipo de valor não pode possuir nenhum membro de dados estáticos '*Identifier*'|
|Erro do compilador C3982|'*Type*': um tipo de valor não pode ter quaisquer membros de dados não públicos '*Identifier*'|
|Erro do compilador C3983|'*Type*': um tipo de valor não pode ter nenhum '*identificador*' de membros públicos sem dados|
|Erro do compilador C3984|'*Type*': um tipo sem valor não pode possuir nenhum membro de dados públicos '*Identifier*'|
|Erro do compilador C3985|'*Identifier*': a assinatura do membro público contém o tipo particular '*Member*'|
|Erro do compilador C3986|'*Identifier*': assinatura de membro público contém tipo nativo '*Member*'|
|Erro do compilador C3987|'*Identifier*': assinatura de membro público contém tipo nativo '*Type*'|
|Erro do compilador C3988|'*Type*': um tipo nativo não pode ser público|
|Erro do compilador C3989|'*Type*': um tipo aninhado não pode ser público|
|Erro do compilador C3990|'*Type*': atributo '*Attribute*' não pode ser private ou Nested|
|Erro do compilador C3991|'*Type*': não é possível implementar uma interface '*interface*' não pública ou aninhada|
|Erro do compilador C3992|'*Identifier*': assinatura de membro público contém tipo inválido '*Type*'|
|Erro do compilador C3993|'*Type*': um tipo de valor deve conter pelo menos um campo público|
|Erro do compilador C3994|'*Type*': um tipo de valor não pode implementar interfaces ou ter funções virtuais|
|Erro do compilador C3995|'*Type*': um tipo de valor não pode ter nenhum '*identificador*' de membros de evento|
|Erro do compilador C3996|Obsoleto.|
|Erro do compilador C3998|'*versão*c++ ': C++ versão sem suporte; Padronizando para '*versão*c++ '|
|Erro do compilador C3999|ERRO desconhecido escolha o comando de suporte técnico no menu da C++ ajuda visual ou abra o arquivo de ajuda do suporte técnico para obter mais informações|

## <a name="see-also"></a>Consulte também

[Erros eC++ avisos do C/compilador e ferramentas de compilação](../compiler-errors-1/c-cpp-build-errors.md) \
[Erros do compilador C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
