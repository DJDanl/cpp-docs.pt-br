---
title: C26441
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
ms.openlocfilehash: 0e6d609ee8b24f40aa06250515f5e60d088a2289
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369890"
---
# <a name="c26441-no_unnamed_guards"></a>C26441 NO_UNNAMED_GUARDS

"Objetos de guarda devem ser nomeados."

**C++ Diretrizes Principais**: CP.44: Lembre-se de nomear seu lock_guards e unique_locks

A biblioteca padrão fornece algumas classes úteis que ajudam a controlar o acesso simultâneo aos recursos. Objetos desses tipos bloqueiam acesso exclusivo durante a vida útil. Isso implica que cada objeto de bloqueio deve ser nomeado, ou seja, ter uma vida útil claramente definida que se estende ao longo do período em que as operações de acesso são executadas. Assim, não atribuir um objeto de bloqueio a uma variável é um erro que efetivamente desabilita o mecanismo de bloqueio (porque as variáveis temporárias são transitórias). Esta regra tenta pegar casos simples de tal comportamento não intencional.

## <a name="remarks"></a>Comentários

- Apenas os tipos de bloqueio padrão são rastreados: std::scoped_lock, std::unique_lock e std::lock_quard.
  - Apenas chamadas simples para construtores são analisadas. A expressão inicializadora mais complexa pode levar a resultados imprecisos, mas este é um cenário bastante incomum.
  - Os bloqueios passaram como argumentos para funcionar chamadas ou retornados à medida que os resultados das chamadas de função são ignorados.
  - Os bloqueios criados como temporários, mas atribuídos a referências nomeadas para prolongar sua vida útil são ignorados.

## <a name="example"></a>Exemplo

variável escopo falta

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

variável escopo ausente - corrigido

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```
