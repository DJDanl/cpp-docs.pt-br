---
title: C26446
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26446
helpviewer_keywords:
- C26446
ms.openlocfilehash: eff94d61f6c792a6ad720a24b049a25d9d354f91
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215069"
---
# <a name="c26446-use_gsl_at"></a>USE_GSL_AT C26446

Prefira usar `gsl::at()` em vez do operador subscrito desmarcado.

Diretrizes Principais do C++: [Bounds. 4: não use funções de biblioteca padrão e tipos que não estão associados-verificados](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#probounds-bounds-safety-profile).

O perfil de limites do Diretrizes Principais do C++ tenta eliminar manipulações não seguras de memória, evitando o uso de ponteiros brutos e operações desmarcadas. Uma maneira de executar o acesso com verificação de intervalo uniforme aos buffers é usar o `gsl::at()` utilitário da biblioteca de suporte de diretrizes. Também é uma boa prática contar com implementações padrão de `at()` disponíveis em contêineres STL.

Essa regra ajuda a localizar locais onde o acesso potencialmente desmarcado é executado por meio de chamadas para Operator \[ ] (). Na maioria dos casos, essas chamadas podem ser facilmente substituídas pelo `gsl::at()` .

- O acesso a matrizes com tamanho conhecido é sinalizado quando um índice não constante é usado em um operador subscrito. Índices de constantes são tratados pelo [C26483 STATIC_INDEX_OUT_OF_RANGE](c26483.md).
- A lógica para avisar sobre chamadas de operador sobrecarregadas [] é mais complexa:
  - Se o índice for não integral, a chamada será ignorada. Isso também manipula a indexação em mapas padrão, pois os parâmetros nesses operadores são passados por referência.
  - Se o operador estiver marcado como sem lançamento (usando **`noexcept`** , **throw ()** ou **`__declspec(nothrow)`** ), a chamada será sinalizada. Supõe-se que se o operador subscrito nunca lançar exceções, ele não executará verificações de intervalo ou essas verificações ficarão obscuras.
  - Se o operador não estiver marcado como não-lançamento, ele poderá ser sinalizado se vier de um contêiner STL que também define uma `at()` função de membro convencional (tais funções são detectadas por correspondência de nome simples).
  - A regra não avisa sobre chamadas para `at()` funções padrão. Essas funções são seguras e substituí-las pelo `gsl::at()` não trará muito valor.
- A indexação no `std::basic_string_view<>` não é segura, portanto, um aviso é emitido. A exibição de cadeia de caracteres padrão pode ser substituída por `gsl::basic_string_span<>` , que é sempre marcada como verificada.
- A implementação não considera o intervalo de verificações que o código do usuário pode ter em algum lugar em loops ou branches. A precisão aqui é negociada para o desempenho. Em geral, as verificações de intervalo explícitas geralmente podem ser substituídas por iteradores mais confiáveis ou de loops aprimorados mais concisos.
