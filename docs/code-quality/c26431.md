---
title: C26431
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26431
helpviewer_keywords:
- C26431
ms.assetid: 40be6032-c8de-49ab-8e43-e8eedc0ca0ba
ms.openlocfilehash: 1be7c1c8ce26a40848c07b4e7f71e2f3da944386
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365652"
---
# <a name="c26431-dont_test_notnull"></a>C26431 DONT_TEST_NOTNULL

"O tipo de expressão já é gsl::not_null. Não testá-lo para nulidade.

**Diretrizes c++ :** F.23:\<Use um> not_null T para indicar que "nulo" não é um valor válido

O tipo de marcador gsl::not_null da Biblioteca de Suporte de Diretrizes é usado para indicar claramente valores que nunca são ponteiros nulos. Causa um fracasso difícil se tal suposição não for realizada em tempo de execução. Portanto, obviamente, não há necessidade de verificar a nulidade se a expressão avalia para um resultado do tipo gsl::not_null.

## <a name="remarks"></a>Comentários

- Uma vez que gsl::not_null em si é uma classe de invólucro de ponteiro fino, a regra realmente rastreia variáveis temporárias que mantêm resultados de chamadas para o operador de conversão sobrecarregado (que retorna objeto de ponteiro contido). Tal lógica torna essa regra aplicável a expressões que envolvem variáveis e eventualmente têm resultado do tipo gsl::not_null. Mas atualmente ele ignora expressões que contêm chamadas de função retornando gsl::not_null.
  - A heurística atual para verificação de nulidade detecta os seguintes contextos:
  - expressão símbolo em uma condição de ramo, por exemplo "if (p) { ... }";
  - operações lógicas não bitwise;
  - operações de comparação onde um operand é uma expressão constante que avalia a zero.

## <a name="example"></a>Exemplo

verificações nulas desnecessárias revelam lógica questionável

```cpp
class type {
public:
    template<class T> bool is() const;
    template<class T> gsl::not_null<const T*> as() const;
    //...
};

class alias_type : public type {
public:
    gsl::not_null<const type*> get_underlying_type() const;
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut)                                     // C26431
        {
            const auto uat = ut->as<alias_type>();
            if (uat)                                // C26431, also incorrect use of API!
                return uat->get_root_type();

            return ut;
        }

        return this;                                // Alias to nothing? Actually, dead code!
    }
    //...
};
```

verificações nulas desnecessárias revelam lógica questionável - reformulada

```cpp
    //...
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut->is<alias_type>())
            return ut->as<alias_type>()->get_root_type();

        return ut;
    }
    //...
```
