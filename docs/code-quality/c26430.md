---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
ms.openlocfilehash: 73f69b54d7f4635be6fb67099b2864ea3882eb24
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81316901"
---
# <a name="c26430-test_on_all_paths"></a>C26430 TEST_ON_ALL_PATHS

"O símbolo não é testado para nulidade em todos os caminhos."

**Diretrizes c++ :** F.23:\<Use um> not_null T para indicar que "nulo" não é um valor válido

Se o código verificar a nulidade das variáveis de ponteiro, ele deve fazer isso de forma consistente e validar ponteiros em todos os caminhos. Às vezes, verificar demais a nulidade ainda é melhor do que a possibilidade de uma queda dura em um dos galhos complicados. Idealmente, esse código deve ser refatorado para ser menos complexo (dividindo-se em múltiplas funções) e confiar em marcadores como gsl::not_null (ver Biblioteca de Suporte de Diretrizes) para isolar partes do algoritmo que podem fazer uma suposição segura sobre valores de ponteiro válidos. A regra TEST_ON_ALL_PATHS ajuda a encontrar lugares onde as verificações de nulidade são inconsistentes (portanto, as suposições podem exigir revisão) ou bugs reais onde o valor nulo potencial pode contornar a verificação de nulidade em alguns dos caminhos do código.

## <a name="remarks"></a>Comentários

- Esta regra espera que o código desfaça uma variável de ponteiro para que a verificação de nulidade (ou a aplicação do valor não nulo) seja justificada. Se não houver desreferência, a regra está suspensa.
  - A implementação atual lida apenas com ponteiros simples (ou seus pseudônimos) e não detecta ponteiros inteligentes, embora as verificações de nulidade também sejam aplicáveis a ponteiros inteligentes.
  - Uma variável é marcada como verificada para nulidade quando é usada nos seguintes contextos:
  - como uma expressão símbolo em uma condição de ramo, por exemplo, "se (p) { ... }";
  - operações lógicas não bitwise;
  - operações de comparação onde um operand é uma expressão constante que avalia a zero.
  - A regra não tem rastreamento completo do fluxo de dados e pode produzir resultados incorretos nos casos em que são usadas verificações indiretas (por exemplo, quando a variável intermediária possui valor nulo e posteriormente usada em comparação).
  - Verificações implícitas de nulidade são assumidas quando o valor do ponteiro é atribuído a partir de:
  - uma alocação realizada com o operador de arremesso novo;
  - um ponteiro obtido a partir do tipo marcado com gsl::not_null.

## <a name="example"></a>Exemplo

testes inconsistentes revelam erro de lógica

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

testes inconsistentes revelam erro de lógica - corrigido

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
