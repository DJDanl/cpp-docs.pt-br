---
title: Classe CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375708"
---
# <a name="cdc-class"></a>Classe CDC

Define uma classe de objetos de contexto de dispositivo.

## <a name="syntax"></a>Sintaxe

```
class CDC : public CObject
```

## <a name="members"></a>Membros

### <a name="public-constructors"></a>Construtores públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::CDC](#cdc)|Constrói um objeto `CDC`.|

### <a name="public-methods"></a>Métodos públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Encerra o trabalho de impressão atual, apagando tudo o que o `StartDoc` aplicativo escreveu para o dispositivo desde a última chamada da função do membro.|
|[CDC::AbortPath](#abortpath)|Fecha e descarta quaisquer caminhos no contexto do dispositivo.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copia o comentário de um buffer em um metaarquivo de formato aprimorado especificado.|
|[CDC::AlphaBlend](#alphablend)|Exibe bitmaps que possuem pixels transparentes ou semitransparentes.|
|[CDC::AngleArc](#anglearc)|Desenha um segmento de linha e um arco, e move a posição atual para o ponto final do arco.|
|[CDC::Arc](#arc)|Desenha um arco elíptico.|
|[CDC:::ArcTo](#arcto)|Desenha um arco elíptico. Esta função é `Arc`semelhante a, exceto que a posição atual é atualizada.|
|[CDC::Anexar](#attach)|Anexa um contexto de `CDC` dispositivo Windows a este objeto.|
|[CDC::StartPath](#beginpath)|Abre um suporte de caminho no contexto do dispositivo.|
|[CDC::BitBlt](#bitblt)|Copia um bitmap de um contexto de dispositivo especificado.|
|[CDC::Acorde](#chord)|Desenha um acorde (uma figura fechada limitada pela intersecção de uma elipse e um segmento de linha).|
|[CDC::CloseFigure](#closefigure)|Fecha uma figura aberta em um caminho.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Cria um contexto de dispositivo de memória compatível com outro contexto do dispositivo. Você pode usá-lo para preparar imagens na memória.|
|[CDC::CreateDC](#createdc)|Cria um contexto de dispositivo para um dispositivo específico.|
|[CDC::CreateIC](#createic)|Cria um contexto de informação para um dispositivo específico. Isso fornece uma maneira rápida de obter informações sobre o dispositivo sem criar um contexto de dispositivo.|
|[CDC::DeleteDC](#deletedc)|Exclui o contexto do dispositivo `CDC` Windows associado a este objeto.|
|[CDC::DeleteTempMap](#deletetempmap)|Chamado pelo `CWinApp` manipulador de tempo ocioso para excluir qualquer objeto temporário `CDC` criado por `FromHandle`. Também destaca o contexto do dispositivo.|
|[CDC::Detach](#detach)|Destaca o contexto do dispositivo `CDC` Windows deste objeto.|
|[CDC::DPtoHIMÉTRICO](#dptohimetric)|Converte unidades de dispositivos em unidades HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Converte unidades de dispositivos em unidades lógicas.|
|[CDC::Draw3dRect](#draw3drect)|Desenha um retângulo tridimensional.|
|[CDC::DrawDragRect](#drawdragrect)|Apaga e redesenha um retângulo à medida que é arrastado.|
|[CDC::DrawEdge](#drawedge)|Desenha as bordas de um retângulo.|
|[CDC::DrawEscape](#drawescape)|Acessa os recursos de desenho de uma tela de vídeo que não estão diretamente disponíveis através da interface do dispositivo gráfico (GDI).|
|[CDC::DrawFocusRect](#drawfocusrect)|Desenha um retângulo no estilo usado para indicar foco.|
|[CDC::DrawFrameControl](#drawframecontrol)|Desenhe um controle de quadros.|
|[CDC::DrawIcon](#drawicon)|Desenha um ícone.|
|[CDC::DrawState](#drawstate)|Exibe uma imagem e aplica um efeito visual para indicar um estado.|
|[CDC::DrawText](#drawtext)|Desenha texto formatado no retângulo especificado.|
|[CDC::DrawTextEx](#drawtextex)|Desenha texto formatado no retângulo especificado usando formatos adicionais.|
|[CDC::Elipse](#ellipse)|Desenha uma elipse.|
|[CDC::EndDoc](#enddoc)|Termina um trabalho de `StartDoc` impressão iniciado pela função de membro.|
|[CDC::EndPage](#endpage)|Informa o driver do dispositivo que uma página está terminando.|
|[CDC::EndPath](#endpath)|Fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto do dispositivo.|
|[CDC::EnumObjects](#enumobjects)|Enumera as canetas e pincéis disponíveis em um contexto de dispositivo.|
|[CDC::Escape](#escape)|Permite que os aplicativos acessem instalações que não estão diretamente disponíveis de um determinado dispositivo através do GDI. Também permite acesso às funções de escape do Windows. As chamadas de fuga feitas por um aplicativo são traduzidas e enviadas para o driver do dispositivo.|
|[CDC::ExcluaClipRect](#excludecliprect)|Cria uma nova região de recorte que consiste na região de recorte existente menos o retângulo especificado.|
|[CDC::ExcluaUpdateRgn](#excludeupdatergn)|Impede o desenho dentro de áreas inválidas de uma janela, excluindo uma região atualizada na janela de uma região de recorte.|
|[CDC::ExtFloodFill](#extfloodfill)|Preenche uma área com o pincel atual. Fornece mais flexibilidade do que a função [CDC::Membro FloodFill.](#floodfill)|
|[CDC::ExtTextOut](#exttextout)|Grava uma seqüência de caracteres dentro de uma região retangular usando a fonte selecionada no momento.|
|[CDC::FillPath](#fillpath)|Fecha quaisquer figuras abertas no caminho atual e preenche o interior do caminho usando o pincel atual e o modo de enchimento do polígono.|
|[CDC::FillRect](#fillrect)|Preenche um determinado retângulo usando um pincel específico.|
|[CDC::FillRgn](#fillrgn)|Preenche uma região específica com o pincel especificado.|
|[CDC:::FillSolidRect](#fillsolidrect)|Preenche um retângulo com uma cor sólida.|
|[CDC::FlattenPath](#flattenpath)|Transforma quaisquer curvas no caminho selecionado no contexto atual do dispositivo e transforma cada curva em uma seqüência de linhas.|
|[CDC::Preenchimento de inundações](#floodfill)|Preenche uma área com o pincel atual.|
|[CDC::FrameRect](#framerect)|Desenha uma borda em torno de um retângulo.|
|[CDC::FrameRgn](#framergn)|Desenha uma borda em torno de uma região específica usando um pincel.|
|[CDC::FromHandle](#fromhandle)|Retorna um ponteiro `CDC` para um objeto quando dado uma alça a um contexto do dispositivo. Se `CDC` um objeto não estiver conectado à `CDC` alça, um objeto temporário será criado e anexado.|
|[CDC::GetArcDirection](#getarcdirection)|Retorna a direção do arco atual para o contexto do dispositivo.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Recupera a configuração para o filtro de proporção atual.|
|[CDC::GetBkColor](#getbkcolor)|Recupera a cor de fundo atual.|
|[CDC::GetBkMode](#getbkmode)|Recupera o modo de fundo.|
|[CDC::GetBoundsRect](#getboundsrect)|Retorna o retângulo delimitador acumulado atual para o contexto do dispositivo especificado.|
|[CDC::Getbrushorg](#getbrushorg)|Recupera a origem do pincel atual.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Recupera as larguras, em unidades lógicas, de caracteres consecutivos em uma determinada faixa da fonte atual.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Recupera as larguras, em unidades lógicas, de índices de glifo consecutivos em uma faixa especificada da fonte TrueType atual.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Recupera vários tipos de informações em uma seqüência de caracteres.|
|[CDC::GetCharWidth](#getcharwidth)|Recupera as larguras fracionadas de caracteres consecutivos em uma determinada faixa da fonte atual.|
|[CDC::getcharwidthi](#getcharwidthi)|Recupera as larguras, em coordenadas lógicas, de índices de glifo consecutivos em uma faixa especificada da fonte atual.|
|[CDC::GetClipBox](#getclipbox)|Recupera as dimensões do retângulo delimitador mais apertado ao redor do limite de recorte atual.|
|[CDC::Obter ajuste de cores](#getcoloradjustment)|Recupera os valores de ajuste de cor para o contexto do dispositivo.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retorna um ponteiro para `CBitmap` o objeto selecionado no momento.|
|[CDC::GetCurrentbrush](#getcurrentbrush)|Retorna um ponteiro para `CBrush` o objeto selecionado no momento.|
|[CDC::GetCurrentFont](#getcurrentfont)|Retorna um ponteiro para `CFont` o objeto selecionado no momento.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retorna um ponteiro para `CPalette` o objeto selecionado no momento.|
|[CDC::GetCurrentPen](#getcurrentpen)|Retorna um ponteiro para `CPen` o objeto selecionado no momento.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Recupera a posição atual da caneta (em coordenadas lógicas).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Recupera a cor atual do pincel.|
|[CDC::GetDCPenColor](#getdcpencolor)|Recupera a cor atual da caneta.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Recupera um tipo especificado de informações específicas do dispositivo sobre os recursos de um determinado dispositivo de exibição.|
|[CDC::GetFontData](#getfontdata)|Recupera informações métricas de fonte de um arquivo de fonte escalável. As informações a serem recuperadas são identificadas especificando um deslocamento no arquivo de fonte e o comprimento das informações a serem devolvidas.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retorna informações sobre a fonte selecionada no momento para o contexto de exibição especificado.|
|[CDC:::GetGlyphOutline](#getglyphoutline)|Recupera a curva de contorno ou bitmap para um caractere de contorno na fonte atual.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Recupera o modo gráfico atual para o contexto especificado do dispositivo.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Recupera um pincel de meio tom.|
|[CDC::GetKerningPairs](#getkerningpairs)|Recupera os pares de kerning de caracteres para a fonte atualmente selecionada no contexto do dispositivo especificado.|
|[CDC::GetLayout](#getlayout)|Recupera o layout de um contexto de dispositivo (DC). O layout pode ser da esquerda para a direita (padrão) ou da direita para a esquerda (espelhado).|
|[CDC::GetMapMode](#getmapmode)|Recupera o modo de mapeamento atual.|
|[CDC::GetMiterLimit](#getmiterlimit)|Retorna o limite de miter para o contexto do dispositivo.|
|[CDC::GetNearestColor](#getnearestcolor)|Recupera a cor lógica mais próxima de uma cor lógica especificada que o determinado dispositivo pode representar.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Recupera informações da métrica de fonte para fontes TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Recupera as larguras de caracteres individuais em um grupo consecutivo de caracteres da fonte atual usando o contexto do dispositivo de saída.|
|[CDC::Get'''' '''''''''''''''''''''](#getoutputtabbedtextextent)|Calcula a largura e a altura de uma seqüência de caracteres no contexto do dispositivo de saída.|
|[CDC::getOutputTextExtent](#getoutputtextextent)|Calcula a largura e a altura de uma linha de texto no contexto do dispositivo de saída usando a fonte atual para determinar as dimensões.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Recupera as métricas para a fonte atual do contexto do dispositivo de saída.|
|[CDC::GetPath](#getpath)|Recupera as coordenadas que definem os pontos finais das linhas e os pontos de controle das curvas encontradas no caminho selecionado no contexto do dispositivo.|
|[CDC::GetPixel](#getpixel)|Recupera o valor de cor RGB do pixel no ponto especificado.|
|[CDC::GetPolyFillmode](#getpolyfillmode)|Recupera o modo de enchimento do polígono atual.|
|[CDC::GetROP2](#getrop2)|Recupera o modo de desenho atual.|
|[CDC::GetSafeHdc](#getsafehdc)|Retorna [CDC::m_hDC](#m_hdc), o contexto do dispositivo de saída.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Recupera o modo de alongamento do bitmap atual.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcula a largura e a altura de uma seqüência de caracteres no contexto do dispositivo de atributo.|
|[CDC::GetTextalign](#gettextalign)|Recupera os sinalizadores de alinhamento de texto.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Recupera a configuração atual para a quantidade de espaçamento entre caracteres.|
|[CDC::GetTextColor](#gettextcolor)|Recupera a cor de texto atual.|
|[CDC::GetTextExtent](#gettextextent)|Calcula a largura e a altura de uma linha de texto no contexto do dispositivo de atributo usando a fonte atual para determinar as dimensões.|
|[CDC::getTextextentexPointi](#gettextextentexpointi)|Recupera o número de caracteres em uma seqüência especificada que caberá dentro de um espaço especificado e preenche uma matriz com a extensão de texto para cada um desses caracteres.|
|[CDC::getTextExtentpointI](#gettextextentpointi)|Recupera a largura e a altura da matriz especificada de índices de glifo.|
|[CDC::GetTextFace](#gettextface)|Copia o nome de tipo da fonte atual em um buffer como uma seqüência de seqüência sumida.|
|[CDC::GetTextMetrics](#gettextmetrics)|Recupera as métricas para a fonte atual a partir do contexto do dispositivo de atributo.|
|[CDC::GetViewportExt](#getviewportext)|Recupera as extensões x e y do viewport.|
|[CDC::GetViewportOrg](#getviewportorg)|Recupera as coordenadas x e y da origem do viewport.|
|[CDC::GetWindow](#getwindow)|Retorna a janela associada ao contexto do dispositivo de exibição.|
|[CDC::GetWindowExt](#getwindowext)|Recupera as extensões x e y da janela associada.|
|[CDC::GetWindowOrg](#getwindoworg)|Recupera as coordenadas x e y da origem da janela associada.|
|[CDC::GetWorldTransform](#getworldtransform)|Recupera o espaço mundial atual para a transformação do espaço de página.|
|[CDC::GradientFill](#gradientfill)|Preenche estruturas retângulos e triângulos com uma cor gradadora.|
|[CDC::GrayString](#graystring)|Desenha texto escurecido (cinza) no local dado.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Converte unidades HIMETRIC em unidades de dispositivo.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Converte unidades HIMETRIC em unidades lógicas.|
|[CDC::IntersectClipRect](#intersectcliprect)|Cria uma nova região de recorte formando a intersecção da região atual e um retângulo.|
|[CDC::InvertRect](#invertrect)|Inverte o conteúdo de um retângulo.|
|[CDC::InvertRgn](#invertrgn)|Inverte as cores em uma região.|
|[CDC::IsPrinting](#isprinting)|Determina se o contexto do dispositivo está sendo usado para impressão.|
|[CDC::LineTo](#lineto)|Desenha uma linha da posição atual até, mas não incluindo, um ponto.|
|[CDC::LPtoDP](#lptodp)|Converte unidades lógicas em unidades de dispositivos.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Converte unidades lógicas em unidades HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Combina os dados de cores para os bitmaps de origem e destino usando a determinada operação de máscara e raster.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Altera a transformação do mundo para um contexto de dispositivo usando o modo especificado.|
|[CDC::MoveTo](#moveto)|Move a posição atual.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Move a região de recorte do dispositivo dado.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifica a origem do viewport em relação às coordenadas da origem atual do viewport.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifica a origem da janela em relação às coordenadas da origem da janela atual.|
|[CDC::PaintRgn](#paintrgn)|Preenche uma região com o pincel selecionado.|
|[CDC::PatBlt](#patblt)|Cria um padrão de bits.|
|[CDC::Pie](#pie)|Desenha uma cunha em forma de torta.|
|[CDC::PlayMetaFile](#playmetafile)|Reproduz o conteúdo do metaarquivo especificado no determinado dispositivo. A versão aprimorada `PlayMetaFile` do exibe a imagem armazenada no metaarquivo de formato aprimorado dado. O metaarquivo pode ser reproduzido várias vezes.|
|[CDC::PlgBlt](#plgblt)|Executa uma transferência de bloco de bits dos bits de dados de cor do retângulo especificado no contexto do dispositivo de origem para o paralelograma especificado no contexto do dispositivo.|
|[CDC::PolyBezier](#polybezier)|Desenha uma ou mais linhas bzier. A posição atual não é usada nem atualizada.|
|[CDC::PolyBezierTo](#polybezierto)|Desenha uma ou mais linhas bzier, e move a posição atual para o ponto final da última linha bzier.|
|[CDC::PolyDraw](#polydraw)|Desenha um conjunto de segmentos de linha e linhas bzier. Esta função atualiza a posição atual.|
|[CDC::Polygon](#polygon)|Desenha um polígono composto por dois ou mais pontos (vértices) conectados por linhas.|
|[CDC::Polyline](#polyline)|Desenha um conjunto de segmentos de linha que conectam os pontos especificados.|
|[CDC::PolylineTo](#polylineto)|Desenha uma ou mais linhas retas e move a posição atual para o ponto final da última linha.|
|[CDC::PolyPolygon](#polypolygon)|Cria dois ou mais polígonos que são preenchidos usando o modo de enchimento do polígono atual. Os polígonos podem ser desarticulados ou podem se sobrepor.|
|[CDC::PolyPoliline](#polypolyline)|Desenha várias séries de segmentos de linha conectada. A posição atual não é usada nem atualizada por esta função.|
|[CDC::PtVisible](#ptvisible)|Especifica se o ponto dado está dentro da região de recorte.|
|[CDC::RealizePalette](#realizepalette)|Mapeia entradas de paleta na paleta lógica atual para a paleta do sistema.|
|[CDC::Retângulo](#rectangle)|Desenha um retângulo usando a caneta atual e preenche-a usando o pincel atual.|
|[CDC::RectVisible](#rectvisible)|Determina se qualquer parte do retângulo dado está dentro da região de recorte.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Releases `m_hAttribDC`, o contexto do dispositivo de atributo.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Releases `m_hDC`, o contexto do dispositivo de saída.|
|[CDC::ResetDC](#resetdc)|Atualiza o `m_hAttribDC` contexto do dispositivo.|
|[CDC::RestoreDC](#restoredc)|Restaura o contexto do dispositivo a `SaveDC`um estado anterior salvo com .|
|[CDC::RoundRect](#roundrect)|Desenha um retângulo com cantos arredondados usando a caneta atual e preenchido usando o pincel atual.|
|[CDC::SaveDC](#savedc)|Salva o estado atual do contexto do dispositivo.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifica a extensão do viewport em relação aos valores atuais.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modifica as extensões da janela em relação aos valores atuais.|
|[CDC::ScrollDC](#scrolldc)|Rola um retângulo de bits horizontal e verticalmente.|
|[CDC::SelectClipPath](#selectclippath)|Seleciona o caminho atual como uma região de recorte para o contexto do dispositivo, combinando a nova região com qualquer região de recorte existente usando o modo especificado.|
|[CDC::SelectClipRgn](#selectcliprgn)|Combina a região dada com a região de recorte atual usando o modo especificado.|
|[CDC::SelectObject](#selectobject)|Seleciona um objeto de desenho GDI, como uma caneta.|
|[CDC::SelectPaleta](#selectpalette)|Seleciona a paleta lógica.|
|[CDC::SelectStockObject](#selectstockobject)|Seleciona uma das canetas de estoque predefinidas, pincéis ou fontes fornecidas pelo Windows.|
|[CDC::SetAbortProc](#setabortproc)|Define uma função de retorno de chamada fornecida pelo programador que o Windows chama se um trabalho de impressão deve ser abortado.|
|[CDC::SetArcDirection](#setarcdirection)|Define a direção do desenho a ser usada para funções de arco e retângulo.|
|[CDC::SetAttribDC](#setattribdc)|Conjuntos `m_hAttribDC`, o contexto do dispositivo de atributo.|
|[CDC::SetBkColor](#setbkcolor)|Define a cor de fundo atual.|
|[CDC::SetBkMode](#setbkmode)|Define o modo de fundo.|
|[CDC::SetBoundsRect](#setboundsrect)|Controla o acúmulo de informações de limitadore-retângulo para o contexto especificado do dispositivo.|
|[CDC::Setbrushorg](#setbrushorg)|Especifica a origem do próximo pincel selecionado em um contexto do dispositivo.|
|[CDC::Ajuste de cores definida](#setcoloradjustment)|Define os valores de ajuste de cor para o contexto do dispositivo usando os valores especificados.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Define a cor do pincel atual.|
|[CDC::SetDCPenColor](#setdcpencolor)|Define a cor da caneta atual.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Define o modo gráfico atual para o contexto especificado do dispositivo.|
|[CDC::SetLayout](#setlayout)|Altera o layout de um contexto de dispositivo (DC).|
|[CDC::SetMapMode](#setmapmode)|Define o modo de mapeamento atual.|
|[CDC::SetMapperFlags](#setmapperflags)|Altera o algoritmo que o mapeador de fontes usa quando mapeia fontes lógicas para fontes físicas.|
|[CDC::SetMiterLimit](#setmiterlimit)|Define o limite para o comprimento das adesões de miter para o contexto do dispositivo.|
|[CDC::SetOutputDC](#setoutputdc)|Conjuntos `m_hDC`, o contexto do dispositivo de saída.|
|[CDC::SetPixel](#setpixel)|Define o pixel no ponto especificado para a aproximação mais próxima da cor especificada.|
|[CDC::SetPixelV](#setpixelv)|Define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. `SetPixelV`é mais `SetPixel` rápido do que porque não precisa devolver o valor de cor do ponto realmente pintado.|
|[CDC::SetPolyFillmode](#setpolyfillmode)|Define o modo de enchimento do polígono.|
|[CDC::SetROP2](#setrop2)|Define o modo de desenho atual.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Define o modo de alongamento do bitmap.|
|[CDC::SetTextalign](#settextalign)|Define as bandeiras de alinhamento de texto.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Define a quantidade de espaçamento entre personagens.|
|[CDC::SetTextColor](#settextcolor)|Define a cor do texto.|
|[CDC::SetTextJustificativa](#settextjustification)|Adiciona espaço aos caracteres de ruptura em uma seqüência.|
|[CDC::SetViewportExt](#setviewportext)|Define as extensões x e y do viewport.|
|[CDC::SetViewportOrg](#setviewportorg)|Define a origem do viewport.|
|[CDC::SetWindowExt](#setwindowext)|Define as extensões x e y da janela associada.|
|[CDC::SetWindowOrg](#setwindoworg)|Define a origem da janela do contexto do dispositivo.|
|[CDC::SetWorldTransform](#setworldtransform)|Define o espaço mundial atual para a transformação do espaço de página.|
|[CDC::StartDoc](#startdoc)|Informa o driver do dispositivo que um novo trabalho de impressão está começando.|
|[CDC::StartPage](#startpage)|Informa o driver do dispositivo que uma nova página está sendo inicializada.|
|[CDC:::StretchBlt](#stretchblt)|Move um bitmap de um retângulo de origem e dispositivo em um retângulo de destino, esticando ou comprimindo o bitmap, se necessário, para se adequar às dimensões do retângulo de destino.|
|[CDC::StrokeandFillPath](#strokeandfillpath)|Fecha quaisquer figuras abertas em um caminho, atinge o contorno do caminho usando a caneta atual, e preenche seu interior usando o pincel atual.|
|[CDC::StrokePath](#strokepath)|Renderiza o caminho especificado usando a caneta atual.|
|[CDC::GuiasTextOut](#tabbedtextout)|Grava uma seqüência de caracteres em um local especificado, expandindo as guias para os valores especificados em uma matriz de posições de parada de guias.|
|[CDC::TextOut](#textout)|Grava uma seqüência de caracteres em um local especificado usando a fonte selecionada no momento.|
|[CDC::TransparentBlt](#transparentblt)|Transfere um bit-block de dados de cores do contexto do dispositivo de origem especificado para um contexto de dispositivo de destino, tornando uma cor especificada transparente na transferência.|
|[CDC::UpdateCores](#updatecolors)|Atualiza a área cliente do contexto do dispositivo combinando as cores atuais na área do cliente com a paleta do sistema em uma base pixel por pixel.|
|[CDC::WidenPath](#widenpath)|Redefine o caminho atual como a área que seria pintada se o caminho fosse traçado usando a caneta atualmente selecionada no contexto do dispositivo.|

### <a name="public-operators"></a>Operadores públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::operador HDC](#operator_hdc)|Recupera a alça do contexto do dispositivo.|

### <a name="public-data-members"></a>Membros de Dados Públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|O contexto do dispositivo `CDC` de atributo usado por este objeto.|
|[CDC::m_hDC](#m_hdc)|O contexto do dispositivo `CDC` de saída usado por este objeto.|

## <a name="remarks"></a>Comentários

O `CDC` objeto fornece funções de membro para trabalhar com um contexto de dispositivo, como uma tela ou impressora, bem como membros para trabalhar com um contexto de exibição associado à área cliente de uma janela.

Faça todos os desenhos através `CDC` das funções do membro de um objeto. A classe fornece funções de membros para operações de contexto de dispositivo, trabalhando com ferramentas de desenho, seleção de objetos de interface de dispositivo gráfico (GDI) e trabalhando com cores e paletas. Ele também fornece funções de membros para obter e definir atributos de desenho, mapear, trabalhar com a porta de visão, trabalhar com a extensão da janela, converter coordenadas, trabalhar com regiões, recortar, desenhar linhas e desenhar formas simples, elipses e polígonos. As funções do membro também são fornecidas para desenhar texto, trabalhar com fontes, usar escapes de impressora, rolagem e reproduzir metaarquivos.

Para usar `CDC` um objeto, construa-o e, em seguida, chame suas funções de membro que o Windows paralelo funções que usam contextos de dispositivos.

> [!NOTE]
> No Windows 95/98, todas as coordenadas de tela são limitadas a 16 bits. Portanto, um **int** passado `CDC` para uma função de membro deve estar na faixa de -32768 a 32767.

Para usos específicos, a Biblioteca de Classes `CDC` da Microsoft Foundation fornece várias classes derivadas de . `CPaintDC`encapsula chamadas para `BeginPaint` `EndPaint`e . `CClientDC`gerencia um contexto de exibição associado à área cliente de uma janela. `CWindowDC`gerencia um contexto de exibição associado a uma janela inteira, incluindo seu quadro e controles. `CMetaFileDC`associa um contexto de dispositivo a um metaarquivo.

`CDC`fornece duas funções de membro, [GetLayout](#getlayout) e [SetLayout,](#setlayout)para reverter o layout de um contexto de dispositivo, que não herda seu layout de uma janela. Essa orientação da direita para a esquerda é necessária para aplicações escritas para culturas, como árabe ou hebraico, onde o layout do personagem não é o padrão europeu.

`CDC`contém dois contextos de dispositivo, [m_hDC](#m_hdc) e `CDC` [m_hAttribDC,](#m_hattribdc)que, na criação de um objeto, referem-se ao mesmo dispositivo. `CDC`direciona todas as chamadas `m_hDC` GDI de saída `m_hAttribDC`e a maioria atribui chamadas GDI a . (Um exemplo de chamada `GetTextColor`de `SetTextColor` atributo é , enquanto é uma chamada de saída.)

Por exemplo, a estrutura usa esses dois `CMetaFileDC` contextos de dispositivo para implementar um objeto que enviará saída para um metaarquivo enquanto lê atributos de um dispositivo físico. A visualização de impressão é implementada no framework de forma semelhante. Você também pode usar os dois contextos do dispositivo de forma semelhante em seu código específico de aplicativo.

Há momentos em que você pode precisar `m_hDC` `m_hAttribDC` de informações métricas de texto a partir dos contextos e do dispositivo. Os seguintes pares de funções fornecem esse recurso:

|Usa m_hAttribDC|Usa m_hDC|
|-----------------------|-----------------|
|[Gettextextent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[Obter'''' '''''''''''''''](#getoutputtabbedtextextent)|
|[Gettextmetrics](#gettextmetrics)|[ObterOutputTextMetrics](#getoutputtextmetrics)|
|[Largura de getchar](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Para obter `CDC`mais informações sobre , consulte [Contextos do dispositivo](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hierarquia de herança

[Cobject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Requisitos

**Cabeçalho:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::AbortDoc

Termina o trabalho de impressão atual e apaga tudo o que o aplicativo escreveu para o dispositivo desde a última chamada para a função de membro [Dodoc.](#startdoc)

```
int AbortDoc();
```

### <a name="return-value"></a>Valor retornado

Um valor maior ou igual a 0 se bem sucedido, ou um valor negativo se ocorreu um erro. A lista a seguir mostra valores de erro comuns e seus significados:

- SP_ERROR erro geral.

- SP_OUTOFDISK Não há espaço em disco suficiente atualmente disponível para spooling, e não haverá mais espaço disponível.

- SP_OUTOFMEMORY Não há memória suficiente disponível para spooling.

- SP_USERABORT Usuário encerrou o trabalho através do Gerenciador de Impressão.

### <a name="remarks"></a>Comentários

Esta função de membro substitui a saída da impressora ABORTDOC.

`AbortDoc`deve ser usado para encerrar o seguinte:

- Operações de impressão que não especificam uma função de abortar usando [SetAbortProc](#setabortproc).

- Operações de impressão que ainda não atingiram sua primeira chamada de escape NEWFRAME ou NEXTBAND.

Se um aplicativo encontrar um erro de impressão ou uma operação de impressão cancelada, ele `AbortDoc` não deve tentar `CDC`encerrar a operação usando as funções [EndDoc](#enddoc) ou membro da classe . O GDI encerra automaticamente a operação antes de retornar o valor de erro.

Se o aplicativo exibir uma caixa de diálogo para permitir `AbortDoc` que o usuário cancele a operação de impressão, ele deve ligar antes de destruir a caixa de diálogo.

Se o Gerenciador de Impressão foi `AbortDoc` usado para iniciar o trabalho de impressão, ligar apaga todo o trabalho de bobina — a impressora não recebe nada. Se o Gerenciador de Impressão não foi usado para iniciar o `AbortDoc` trabalho de impressão, os dados podem ter sido enviados para a impressora antes de serem chamados. Neste caso, o driver da impressora teria redefinido a impressora (quando possível) e fechado o trabalho de impressão.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::AbortPath

Fecha e descarta quaisquer caminhos no contexto do dispositivo.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se houver um suporte de caminho aberto no contexto do dispositivo, o suporte de caminho será fechado e o caminho será descartado. Se houver um caminho fechado no contexto do dispositivo, o caminho será descartado.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC::AddMetaFileComment

Copia o comentário de um buffer em um metaarquivo de formato aprimorado especificado.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parâmetros

*nDataSize*<br/>
Especifica o comprimento do buffer de comentários, em bytes.

*pCommentData*<br/>
Aponta para o buffer que contém o comentário.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um comentário pode incluir qualquer informação privada — por exemplo, a origem da imagem e a data em que ela foi criada. Um comentário deve começar com uma assinatura de aplicativo, seguido pelos dados. Os comentários não devem conter dados específicos da posição. Dados específicos da posição especificam a localização de um registro e não devem ser incluídos porque um metaarquivo pode ser incorporado em outro metaarquivo. Esta função só pode ser usada com metaarquivos aprimorados.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::AlphaBlend

Chame esta função de membro para exibir bitmaps que tenham pixels transparentes ou semitransparentes.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parâmetros

*xDest*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*yDest*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*nDestWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino.

*nDestHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino.

*pSrcDC*<br/>
Um ponteiro para o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*Mistura*<br/>
Especifica uma estrutura [BLENDFUNCTION.](/windows/win32/api/wingdi/ns-wingdi-blendfunction)

### <a name="return-value"></a>Valor retornado

VERDADE se bem sucedido; caso contrário, FALSO.

### <a name="remarks"></a>Comentários

Consulte [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) no Windows SDK para obter mais informações.

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::AngleArc

Desenha um segmento de linha e um arco.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do centro do círculo.

*Y*<br/>
Especifica a coordenada lógica y do centro do círculo.

*nRadius*<br/>
Especifica o raio do círculo em unidades lógicas. Esse valor deve ser positivo.

*fStartAngle*<br/>
Especifica o ângulo de partida em graus relativos ao eixo x.

*fSweepAngle*<br/>
Especifica o ângulo de varredura em graus relativos ao ângulo inicial.

### <a name="return-value"></a>Valor retornado

Não zero se bem sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

O segmento de linha é desenhado da posição atual até o início do arco. O arco é desenhado ao longo do perímetro de um círculo com o raio dado e centro. O comprimento do arco é definido pelos ângulos de início e varredura dado.

`AngleArc`move a posição atual para o ponto final do arco. O arco desenhado por esta função pode parecer elíptico, dependendo do modo de transformação e mapeamento atual. Antes de desenhar o arco, esta função desenha o segmento de linha da posição atual para o início do arco. O arco é desenhado construindo um círculo imaginário com o raio especificado em torno do ponto central especificado. O ponto de partida do arco é determinado medindo no sentido anti-horário a partir do eixo x do círculo pelo número de graus no ângulo inicial. O ponto final é similarmente localizado medindo no sentido anti-horário a partir do ponto de partida pelo número de graus no ângulo de varredura.

Se o ângulo de varredura for superior a 360 graus, o arco é varrido várias vezes. Esta função desenha linhas usando a caneta atual. A figura não está preenchida.

## <a name="cdcarc"></a><a name="arc"></a>CDC::Arc

Desenha um arco elíptico.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*y3*<br/>
Especifica a coordenada y do ponto que define o ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*y4*<br/>
Especifica a coordenada y do ponto que define o ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*Lprect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um LPRECT ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco. Você pode passar uma estrutura [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O arco desenhado usando a função é um segmento da elipse definido pelo retângulo delimitador especificado.

O ponto de partida real do arco é o ponto em que um raio extraído do centro do retângulo delimitador através do ponto de partida especificado cruza a elipse. O ponto final real do arco é o ponto em que um raio extraído do centro do retângulo delimitador através do ponto final especificado cruza a elipse. O arco é desenhado no sentido anti-horário. Uma vez que um arco não é uma figura fechada, ele não é preenchido. Tanto a largura quanto a altura do retângulo devem ser maiores que 2 unidades e inferiores a 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC:::ArcTo

Desenha um arco elíptico.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*y3*<br/>
Especifica a coordenada y do ponto que define o ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*y4*<br/>
Especifica a coordenada y do ponto que define o ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*Lprect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para uma estrutura de dados [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco. Você pode passar uma estrutura de dados [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco. Você pode passar `POINT` uma estrutura `CPoint` de dados ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função é `CDC::Arc`semelhante a, exceto que a posição atual é atualizada. Os pontos *(x1*, *y1)* e *(x2*, *y2*) especificam o retângulo delimitador. Uma elipse formada pelo retângulo delimitador dado define a curva do arco. O arco se estende no sentido anti-horário (a direção do arco padrão) a partir do ponto onde ele cruza a linha radial do centro do retângulo delimitador para ( *x3*, *y3*). O arco termina onde cruza a linha radial do centro do retângulo delimitador para ( *x4*, *y4*). Se o ponto de partida e o ponto final forem os mesmos, uma elipse completa é desenhada.

Uma linha é traçada da posição atual para o ponto de partida do arco. Se não ocorrer nenhum erro, a posição atual será definida para o ponto final do arco. O arco é desenhado usando a caneta atual; não está preenchido.

## <a name="cdcattach"></a><a name="attach"></a>CDC::Anexar

Use esta função de membro para `CDC` anexar um *hDC* ao objeto.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*Hdc*<br/>
Um contexto de dispositivo Windows.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O *hDC* é `m_hDC`armazenado em ambos , `m_hAttribDC`o contexto do dispositivo de saída e, em , o contexto do dispositivo de atributo.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::StartPath

Abre um suporte de caminho no contexto do dispositivo.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Depois que um suporte de caminho é aberto, um aplicativo pode começar a chamar funções de desenho GDI para definir os pontos que estão no caminho. Um aplicativo pode fechar um suporte `EndPath` de caminho aberto chamando a função de membro. Quando um `BeginPath`aplicativo é call, quaisquer caminhos anteriores são descartados.

Consulte [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) no Windows SDK para obter uma lista das funções de desenho que definem pontos em um caminho.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC::BitBlt

Copia um bitmap do contexto do dispositivo de origem para este contexto atual do dispositivo.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo de destino.

*Y*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo de destino.

*Nwidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de destino e do bitmap de origem.

*Nheight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de destino e do bitmap de origem.

*pSrcDC*<br/>
Ponteiro para `CDC` um objeto que identifica o contexto do dispositivo a partir do qual o bitmap será copiado. Deve ser NULO se *dwRop* especificar uma operação de rasterque que não inclua uma fonte.

*xSrc*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do bitmap de origem.

*ySrc*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do bitmap de origem.

*{1&amp;gt;dwRop&amp;lt;1}*<br/>
Especifica a operação de varredura a ser executada. Os códigos de operação de raster definem como o GDI combina cores em operações de saída que envolvem um pincel atual, um possível bitmap de origem e um bitmap de destino. Consulte [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) no Windows SDK para obter uma lista dos códigos de operação de rasterpara *dwRop* e suas descrições

Para obter uma lista completa de códigos de operação de raster, consulte Sobre códigos de [operação rasterno](/windows/win32/gdi/raster-operation-codes) no SDK do Windows.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O aplicativo pode alinhar as janelas ou as áreas `BitBlt` do cliente nos limites de byte para garantir que as operações ocorram em retângulos alinhados a bytes. (Defina as bandeiras de CS_BYTEALIGNWINDOW ou CS_BYTEALIGNCLIENT ao registrar as classes da janela.)

`BitBlt`as operações em retângulos alinhados `BitBlt` a bytes são consideravelmente mais rápidas do que as operações em retângulos que não estão alinhados. Se você quiser especificar estilos de classe, como alinhamento de bytes para o seu próprio contexto de dispositivo, você terá que registrar uma classe de janela em vez de depender das classes da Microsoft Foundation para fazê-lo para você. Use a função global [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

O GDI transforma *nWidth* e *nHeight*, uma vez usando o contexto do dispositivo de destino e uma vez usando o contexto do dispositivo de origem. Se as extensões resultantes não corresponderem, `StretchBlt` o GDI usará a função Windows para compactar ou esticar o bitmap de origem conforme necessário.

Se os bitmaps de destino, origem e padrão `BitBlt` não tiverem o mesmo formato de cor, a função converterá os bitmaps de origem e padrão para corresponder ao destino. As cores de primeiro plano e de fundo do bitmap de destino são usadas na conversão.

Quando `BitBlt` a função converte um bitmap monocromático em cor, ele define bits brancos (1) para a cor de fundo e bits pretos (0) para a cor do primeiro plano. As cores de primeiro plano e de fundo do contexto do dispositivo de destino são usadas. Para converter a cor `BitBlt` em monocromática, define pixels que combinam a cor de fundo com branco e define todos os outros pixels em preto. `BitBlt`usa as cores de primeiro plano e de fundo do contexto do dispositivo de cor para converter de cor para monocromático.

Observe que nem todos `BitBlt`os contextos do dispositivo suportam . Para verificar se um determinado `BitBlt`contexto `GetDeviceCaps` do dispositivo é suportado, use a função de membro e especifique o índice RASTERCAPS.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC::CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

Constrói um objeto `CDC`.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC::Acorde

Desenha um acorde (uma figura fechada limitada pela intersecção de uma elipse e um segmento de linha).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador do acorde (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador do acorde (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador do acorde (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador do acorde (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o ponto de partida do acorde (em unidades lógicas).

*y3*<br/>
Especifica a coordenada y do ponto que define o ponto de partida do acorde (em unidades lógicas).

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto final do acorde (em unidades lógicas).

*y4*<br/>
Especifica a coordenada y do ponto que define o ponto final do acorde (em unidades lógicas).

*Lprect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um LPRECT ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o ponto de partida do acorde (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o acorde. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto final do acorde (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o acorde. Você pode passar uma estrutura [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os parâmetros *(x1*, *y1)* e *(x2*, *y2)* especificam os cantos superior-esquerdo e inferior direito, respectivamente, de um retângulo delimitando a elipse que faz parte do acorde. Os parâmetros *(x3*, *y3)* e *(x4*, *y4)* especificam os pontos finais de uma linha que cruza a elipse. O acorde é desenhado usando a caneta selecionada e preenchido usando o pincel selecionado.

A figura desenhada `Chord` pela função estende-se até, mas não inclui as coordenadas direita e inferior. Isso significa que a altura da figura é *y2* - *y1* e a largura da figura é *x2* - *x1*.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC::CloseFigure

Fecha uma figura aberta em um caminho.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função fecha a figura desenhando uma linha da posição atual para o primeiro ponto da figura (geralmente, o ponto especificado pela chamada mais recente para a `MoveTo` função do membro) e conecta as linhas usando o estilo de juntade linha. Se uma figura for `LineTo` fechada usando `CloseFigure`a função de membro em vez de , as tampas finais são usadas para criar o canto em vez de uma adesão. `CloseFigure`só deve ser chamado se houver um suporte de caminho aberto no contexto do dispositivo.

Uma figura em um caminho está aberta a menos que esteja explicitamente fechada usando esta função. (Uma figura pode ser aberta mesmo que o ponto atual e o ponto de partida da figura sejam os mesmos.) Qualquer linha ou curva adicionada `CloseFigure` ao caminho após começa uma nova figura.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC::CreateCompatibleDC

Cria um contexto de dispositivo de memória compatível com o dispositivo especificado pelo *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parâmetros

*pDC*<br/>
Um ponteiro para um contexto de dispositivo. Se *o pDC* for NULL, a função criará um contexto de dispositivo de memória compatível com o display do sistema.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um contexto de dispositivo de memória é um bloco de memória que representa uma superfície de exibição. Ele pode ser usado para preparar imagens na memória antes de copiá-las para a superfície real do dispositivo compatível.

Quando um contexto de dispositivo de memória é criado, o GDI seleciona automaticamente um bitmap de estoque monocromático 1 por 1 para ele. As funções de saída do GDI só podem ser usadas com um contexto de dispositivo de memória se um bitmap tiver sido criado e selecionado nesse contexto.

Esta função só pode ser usada para criar contextos de dispositivos compatíveis para dispositivos que suportam operações de raster. Consulte a função [CDC::BitBlt](#bitblt) para obter informações sobre transferências de blocos de bits entre contextos de dispositivos. Para determinar se um contexto do dispositivo suporta operações de raster, consulte a capacidade de rasteração RC_BITBLT na função `CDC::GetDeviceCaps`do membro .

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::CreateDC

Cria um contexto de dispositivo para o dispositivo especificado.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parâmetros

*lpszDriverName*<br/>
Aponta para uma seqüência de terminadas nula que especifica o nome do arquivo (sem extensão) do driver do dispositivo (por exemplo, "EPSON"). Você também pode `CString` passar um objeto para este parâmetro.

*lpszNome de dispositivo*<br/>
Aponta para uma seqüência de terminação nula que especifica o nome do dispositivo específico a ser suportado (por exemplo, "EPSON FX-80"). O parâmetro *lpszDeviceName* é usado se o módulo suportar mais de um dispositivo. Você também pode `CString` passar um objeto para este parâmetro.

*lpszSaída*<br/>
Aponta para uma seqüência de terminadas nula que especifica o nome do arquivo ou do dispositivo para o meio de saída física (arquivo ou porta de saída). Você também pode `CString` passar um objeto para este parâmetro.

*Lpinitdata*<br/>
Aponta para `DEVMODE` uma estrutura contendo dados de inicialização específicos do dispositivo para o driver do dispositivo. A `DocumentProperties` função Windows recupera essa estrutura preenchida para um determinado dispositivo. O parâmetro *lpInitData* deve ser NULO se o driver do dispositivo for usar a inicialização padrão (se houver) especificada pelo usuário através do Painel de Controle.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A IMPRESSÃO. O arquivo de cabeçalho H é necessário se a estrutura [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) for usada.

Os nomes dos dispositivos seguem estas convenções: um cólon final (:) é recomendado, mas opcional. O Windows tira o cólon de terminação de modo que um nome de dispositivo que termina com um cólon é mapeado para a mesma porta que o mesmo nome sem um cólon. Os nomes do driver e da porta não devem conter espaços de liderança ou de trilha. As funções de saída do GDI não podem ser usadas com contextos de informação.

## <a name="cdccreateic"></a><a name="createic"></a>CDC::CreateIC

Cria um contexto de informações para o dispositivo especificado.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parâmetros

*lpszDriverName*<br/>
Aponta para uma seqüência de terminadas nula que especifica o nome do arquivo (sem extensão) do driver do dispositivo (por exemplo, "EPSON"). Você pode `CString` passar um objeto para este parâmetro.

*lpszNome de dispositivo*<br/>
Aponta para uma seqüência de terminação nula que especifica o nome do dispositivo específico a ser suportado (por exemplo, "EPSON FX-80"). O parâmetro *lpszDeviceName* é usado se o módulo suportar mais de um dispositivo. Você pode `CString` passar um objeto para este parâmetro.

*lpszSaída*<br/>
Aponta para uma seqüência de terminação nula que especifica o nome do arquivo ou do dispositivo para o meio de saída física (arquivo ou porta). Você pode `CString` passar um objeto para este parâmetro.

*Lpinitdata*<br/>
Aponta para dados de inicialização específicos do dispositivo para o driver do dispositivo. O parâmetro *lpInitData* deve ser NULO se o driver do dispositivo for usar a inicialização padrão (se houver) especificada pelo usuário através do Painel de Controle. Consulte `CreateDC` o formato de dados para inicialização específica do dispositivo.

### <a name="return-value"></a>Valor retornado

Não zero se bem sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto de informações fornece uma maneira rápida de obter informações sobre o dispositivo sem criar um contexto de dispositivo.

Os nomes dos dispositivos seguem estas convenções: um cólon final (:) é recomendado, mas opcional. O Windows tira o cólon de terminação de modo que um nome de dispositivo que termina com um cólon é mapeado para a mesma porta que o mesmo nome sem um cólon. Os nomes do driver e da porta não devem conter espaços de liderança ou de trilha. As funções de saída do GDI não podem ser usadas com contextos de informação.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DeleteDC

Em geral, não chame essa função; o destruidor fará isso por você.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valor retornado

Não zero se a função for concluída com sucesso; caso contrário, 0.

### <a name="remarks"></a>Comentários

A `DeleteDC` função member exclui os contextos do `m_hDC` dispositivo `CDC` Windows associados no objeto atual. Se `CDC` este objeto for o último contexto do dispositivo ativo para um determinado dispositivo, o dispositivo será notificado e todos os recursos de armazenamento e sistema usados pelo dispositivo serão liberados.

Um aplicativo não `DeleteDC` deve chamar se os objetos foram selecionados no contexto do dispositivo. Os objetos devem primeiro ser selecionados fora do contexto do dispositivo antes de serem excluídos.

Um aplicativo não deve excluir um contexto do dispositivo cuja alça foi obtida ligando para [CWnd:::GetDC](../../mfc/reference/cwnd-class.md#getdc). Em vez disso, deve chamar [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) para liberar o contexto do dispositivo. As classes [CClientDC](../../mfc/reference/cclientdc-class.md) e [CWindowDC](../../mfc/reference/cwindowdc-class.md) são fornecidas para encerrar essa funcionalidade.

A `DeleteDC` função é geralmente usada para excluir contextos de dispositivos criados com [CreateDC,](#createdc) [CreateIC](#createic)ou [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Exemplo

  Veja o exemplo de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::DeleteTempMap

Chamado automaticamente pelo `CWinApp` manipulador de `DeleteTempMap` tempo ocioso, `CDC` `FromHandle`exclui quaisquer objetos temporários criados por , mas não destrói as alças de contexto do dispositivo (s) `hDC`temporariamente associadas aos `CDC` objetos.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Detach

Chame esta função `m_hDC` para separar (o contexto `CDC` do dispositivo `m_hDC` `m_hAttribDC` de saída) do objeto e definir ambos e para NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Valor retornado

Um contexto de dispositivo Windows.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::DPtoHIMÉTRICO

Use esta função quando você der tamanhos HIMÉTRICOs ao OLE, convertendo pixels em HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpTamanho*<br/>
Aponta para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

Se o modo de mapeamento do objeto de contexto do dispositivo for MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, então a conversão é baseada no número de pixels na polegada física. Se o modo de mapeamento for um dos outros modos não restritos (por exemplo, MM_TEXT), então a conversão é baseada no número de pixels na polegada lógica.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::DPtoLP

Converte unidades de dispositivos em unidades lógicas.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma matriz de estruturas [POINT](/windows/win32/api/windef/ns-windef-point) ou objetos [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*Ncount*<br/>
O número de pontos na matriz.

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect.](../../atl-mfc-shared/reference/crect-class.md) Este parâmetro é usado para o simples caso de conversão de um retângulo de pontos de dispositivo para pontos lógicos.

*lpTamanho*<br/>
Aponta para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

A função mapeia as coordenadas de cada ponto, ou dimensão de um tamanho, do sistema de coordenadas do dispositivo para o sistema de coordenadas lógicas do GDI. A conversão depende do modo de mapeamento atual e das configurações das origens e extensões para a janela e a porta de visualização do dispositivo.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Draw3dRect

Chame esta função de membro para desenhar um retângulo tridimensional.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

*clrTopLeft*<br/>
Especifica a cor dos lados superior e esquerdo do retângulo tridimensional.

*clrBottomRight*<br/>
Especifica a cor dos lados inferior e direito do retângulo tridimensional.

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo tridimensional.

*Y*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo tridimensional.

*Cx*<br/>
Especifica a largura do retângulo tridimensional.

*Cy*<br/>
Especifica a altura do retângulo tridimensional.

### <a name="remarks"></a>Comentários

O retângulo será desenhado com os lados superior e esquerdo na cor especificada por *clrTopLeft* e os lados inferior e direito na cor especificada por *clrBottomRight*.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::DrawDragRect

Chame esta função de membro repetidamente para redesenhar um retângulo de arrasto.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica as coordenadas lógicas de um retângulo — neste caso, a posição final do retângulo está sendo redesenhada.

*Tamanho*<br/>
Especifica o deslocamento do canto superior esquerdo da borda externa para o canto superior esquerdo da borda interna (ou seja, a espessura da borda) de um retângulo.

*lpRectLast*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica as coordenadas lógicas da posição de um retângulo — neste caso, a posição original do retângulo está sendo redesenhada.

*tamanhoÚltimo*<br/>
Especifica o deslocamento do canto superior esquerdo da borda externa para o canto superior esquerdo da borda interna (ou seja, a espessura da borda) do retângulo original sendo redesenhado.

*pBrush*<br/>
Ponteiro para um objeto de escova. Definir como NULL para usar o pincel de meio tom padrão.

*pBrushLast*<br/>
Ponteiro para o último objeto de escova usado. Definir como NULL para usar o pincel de meio tom padrão.

### <a name="remarks"></a>Comentários

Chame-o em um loop enquanto você amostra a posição do mouse, a fim de dar feedback visual. Quando você `DrawDragRect`chama, o retângulo anterior é apagado e um novo é desenhado. Por exemplo, à medida que o usuário arrasta `DrawDragRect` um retângulo pela tela, apagará o retângulo original e redesenhará um novo em sua nova posição. Por padrão, `DrawDragRect` desenha o retângulo usando uma escova de meio tom para eliminar a cintilação e para criar a aparência de um retângulo suavemente em movimento.

Na primeira vez `DrawDragRect`que você chamar, o *parâmetro lpRectLast* deve ser NULO.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::DrawEdge

Chame esta função de membro para desenhar as bordas de um retângulo do tipo e estilo especificados.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Um ponteiro `RECT` para uma estrutura que contém as coordenadas lógicas do retângulo.

*nEdge*<br/>
Especifica o tipo de borda interna e externa a ser desenhar. Este parâmetro deve ser uma combinação de uma bandeira de fronteira interna e uma bandeira de fronteira externa. Consulte [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) no Windows SDK para obter uma tabela dos tipos do parâmetro.

*Nflags*<br/>
As bandeiras que especificam o tipo de borda a ser desenhada. Consulte `DrawEdge` no Windows SDK uma tabela de valores do parâmetro. Para linhas diagonais, as bandeiras BF_RECT especificam o ponto final do vetor limitado pelo parâmetro retângulo.

### <a name="return-value"></a>Valor retornado

Não zero se bem sucedido; caso contrário, 0.

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::DrawEscape

Acessa os recursos de desenho de uma tela de vídeo que não estão diretamente disponíveis através da interface do dispositivo gráfico (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parâmetros

*nEscape*<br/>
Especifica a função de escape a ser executada.

*nInputSize*<br/>
Especifica o número de bytes de dados apontados pelo parâmetro *lpszInputData.*

*lpszInputData*<br/>
Aponta para a estrutura de entrada necessária para a fuga especificada.

### <a name="return-value"></a>Valor retornado

Especifica o resultado da função. Maior que zero se bem sucedido, exceto pela fuga de sorteio QUERYESCSUPPORT, que verifica apenas a implementação; ou zero se a fuga não for implementada; ou menos de zero se ocorreu um erro.

### <a name="remarks"></a>Comentários

Quando um `DrawEscape`aplicativo chama, os dados identificados por *nInputSize* e *lpszInputData* são passados diretamente para o driver de exibição especificado.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::DrawFocusRect

Desenha um retângulo no estilo usado para indicar que o retângulo tem o foco.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica as coordenadas lógicas do retângulo a ser desenhado.

### <a name="remarks"></a>Comentários

Uma vez que esta é uma função Boolean XOR, chamar esta função uma segunda vez com o mesmo retângulo remove o retângulo do display. O retângulo desenhado por esta função não pode ser rolado. Para rolar uma área contendo um retângulo desenhado `DrawFocusRect` por esta função, primeiro ligue para remover o `DrawFocusRect` retângulo do display, em seguida, role a área e, em seguida, chame novamente para desenhar o retângulo na nova posição.

> [!CAUTION]
> `DrawFocusRect`funciona apenas no modo MM_TEXT. Em outros modos, esta função não desenha o retângulo de foco corretamente, mas não retorna os valores de erro.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::DrawFrameControl

Chame esta função de membro para desenhar um controle de quadro do tipo e estilo especificados.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Um ponteiro `RECT` para uma estrutura que contém as coordenadas lógicas do retângulo.

*nType*<br/>
Especifica o tipo de controle de quadro saque. Consulte o parâmetro *uType* no [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) no Windows SDK para obter uma lista dos possíveis valores deste parâmetro.

*Nstate*<br/>
Especifica o estado inicial do controle de quadros. Pode ser um ou mais dos valores descritos para o parâmetro *uState* no `DrawFrameControl` SDK do Windows. Use o *valor nState* DFCS_ADJUSTRECT para ajustar o retângulo delimitador para excluir a borda circundante do botão de pressão.

### <a name="return-value"></a>Valor retornado

Não zero se bem sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

Em vários casos, *nState* depende do parâmetro *nType.* A lista a seguir mostra a relação entre os quatro valores *nType* e *nState*:

- DFC_BUTTON

  - DFCS_BUTTON3STATE botão de três estados

  - caixa de verificação de DFCS_BUTTONCHECK

  - DFCS_BUTTONPUSH botão de apertar

  - botão de rádio DFCS_BUTTONRADIO

  - DFCS_BUTTONRADIOIMAGE imagem para botão de rádio (imagem não quadrada precisa)

  - DFCS_BUTTONRADIOMASK Máscara para botão de rádio (máscara não quadrada precisa)

- DFC_CAPTION

  - DFCS_CAPTIONCLOSE botão Fechar

  - botão de ajuda DFCS_CAPTIONHELP

  - DFCS_CAPTIONMAX botão maximizar

  - DFCS_CAPTIONMIN minimizar o botão

  - botão DFCS_CAPTIONRESTORE Restaurar

- DFC_MENU

  - DFCS_MENUARROW seta submenu

  - Bala de DFCS_MENUBULLET

  - DFCS_MENUCHECK marca de verificação

- DFC_SCROLL

  - DFCS_SCROLLCOMBOBOX barra de rolagem da caixa combo

  - DFCS_SCROLLDOWN seta para baixo da barra de rolagem

  - DFCS_SCROLLLEFT seta esquerda da barra de rolagem

  - DFCS_SCROLLRIGHT seta direita da barra de rolagem

  - DFCS_SCROLLSIZEGRIP aderência de tamanho no canto inferior direito da janela

  - DFCS_SCROLLUP seta para cima da barra de rolagem

### <a name="example"></a>Exemplo

Este código desenha o aperto de tamanho no canto inferior direito da sua janela. É apropriado para `OnPaint` o manipulador de uma caixa de diálogo, que não tem estilos e normalmente não contém outros controles (como uma barra de status) que podem dar-lhe um aperto de tamanho.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::DrawIcon

Desenha um ícone no dispositivo `CDC` representado pelo objeto atual.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do ícone.

*Y*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do ícone.

*Hicon*<br/>
Identifica a alça do ícone a ser desenhado.

*Ponto*<br/>
Especifica as coordenadas lógicas x e y do canto superior esquerdo do ícone. Você pode passar uma estrutura [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parâmetro.

### <a name="return-value"></a>Valor retornado

Não zero se a função for concluída com sucesso; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função coloca o canto superior esquerdo do ícone no local especificado por *x* e *y*. A localização está sujeita ao modo de mapeamento atual do contexto do dispositivo.

O recurso de ícone deve ter sido carregado `CWinApp::LoadIcon` `CWinApp::LoadStandardIcon`anteriormente `CWinApp::LoadOEMIcon`usando as funções, ou . O `MM_TEXT` modo de mapeamento deve ser selecionado antes de usar esta função.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::DrawState

Chame esta função de membro para exibir uma imagem e aplicar um efeito visual para indicar um estado, como um estado desativado ou padrão.

> [!NOTE]
> Para todos os estados *nFlag,* exceto DSS_NORMAL, a imagem é convertida em monocromática antes que o efeito visual seja aplicado.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parâmetros

*pt*<br/>
Especifica a localização da imagem.

*Tamanho*<br/>
Especifica o tamanho da imagem.

*Hbitmap*<br/>
Uma alça para um bitmap.

*Nflags*<br/>
Sinalizadores que especificam o tipo de imagem e o estado. Consulte [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) no Windows SDK para os possíveis tipos e estados *nFlags.*

*Hbrush*<br/>
Uma alça para um pincel.

*Pbitmap*<br/>
Um ponteiro para um objeto CBitmap.

*pBrush*<br/>
Um ponteiro para um objeto CBrush.

*Hicon*<br/>
Um identificador para um ícone.

*lpszText*<br/>
Um ponteiro para texto.

*bPrefixText*<br/>
Texto que pode conter um acelerador mnemônico. O parâmetro *lData* especifica o endereço da seqüência e o parâmetro *nTextLen* especifica o comprimento. Se *nTextLen* for 0, a seqüência será presumida como nula.

*Ntextlen*<br/>
Comprimento da seqüência de texto apontado por *lpszText*. Se *nTextLen* for 0, a seqüência será presumida como nula.

*lpDrawProc*<br/>
Um ponteiro para uma função de retorno de chamada usado para renderizar uma imagem. Este parâmetro é necessário se o tipo de imagem em *nFlags* for DST_COMPLEX. É opcional e pode ser NULA se o tipo de imagem for DST_TEXT. Para todos os outros tipos de imagem, este parâmetro é ignorado. Para obter mais informações sobre a função de retorno de chamada, consulte a função [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) no SDK do Windows.

*Ldata*<br/>
Especifica informações sobre a imagem. O significado deste parâmetro depende do tipo de imagem.

### <a name="return-value"></a>Valor retornado

Não zero se bem sucedido; caso contrário, 0.

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::DrawText

Chame esta função de membro para formatar texto no retângulo dado. Para especificar opções adicionais de formatação, use [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para a corda a ser desenhada. Se *nCount* for -1, a seqüência deve ser anulada.

*Ncount*<br/>
Especifica o número de chars na seqüência. Se *nCount* é -1, então *lpszString* é assumido como um ponteiro `DrawText` longo para uma seqüência de caracteres com término nulo e calcula a contagem de caracteres automaticamente.

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contém o retângulo (em coordenadas lógicas) no qual o texto deve ser formatado.

*Str*<br/>
Um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que contém os caracteres especificados a serem desenhados.

*Nformat*<br/>
Especifica o método de formatação do texto. Pode ser qualquer combinação dos valores descritos para o parâmetro *uFormat* em [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) no Windows SDK. (combine usando o operador bitwise OR):

> [!NOTE]
> Algumas combinações de sinalizadores *uFormat* podem fazer com que a seqüência de string saqueada seja modificada. O uso de DT_MODIFYSTRING com DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS pode fazer `CString` com que a seqüência seja modificada, causando uma afirmação na substituição. Os valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP e DT_NOPREFIX não podem ser utilizados com o valor DT_TABSTOP.

### <a name="return-value"></a>Valor retornado

A altura do texto se a função for bem sucedida.

### <a name="remarks"></a>Comentários

Ele formata o texto expandindo as guias em espaços apropriados, alinhando o texto à esquerda, à direita ou ao centro do retângulo dado e quebrando o texto em linhas que se encaixam no retângulo dado. O tipo de formatação é especificado por *nFormat*.

Essa função de membro usa a fonte, a cor do texto e a cor de fundo do contexto do dispositivo para desenhar o texto. A menos que o `DrawText` formato DT_NOCLIP seja usado, clipe o texto para que o texto não apareça fora do retângulo dado. Toda formatação é assumida ter várias linhas, a menos que o formato DT_SINGLELINE seja dado.

Se a fonte selecionada for muito grande para o `DrawText` retângulo especificado, a função membro não tentará substituir uma fonte menor.

Se a bandeira DT_CALCRECT for especificada, o retângulo especificado pelo *lpRect* será atualizado para refletir a largura e a altura necessárias para desenhar o texto.

Se o TA_UPDATECP sinalizador de alinhamento de texto tiver sido `DrawText` definido (consulte [CDC::SetTextAlign),](#settextalign)exibirá texto a partir da posição atual, em vez de à esquerda do retângulo dado. `DrawText`não envolverá o texto quando a bandeira de TA_UPDATECP tiver sido definida (ou seja, a bandeira DT_WORDBREAK não terá efeito).

A cor do texto pode ser definida pelo [CDC::SetTextColor](#settextcolor).

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::DrawTextEx

Forma texto no retângulo dado.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para a corda a ser desenhada. Se *nCount* for -1, a seqüência deve ser anulada.

*Ncount*<br/>
Especifica o número de chars na seqüência. Se *nCount* é -1, então *lpszString* é assumido como um ponteiro `DrawText` longo para uma seqüência de caracteres com término nulo e calcula a contagem de caracteres automaticamente.

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contém o retângulo (em coordenadas lógicas) no qual o texto deve ser formatado.

*Str*<br/>
Um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que contém os caracteres especificados a serem desenhados.

*Nformat*<br/>
Especifica o método de formatação do texto. Pode ser qualquer combinação dos valores descritos para o parâmetro *uFormat* em [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) no Windows SDK. (Combine usando o operador **bitwise OR):**

> [!NOTE]
> Algumas combinações de sinalizadores *uFormat* podem fazer com que a seqüência de string saqueada seja modificada. O uso de DT_MODIFYSTRING com DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS pode fazer `CString` com que a seqüência seja modificada, causando uma afirmação na substituição. Os valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP e DT_NOPREFIX não podem ser utilizados com o valor DT_TABSTOP.

*lpDTParams*<br/>
Pointer para uma estrutura [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) que especifica opções adicionais de formatação. Este parâmetro pode ser NULO.

### <a name="remarks"></a>Comentários

Ele formata o texto expandindo as guias em espaços apropriados, alinhando o texto à esquerda, à direita ou ao centro do retângulo dado e quebrando o texto em linhas que se encaixam no retângulo dado. O tipo de formatação é especificado por *nFormat* e *lpDTParams*. Para obter mais informações, consulte [CDC::DrawText](#drawtext) e [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) no SDK do Windows.

A cor do texto pode ser definida pelo [CDC::SetTextColor](#settextcolor).

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::Elipse

Desenha uma elipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo delimitador da elipse.

*y1*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo delimitador da elipse.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo delimitador da elipse.

*y2*<br/>
Especifica a coordenada lógica y do canto inferior direito do retângulo delimitador da elipse.

*Lprect*<br/>
Especifica o retângulo delimitador da elipse. Você também pode passar um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O centro da elipse é o centro do retângulo delimitador especificado por *x1*, *y1*, *x2*e *y2*, ou *lpRect*. A elipse é desenhada com a caneta atual, e seu interior é preenchido com o pincel atual.

A figura desenhada por esta função estende-se até, mas não inclui, as coordenadas direita e inferior. Isso significa que a altura da figura é *y2* - *y1* e a largura da figura é *x2* - *x1*.

Se a largura ou a altura do retângulo delimitador for 0, nenhuma elipse será desenhada.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC::EndDoc

Termina um trabalho de impressão iniciado por uma chamada para a função de membro [do StartDoc.](#startdoc)

```
int EndDoc();
```

### <a name="return-value"></a>Valor retornado

Maior ou igual a 0 se a função for bem sucedida, ou um valor negativo se ocorreu um erro.

### <a name="remarks"></a>Comentários

Esta função de membro substitui a saída da impressora ENDDOC e deve ser chamada imediatamente após terminar um trabalho de impressão bem-sucedido.

Se um aplicativo encontrar um erro de impressão ou uma operação de impressão `EndDoc` cancelada, ele não deve tentar encerrar a operação usando qualquer um ou [abortDoc](#abortdoc). O GDI encerra automaticamente a operação antes de retornar o valor de erro.

Esta função não deve ser usada dentro de metaarquivos.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC::EndPage

Informa o dispositivo que o aplicativo terminou de escrever para uma página.

```
int EndPage();
```

### <a name="return-value"></a>Valor retornado

Maior ou igual a 0 se a função for bem sucedida, ou um valor negativo se ocorreu um erro.

### <a name="remarks"></a>Comentários

Esta função de membro é normalmente usada para direcionar o driver do dispositivo para avançar para uma nova página.

Esta função de membro substitui a saída da impressora NEWFRAME. Ao contrário do NEWFRAME, essa função é sempre chamada após a impressão de uma página.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC::EndPath

Fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto do dispositivo.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC::EnumObjects

Enumera as canetas e pincéis disponíveis em um contexto de dispositivo.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parâmetros

*nObjectType*<br/>
Especifica o tipo de objeto. Pode ter os valores OBJ_BRUSH ou OBJ_PEN.

*Lpfn*<br/>
É o endereço de instância de procedimento da função de retorno de chamada fornecida pelo aplicativo. Veja a seção "Observações" abaixo.

*Lpdata*<br/>
Aponta para os dados fornecidos pelo aplicativo. Os dados são passados para a função de retorno de chamada, juntamente com as informações do objeto.

### <a name="return-value"></a>Valor retornado

Especifica o último valor retornado pela [função de retorno](callback-functions-used-by-mfc.md#enum_objects)de chamada . Seu significado é definido pelo usuário.

### <a name="remarks"></a>Comentários

Para cada objeto de um determinado tipo, a função de retorno de chamada que você passa é chamada com as informações para esse objeto. O sistema chama a função de retorno de chamada até que não haja mais objetos ou a função de retorno de chamada retorna 0.

Observe que os novos recursos do Microsoft Visual C++ permitem `EnumObjects`que você use uma função comum à medida que a função passou para . O endereço `EnumObjects` passado é um indicador para uma função exportada com **EXPORT** e com a convenção de chamada pascal. Em aplicativos de modo de proteção, você não precisa criar essa função com a função Windows MakeProcInstance ou liberar a função após o uso com a função FreeProcInstance Windows.

Você também não precisa exportar o nome da função em uma declaração **EXPORTS** no arquivo de definição de módulo do aplicativo. Em vez disso, você pode usar o modificador de função **EXPORT,** como em

**int CALLBACK EXPORT** AFunction **(LPSTR**, **LPSTR);**

para fazer com que o compilador emita o registro de exportação adequado para exportação por nome sem aliasing. Isso funciona para a maioria das necessidades. Para alguns casos especiais, como exportar uma função por ordinal ou aliasing a exportação, você ainda precisa usar uma declaração **EXPORTS** em um arquivo de definição de módulo.

Para compilar programas da Microsoft Foundation, você normalmente usará as opções de compilador /GA e /GEs. A opção compilador /Gw não é usada com as classes da Microsoft Foundation. (Se você usar a `MakeProcInstance`função Windows, você precisará lançar explicitamente o ponteiro de função retornado de FARPROC para o tipo necessário nesta API.) As interfaces de registro de retorno de chamada agora são seguras para o tipo (você deve passar em um ponteiro de função que aponta para o tipo certo de função para o retorno de chamada específico).

Observe também que todas as funções de retorno de chamada devem prender as exceções do Microsoft Foundation antes de retornar ao Windows, uma vez que as exceções não podem ser lançadas através dos limites de retorno de chamada. Para obter mais informações sobre exceções, consulte o artigo [Exceções](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::Escape

Esta função de membro é praticamente obsoleta para a programação Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parâmetros

*nEscape*<br/>
Especifica a função de escape a ser executada.

Para obter uma lista completa de funções de fuga, consulte [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) no SDK do Windows.

*Ncount*<br/>
Especifica o número de bytes de dados apontados por *lpszInData*.

*lpszInData*<br/>
Aponta para a estrutura de dados de entrada necessária para esta fuga.

*lpOutData*<br/>
Aponta para a estrutura que é para receber a saída desta fuga. O parâmetro *lpOutData* é NULO se nenhum dado for retornado.

*nInputSize*<br/>
Especifica o número de bytes de dados apontados pelo parâmetro *lpszInputData.*

*lpszInputData*<br/>
Aponta para a estrutura de entrada necessária para a fuga especificada.

*nOutputSize*<br/>
Especifica o número de bytes de dados apontados pelo parâmetro *lpszOutputData.*

*lpszOutputData*<br/>
Aponta para a estrutura que recebe saída dessa fuga. Este parâmetro deve ser NULO se nenhum dado for devolvido.

### <a name="return-value"></a>Valor retornado

Um valor positivo é devolvido se a função for bem sucedida, exceto pela fuga QUERYESCSUPPORT, que só verifica a implementação. Zero é devolvido se a fuga não for implementada. Um valor negativo é devolvido se ocorrer um erro. Os seguintes são valores de erro comuns:

- SP_ERROR erro geral.

- SP_OUTOFDISK Não há espaço em disco suficiente atualmente disponível para spooling, e não haverá mais espaço disponível.

- SP_OUTOFMEMORY Não há memória suficiente disponível para spooling.

- SP_USERABORT Usuário encerrou o trabalho através do Gerenciador de Impressão.

### <a name="remarks"></a>Comentários

Das escapadas originais da impressora, apenas o QUERYESCSUPPORT é suportado para aplicativos Win32. Todas as outras saídas de impressora são obsoletas e são suportadas apenas para compatibilidade com aplicativos de 16 bits.

Para a programação Win32, `CDC` agora fornece seis funções de membros que substituim suas saídas de impressora correspondentes:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Além disso, [o CDC::GetDeviceCaps](#getdevicecaps) suporta índices Win32 que substituim outras saídas de impressora. Consulte [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) no Windows SDK para obter mais informações.

Esta função de membro permite que os aplicativos acessem instalações de um determinado dispositivo que não estão diretamente disponíveis através do GDI.

Use a primeira versão se o aplicativo usar valores de fuga predefinidos. Use a segunda versão se o aplicativo definir valores de escape privados. Consulte [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) no Windows SDK para obter mais informações sobre a segunda versão.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::ExcluaClipRect

Cria uma nova região de recorte que consiste na região de recorte existente menos o retângulo especificado.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y1*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo.

*y2*<br/>
Especifica a coordenada lógica y do canto inferior direito do retângulo.

*Lprect*<br/>
Especifica o retângulo. Também pode `CRect` ser um objeto.

### <a name="return-value"></a>Valor retornado

Especifica o tipo da nova região de recorte. Pode ser qualquer um dos seguintes valores:

- REGIÃO COMPLEXA A região tem fronteiras sobrepostas.

- ERRO Nenhuma região foi criada.

- NULLREGION A região está vazia.

- REGIÃO SIMPLES A região não tem fronteiras sobrepostas.

### <a name="remarks"></a>Comentários

A largura do retângulo, especificada pelo valor absoluto de *x2* - *x1,* não deve exceder 32.767 unidades. Este limite também se aplica à altura do retângulo.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::ExcluaUpdateRgn

Impede o desenho dentro de áreas inválidas de uma janela, excluindo `CDC` uma região atualizada na janela da região de recorte associada ao objeto.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parâmetros

*Pwnd*<br/>
Aponta para o objeto da janela cuja janela está sendo atualizada.

### <a name="return-value"></a>Valor retornado

O tipo de região excluída. Pode ser qualquer um dos seguintes valores:

- REGIÃO COMPLEXA A região tem fronteiras sobrepostas.

- ERRO Nenhuma região foi criada.

- NULLREGION A região está vazia.

- REGIÃO SIMPLES A região não tem fronteiras sobrepostas.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::ExtFloodFill

Preenche uma área da superfície do display com o pincel atual.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto onde o preenchimento começa.

*Y*<br/>
Especifica a coordenada lógica y do ponto onde o preenchimento começa.

*Crcolor*<br/>
Especifica a cor do limite ou da área a ser preenchida. A interpretação do *crColor* depende do valor do *nFillType*.

*nFillType*<br/>
Especifica o tipo de preenchimento de inundação a ser realizado. Deve ser um dos seguintes valores:

- FLOODFILLBORDER A área de preenchimento é limitada pela cor especificada pelo *crColor*. Este estilo é idêntico ao `FloodFill`preenchimento realizado por .

- INUNDAÇÃOSuperfície A área de preenchimento é definida pela cor especificada pelo *crColor*. O enchimento continua para fora em todas as direções, desde que a cor seja encontrada. Este estilo é útil para preencher áreas com limites multicoloridos.

### <a name="return-value"></a>Valor retornado

Não zero se a função for bem sucedida; caso contrário 0 se o enchimento não puder ser concluído, se o ponto dado tiver a cor de limite especificada por *crColor* (se FLOODFILLBORDER foi solicitado), se o ponto dado não tiver a cor especificada por *crColor* (se FLOODFILLSURFACE foi solicitado), ou se o ponto estiver fora da região de recorte.

### <a name="remarks"></a>Comentários

Esta função de membro `FloodFill` oferece mais flexibilidade do que porque você pode especificar um tipo de preenchimento no *nFillType*.

Se *nFillType* estiver definido como FLOODFILLBORDER, a área deverá ser completamente limitada pela cor especificada por *crColor*. A função começa no ponto especificado por *x* e *y* e preenche em todas as direções até o limite de cor.

Se *nFillType* estiver definido como FLOODFILLSURFACE, a função começa no ponto especificado por *x* e *y* e continua em todas as direções, preenchendo todas as áreas adjacentes que contenham a cor especificada por *crColor*.

Apenas contextos e dispositivos de dispositivo de memória que `ExtFloodFill`suportam suporte à tecnologia de exibição de rasterantes . Para obter mais informações, consulte a função [membro GetDeviceCaps.](#getdevicecaps)

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::ExtTextOut

Chame esta função de membro para escrever uma seqüência de caracteres dentro de uma região retangular usando a fonte selecionada no momento.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da célula de caracteres para o primeiro caractere na seqüência especificada.

*Y*<br/>
Especifica a coordenada lógica y da parte superior da célula de caracteres para o primeiro caractere na seqüência especificada.

*nOpções*<br/>
Especifica o tipo de retângulo. Este parâmetro pode ser um, ambos, ou nenhum dos seguintes valores:

- ETO_CLIPPED Especifica que o texto está preso no retângulo.

- ETO_OPAQUE Especifica que a cor de fundo atual preenche o retângulo. (Você pode definir e consultar a cor de fundo atual com as funções de membro [SetBkColor](#setbkcolor) e [GetBkColor.)](#getbkcolor)

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) que determina as dimensões do retângulo. Este parâmetro pode ser NULO. Você também pode passar um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

*lpszString*<br/>
Aponta para a seqüência de caracteres especificada a ser desenhada. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parâmetro.

*Ncount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*lpDxLarguras*<br/>
Aponta para uma matriz de valores que indicam a distância entre as origens das células de caracteres adjacentes. Por exemplo, *lpDxWidths*[ *i*] unidades lógicas separarão as origens da célula de *caracterei* e da célula de *caracterei* + 1. Se *lpDxWidths* for `ExtTextOut` NULL, use o espaçamento padrão entre caracteres.

*Str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem desenhados.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A região retangular pode ser opaca (preenchida com a cor de fundo atual), e pode ser uma região de recorte.

Se *nOptions* for 0 e *lpRect* for NULL, a função grava texto no contexto do dispositivo sem usar uma região retangular. Por padrão, a posição atual não é usada nem atualizada pela função. Se um aplicativo precisar atualizar a `ExtTextOut`posição atual quando `CDC` ele chamar, o aplicativo pode chamar a função de membro [SetTextAlign](#settextalign) com *nFlags* definido para TA_UPDATECP. Quando este sinalizador é definido, o Windows ignora *x* e *y* em chamadas subseqüentes e `ExtTextOut` usa a posição atual em vez disso. Quando um aplicativo usa TA_UPDATECP para `ExtTextOut` atualizar a posição atual, define a posição atual no final da linha de texto anterior ou na posição especificada pelo último elemento do array apontado por *lpDxWidths*, o que for maior.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC::FillPath

Fecha quaisquer figuras abertas no caminho atual e preenche o interior do caminho usando o pincel atual e o modo de enchimento do polígono.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Depois que seu interior é preenchido, o caminho é descartado a partir do contexto do dispositivo.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC::FillRect

Chame esta função de membro para preencher um determinado retângulo usando o pincel especificado.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) que contém as coordenadas lógicas do retângulo a ser preenchido. Você também pode passar um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parâmetro.

*pBrush*<br/>
Identifica o pincel usado para preencher o retângulo.

### <a name="remarks"></a>Comentários

A função preenche o retângulo completo, incluindo as bordas esquerda e superior, mas não preenche as bordas direita e inferior.

O pincel precisa ser criado usando as funções do membro [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush,](../../mfc/reference/cbrush-class.md#createhatchbrush) [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush) `GetStockObject` e [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)ou recuperados pela função Windows.

Ao preencher o retângulo `FillRect` especificado, não inclui os lados direito e inferior do retângulo. O GDI preenche um retângulo até, mas não inclui a coluna direita e a linha inferior, independentemente do modo de mapeamento atual. `FillRect`compara os valores `top`do `right` retângulo `bottom` `left`especificado. Se `bottom` for menor ou `top`igual `right` a , ou `left`se for menor ou igual a , o retângulo não é desenhado.

`FillRect`é semelhante ao [CDC::FillSolidRect](#fillsolidrect); no `FillRect` entanto, pega um pincel e, portanto, pode ser usado para preencher um retângulo com uma cor sólida, uma cor dithered, pincéis eclodidos ou um padrão. `FillSolidRect`usa apenas cores sólidas (indicadas por um parâmetro COLORREF). `FillRect`geralmente é mais `FillSolidRect`lento do que .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC::FillRgn

Preenche a região especificada por *pRgn* com o pincel especificado por *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*Prgn*<br/>
Um ponteiro para a região a ser preenchida. As coordenadas para a determinada região são especificadas em unidades lógicas.

*pBrush*<br/>
Identifica o pincel a ser usado para preencher a região.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O pincel deve ser criado `CBrush` usando `CreateHatchBrush`as `CreatePatternBrush` `CreateSolidBrush`funções do membro, ou ser recuperado por `GetStockObject`.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC:::FillSolidRect

Chame esta função de membro para preencher o retângulo dado com a cor sólida especificada.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para uma `CRect` estrutura de dados [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto para este parâmetro.

*clr* Especifica a cor a ser usada para preencher o retângulo.

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*Y*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo de destino.

*Cx*<br/>
Especifica a largura do retângulo.

*Cy*<br/>
Especifica a altura do retângulo.

### <a name="remarks"></a>Comentários

`FillSolidRect`é muito semelhante ao [CDC::FillRect;](#fillrect) no `FillSolidRect` entanto, usa apenas cores sólidas (indicadas pelo parâmetro COLORREF), enquanto `FillRect` pega um pincel e, portanto, pode ser usado para preencher um retângulo com uma cor sólida, uma cor dithered, pincéis eclodidos ou um padrão. `FillSolidRect`geralmente é `FillRect`mais rápido do que .

> [!NOTE]
> Quando você `FillSolidRect`chama , a cor de fundo, que foi previamente definida usando [SetBkColor](#setbkcolor), é definida como a cor indicada pelo *clr*.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::FlattenPath

Transforma quaisquer curvas no caminho selecionado no contexto atual do dispositivo e transforma cada curva em uma seqüência de linhas.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::Preenchimento de inundações

Preenche uma área da superfície do display com o pincel atual.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto onde o preenchimento começa.

*Y*<br/>
Especifica a coordenada lógica y do ponto onde o preenchimento começa.

*Crcolor*<br/>
Especifica a cor do limite.

### <a name="return-value"></a>Valor retornado

Não zero se a função for bem sucedida; caso contrário 0 é devolvido se o enchimento não puder ser concluído, o ponto dado tem a cor de limite especificada por *crColor*, ou o ponto está fora da região de recorte.

### <a name="remarks"></a>Comentários

Presume-se que a área seja limitada conforme especificado pelo *crColor*. A `FloodFill` função começa no ponto especificado por *x* e *y* e continua em todas as direções até o limite de cor.

Apenas contextos de dispositivo de memória e dispositivos que `FloodFill` suportam a tecnologia de exibição de rasteros suportam a função do membro. Para obter informações sobre `GetDeviceCaps` RC_BITBLT capacidade, consulte a função do membro.

A `ExtFloodFill` função oferece capacidade semelhante, mas maior flexibilidade.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::FrameRect

Desenha uma borda em torno do retângulo especificado por *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contém as coordenadas lógicas dos cantos superior-esquerdo e inferior direito do retângulo. Você também pode `CRect` passar um objeto para este parâmetro.

*pBrush*<br/>
Identifica o pincel a ser usado para enquadrar o retângulo.

### <a name="remarks"></a>Comentários

A função usa o pincel dado para desenhar a borda. A largura e altura da borda é sempre 1 unidade lógica.

Se a coordenada do `bottom` retângulo for `top`menor ou `right` igual a , `left`ou se for menor ou igual a , o retângulo não é desenhado.

A borda `FrameRect` desenhada está na mesma posição que `Rectangle` uma borda desenhada pela `Rectangle` função do membro usando as mesmas coordenadas (se usar uma caneta de 1 unidade lógica de largura). O interior do retângulo não `FrameRect`é preenchido por .

## <a name="cdcframergn"></a><a name="framergn"></a>CDC::FrameRgn

Desenha uma borda ao redor da região especificada por *pRgn* usando o pincel especificado por *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*Prgn*<br/>
Aponta para `CRgn` o objeto que identifica a região a ser fechada em uma fronteira. As coordenadas para a determinada região são especificadas em unidades lógicas.

*pBrush*<br/>
Aponta para `CBrush` o objeto que identifica o pincel a ser usado para desenhar a borda.

*Nwidth*<br/>
Especifica a largura da borda em pinceladas verticais em unidades do dispositivo.

*Nheight*<br/>
Especifica a altura da borda em pinceladas horizontais em unidades do dispositivo.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::FromHandle

Retorna um ponteiro `CDC` para um objeto quando dado uma alça a um contexto do dispositivo.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*Hdc*<br/>
Contém uma alça para um contexto de dispositivo Windows.

### <a name="return-value"></a>Valor retornado

O ponteiro pode ser temporário e não deve ser armazenado além do uso imediato.

### <a name="remarks"></a>Comentários

Se `CDC` um objeto não estiver conectado à `CDC` alça, um objeto temporário será criado e anexado.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC::GetArcDirection

Retorna a direção do arco atual para o contexto do dispositivo.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valor retornado

Especifica a direção do arco atual, se bem sucedida. A seguir estão os valores de retorno válidos:

- AD_COUNTERCLOCKWISE Arcos e retângulos desenhados no sentido anti-horário.

- arcos AD_CLOCKWISE e retângulos desenhados no sentido horário.

Se ocorrer um erro, o valor de retorno é zero.

### <a name="remarks"></a>Comentários

As funções de arco e retângulo usam a direção do arco.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter

Recupera a configuração para o filtro de proporção atual.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valor retornado

Um `CSize` objeto representando a proporção utilizada pelo filtro de proporção atual.

### <a name="remarks"></a>Comentários

A proporção é a proporção formada pela largura e altura dos pixels de um dispositivo. Informações sobre a proporção de um dispositivo são usadas na criação, seleção e exibição de fontes. O Windows fornece um filtro especial, o filtro de proporção, para selecionar fontes projetadas para uma proporção específica de todas as fontes disponíveis. O filtro usa a proporção `SetMapperFlags` especificada pela função do membro.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::GetBkColor

Retorna a cor de fundo atual.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valor retornado

Um valor de cor RGB.

### <a name="remarks"></a>Comentários

Se o modo de fundo for OPAQUE, o sistema usa a cor de fundo para preencher as lacunas em linhas estilizadas, as lacunas entre linhas eclodidas em pincéis e o fundo nas células de caracteres. O sistema também usa a cor de fundo ao converter bitmaps entre contextos de dispositivos monocromáticos e de cores.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC::GetBkMode

Retorna o modo de fundo.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valor retornado

O modo de fundo atual, que pode ser OPAQUE ou TRANSPARENTE.

### <a name="remarks"></a>Comentários

O modo de fundo define se o sistema remove as cores de fundo existentes na superfície do desenho antes de desenhar texto, pincéis eclodidos ou qualquer estilo de caneta que não seja uma linha sólida.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::GetBoundsRect

Retorna o retângulo delimitador acumulado atual para o contexto do dispositivo especificado.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parâmetros

*lpRectBounds*<br/>
Aponta para um buffer que receberá o retângulo delimitador atual. O retângulo é devolvido em coordenadas lógicas.

*Sinalizadores*<br/>
Especifica se o retângulo delimitador deve ser limpo após o retorno. Este parâmetro deve ser zero ou definido para o seguinte valor:

- DCB_RESET força o retângulo delimitador a ser limpo depois de devolvido.

### <a name="return-value"></a>Valor retornado

Especifica o estado atual do retângulo delimitador se a função for bem sucedida. Pode ser uma combinação dos seguintes valores:

- DCB_ACCUMULATE acúmulo de retângulo delimitador está ocorrendo.

- DCB_RESET retângulo delimitador está vazio.

- DCB_SET retângulo delimitador não está vazio.

- DCB_ENABLE acúmulo de limitador está ligado.

- DCB_DISABLE acúmulo delimitador está desligado.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::Getbrushorg

Recupera a origem (em unidades de dispositivo) do pincel atualmente selecionado para o contexto do dispositivo.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valor retornado

A origem atual do pincel (em unidades do dispositivo) como um objeto [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="remarks"></a>Comentários

A origem inicial do pincel está em (0,0) da área do cliente. O valor de retorno especifica este ponto em unidades do dispositivo em relação à origem da janela da área de trabalho.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::GetCharacterPlacement

Recupera vários tipos de informações em uma seqüência de caracteres.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parâmetros

*Lpstring*<br/>
Um ponteiro para a seqüência de caracteres para processar.

*Ncount*<br/>
Especifica o comprimento da seqüência. Para a versão ANSI, é uma contagem BYTE e para a função Unicode é uma contagem DE WORD. Para obter mais informações, consulte [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*Nmaxextent*<br/>
Especifica a extensão máxima (em unidades lógicas) para a qual a seqüência é processada. Personagens que, se processados, excederiam essa extensão são ignorados. Os cálculos para qualquer pedido ou matrizes de glifo necessários aplicam-se apenas aos caracteres incluídos. Este parâmetro é usado somente se o valor GCP_MAXEXTENT for especificado no parâmetro *dwFlags.* À medida que a função processa a seqüência de entrada, cada caractere e sua extensão são adicionados à saída, extensão e outras matrizes apenas se a extensão total ainda não tiver excedido o máximo. Uma vez atingido o limite, o processamento parará.

*lpResultadoss*<br/>
Ponteiro para uma estrutura [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) que recebe os resultados da função.

*dwFlags*<br/>
Especifica como processar a seqüência nas matrizes necessárias. Este parâmetro pode ser um ou mais dos valores listados na seção *dwFlags* do tópico [GetCharacterPlacement.](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)

*Str*<br/>
Um ponteiro para um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para processar.

### <a name="return-value"></a>Valor retornado

Se a função for bem sucedida, o valor de retorno será a largura e a altura da string em unidades lógicas.

Se a função falhar, o valor retornado será zero.

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), conforme descrito no SDK do Windows.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::GetCharABCWidths

Recupera as larguras de caracteres consecutivos em uma faixa especificada da fonte TrueType atual.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parâmetros

*Nfirstchar*<br/>
Especifica o primeiro caractere na faixa de caracteres da fonte atual para a qual as larguras de caracteres são devolvidas.

*Nlastchar*<br/>
Especifica o último caractere na faixa de caracteres da fonte atual para a qual as larguras de caracteres são devolvidas.

*lpabc*<br/>
Aponta para uma matriz de estruturas [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que recebem as larguras de caractere quando a função retorna. Esta matriz deve conter `ABC` pelo menos tantas estruturas quanto há caracteres no intervalo especificado pelos parâmetros *nFirstChar* e *nLastChar.*

*lpABCF*<br/>
Aponta para um buffer fornecido por aplicativo com uma matriz de estruturas [ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat) para receber as larguras de caractere quando a função retorna. As larguras retornadas por esta função estão no formato de ponto flutuante IEEE.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As larguras são devolvidas em unidades lógicas. Esta função é bem sucedida apenas com fontes TrueType.

O rasterizador TrueType fornece espaçamento de caracteres "ABC" depois que um tamanho de ponto específico foi selecionado. O espaçamento "A" é a distância que é adicionada à posição atual antes de colocar o glifo. O espaçamento "B" é a largura da parte preta do glifo. O espaçamento "C" é adicionado à posição atual para explicar o espaço branco à direita do glifo. A largura avançada total é dada por A + B + C.

Quando `GetCharABCWidths` a função do membro recupera larguras negativas de "A" ou "C" para um caractere, esse caractere inclui saliências ou saliências.

Para converter as larguras de ABC em unidades de design de fonte, `lfHeight` um aplicativo deve criar uma fonte cuja `ntmSizeEM` altura (conforme especificado no membro da estrutura [LOGFONT)](/windows/win32/api/wingdi/ns-wingdi-logfontw) seja igual ao valor armazenado no membro da estrutura [NEWTEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) (O valor `ntmSizeEM` do membro pode ser recuperado chamando a função [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows.)

As larguras ABC do caractere padrão são usadas para caracteres que estão fora do intervalo da fonte selecionada no momento.

Para recuperar as larguras dos caracteres em fontes não-TrueType, os aplicativos devem usar a função [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI

Recupera as larguras, em unidades lógicas, de índices de glifo consecutivos em uma faixa especificada da fonte TrueType atual.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parâmetros

*giFirst*<br/>
Especifica o primeiro índice de glifo no grupo de índices de glifos consecutivos da fonte atual. Este parâmetro só é usado se o parâmetro *pgi* for NULO.

*Cgi*<br/>
Especifica o número de índices de glifos.

*Igp*<br/>
Um ponteiro para uma matriz contendo índices de glifo. Se o valor for NULO, o parâmetro *giFirst* será usado em vez disso. O *parâmetro cgi* especifica o número de índices de glifo nesta matriz.

*lpabc*<br/>
Ponteiro para uma matriz de estruturas [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que recebem as larguras de caracteres. Esta matriz deve conter `ABC` pelo menos tantas estruturas quanto há índices de glifos especificados pelo parâmetro *cgi.*

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), conforme descrito no SDK do Windows.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::GetCharWidth

Recupera as larguras de caracteres individuais em um grupo `m_hAttribDC`consecutivo de caracteres da fonte atual, usando , o contexto do dispositivo de entrada.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*Nfirstchar*<br/>
Especifica o primeiro caractere em um grupo consecutivo de caracteres na fonte atual.

*Nlastchar*<br/>
Especifica o último caractere em um grupo consecutivo de caracteres na fonte atual.

*Lpbuffer*<br/>
Aponta para um buffer que receberá os valores de largura para um grupo consecutivo de caracteres na fonte atual.

*lpFloatBuffer*<br/>
Aponta para um buffer para receber as larguras de caractere. As larguras retornadas estão no formato de ponto flutuante IEEE de 32 bits. (As larguras são medidas ao longo da linha de base dos caracteres.)

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Por exemplo, se *nFirstChar* identificar a letra 'a' e *nLastChar* identificar a letra 'z', a função recuperará as larguras de todos os caracteres minúsculos.

A função armazena os valores no buffer apontados por *lpBuffer*. Este buffer deve ser grande o suficiente para segurar todas as larguras. Ou seja, deve haver pelo menos 26 entradas no exemplo dado.

Se um caractere no grupo consecutivo de caracteres não existir em uma fonte específica, ele será atribuído ao valor de largura do caractere padrão.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::getcharwidthi

Recupera as larguras, em coordenadas lógicas, de índices de glifo consecutivos em uma faixa especificada da fonte atual.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*giFirst*<br/>
Especifica o primeiro índice de glifo no grupo de índices de glifos consecutivos da fonte atual. Este parâmetro só é usado se o parâmetro *pgi* for NULO.

*Cgi*<br/>
Especifica o número de índices de glifos.

*Igp*<br/>
Um ponteiro para uma matriz contendo índices de glifo. Se o valor for NULO, o parâmetro *giFirst* será usado em vez disso. O *parâmetro cgi* especifica o número de índices de glifo nesta matriz.

*Lpbuffer*<br/>
Um ponteiro para um buffer que recebe as larguras.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), conforme descrito no SDK do Windows.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC::GetClipBox

Recupera as dimensões do retângulo delimitador mais apertado ao redor do limite de recorte atual.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para a estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que deve receber as dimensões do retângulo.

### <a name="return-value"></a>Valor retornado

O tipo da região de recorte. Pode ser qualquer um dos seguintes valores:

- REGIÃO COMPLEXA A região de recorte tem fronteiras sobrepostas.

- ERRO O contexto do dispositivo não é válido.

- NULLREGION A região de recorte está vazia.

- REGIÃO SIMPLESRegião A região de recorte não tem fronteiras sobrepostas.

### <a name="remarks"></a>Comentários

As dimensões são copiadas para o buffer apontado por *lpRect*.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::Obter ajuste de cores

Recupera os valores de ajuste de cor para o contexto do dispositivo.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parâmetros

*lpColorAdjust*<br/>
Aponta para uma estrutura de dados [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) para receber os valores de ajuste de cor.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap

Retorna um ponteiro para `CBitmap` o objeto selecionado no momento.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valor retornado

Ponteiro para `CBitmap` um objeto, se bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Esta função de membro pode retornar objetos temporários.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC::GetCurrentbrush

Retorna um ponteiro para `CBrush` o objeto selecionado no momento.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valor retornado

Ponteiro para `CBrush` um objeto, se bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Esta função de membro pode retornar objetos temporários.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::GetCurrentFont

Retorna um ponteiro para `CFont` o objeto selecionado no momento.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valor retornado

Ponteiro para `CFont` um objeto, se bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Esta função de membro pode retornar objetos temporários.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::GetCurrentPalette

Retorna um ponteiro para `CPalette` o objeto selecionado no momento.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valor retornado

Ponteiro para `CPalette` um objeto, se bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Esta função de membro pode retornar objetos temporários.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::GetCurrentPen

Retorna um ponteiro para `CPen` o objeto selecionado no momento.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valor retornado

Ponteiro para `CPen` um objeto, se bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Esta função de membro pode retornar objetos temporários.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::GetCurrentPosition

Recupera a posição atual (em coordenadas lógicas).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valor retornado

A posição atual `CPoint` como objeto.

### <a name="remarks"></a>Comentários

A posição atual pode `MoveTo` ser definida com a função do membro.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::GetDCBrushColor

Recupera a cor atual do pincel.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valor retornado

Se a função for bem sucedida, o valor de retorno será o valor [COLORREF](/windows/win32/gdi/colorref) para a cor do pincel atual.

Se a função falhar, o valor de retorno será CLR_INVALID.

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), conforme descrito no SDK do Windows.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::GetDCPenColor

Recupera a cor atual da caneta.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valor retornado

Se a função for bem sucedida, o valor de retorno será o valor [COLORREF](/windows/win32/gdi/colorref) para a cor da caneta atual.

Se a função falhar, o valor de retorno será CLR_INVALID.

### <a name="remarks"></a>Comentários

Esta função de membro utiliza a função Win32 [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), conforme descrito no SDK do Windows.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::GetDeviceCaps

Recupera uma ampla gama de informações específicas do dispositivo sobre o dispositivo de exibição.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parâmetros

*nIndex*<br/>
Especifica o tipo de informação a ser devolvida. Consulte [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) no Windows SDK para obter uma lista de valores.

### <a name="return-value"></a>Valor retornado

O valor da capacidade solicitada se a função for bem sucedida.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC::GetFontData

Recupera informações de métrica de fonte de um arquivo de fonte escalável.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parâmetros

*Dwtable*<br/>
Especifica o nome da tabela métrica a ser devolvida. Este parâmetro pode ser uma das tabelas métricas documentadas na especificação TrueType Font Files publicada pela Microsoft Corporation. Se este parâmetro for 0, as informações são recuperadas a partir do início do arquivo de fonte.

*Dwoffset*<br/>
Especifica o deslocamento desde o início da tabela para começar a recuperar informações. Se este parâmetro for 0, as informações são recuperadas a partir do início da tabela especificada pelo parâmetro *dwTable.* Se este valor for maior ou igual ao `GetFontData` tamanho da tabela, retorna 0.

*Lpdata*<br/>
Aponta para um buffer que receberá as informações da fonte. Se esse valor for NULO, a função retorna o tamanho do buffer necessário para os dados de fonte especificados no parâmetro *dwTable.*

*cbData*<br/>
Especifica o comprimento, em bytes, das informações a serem recuperadas. Se este parâmetro for `GetFontData` 0, retorne o tamanho dos dados especificados no parâmetro *dwTable.*

### <a name="return-value"></a>Valor retornado

Especifica o número de bytes retornados no buffer apontado por *lpData* se a função for bem sucedida; caso contrário -1.

### <a name="remarks"></a>Comentários

As informações a serem recuperadas são identificadas especificando um deslocamento no arquivo de fonte e o comprimento das informações a serem devolvidas.

Um aplicativo às `GetFontData` vezes pode usar a função member para salvar uma fonte TrueType com um documento. Para fazer isso, o aplicativo determina se a fonte pode ser incorporada e, em seguida, recupera todo o arquivo de fonte, especificando 0 para os parâmetros *dwTable,* *dwOffset*e *cbData.*

Os aplicativos podem determinar se uma fonte `otmfsType` pode ser incorporada verificando o membro da estrutura [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Se o `otmfsType` bit 1 estiver definido, a incorporação não é permitida para a fonte. Se o bit 1 estiver limpo, a fonte pode ser incorporada. Se o bit 2 estiver definido, a incorporação será apenas lida.

Se um aplicativo tentar usar essa função para recuperar informações `GetFontData` para uma fonte não-TrueType, a função membro reah -1.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo

Retorna informações sobre a fonte selecionada no momento para o contexto de exibição especificado.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valor retornado

O valor de retorno identifica características da fonte selecionada no momento. Para obter uma lista completa de valores possíveis, consulte [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), conforme descrito no SDK do Windows.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC:::GetGlyphOutline

Recupera a curva de contorno ou bitmap para um caractere de contorno na fonte atual.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parâmetros

*Nchar*<br/>
Especifica o caractere para o qual as informações devem ser devolvidas.

*Nformat*<br/>
Especifica o formato em que a função deve retornar informações. Pode ser um dos seguintes valores, ou 0:

|Valor|Significado|
|-----------|-------------|
|GGO_BITMAP|Retorna o bitmap glifo. Quando a função retorna, o buffer apontado pelo *lpBuffer* contém um bitmap de 1 bit por pixel cujas linhas começam em limites de palavras duplas.|
|Ggo_native|Retorna os pontos de dados da curva no formato nativo do rasterizador, usando unidades do dispositivo. Quando esse valor é especificado, qualquer transformação especificada no *lpmat2* é ignorada.|

Quando o valor do *nFormat* é 0, a função preenche uma estrutura [GLIFPHMETRICS,](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) mas não retorna dados de contorno de glifos.

*glpm*<br/>
Aponta para uma estrutura glifosa que descreve a colocação do glifo na célula do personagem.

*cbBuffer*<br/>
Especifica o tamanho do buffer no qual a função copia informações sobre o caractere de contorno. Se este valor for 0 e o parâmetro *nFormat* for o valor GGO_BITMAP ou GGO_NATIVE, a função retorna o tamanho necessário do buffer.

*Lpbuffer*<br/>
Aponta para um buffer no qual a função copia informações sobre o caractere de contorno. Se *nFormat* especificar o valor GGO_NATIVE, as informações serão copiadas sob a forma de estruturas TTPOLYGONHEADER e TTPOLYCURVE. Se esse valor for NULL e *nFormat* for o valor GGO_BITMAP ou GGO_NATIVE, a função retorna o tamanho necessário do buffer.

*Lpmat2*<br/>
Aponta para uma estrutura [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) que contém uma matriz de transformação para o personagem. Este parâmetro não pode ser NULO, mesmo quando o valor GGO_NATIVE é especificado para *nFormat*.

### <a name="return-value"></a>Valor retornado

O tamanho, em bytes, do buffer necessário para as informações recuperadas se *cbBuffer* é 0 ou *lpBuffer* é NULL. Caso contrário, é um valor positivo se a função for bem sucedida, ou -1 se houver um erro.

### <a name="remarks"></a>Comentários

Um aplicativo pode girar caracteres recuperados no formato bitmap especificando uma matriz de transformação 2 por 2 na estrutura apontada pelo *lpmat2*.

Um contorno de glifo é devolvido como uma série de contornos. Cada contorno é definido por uma estrutura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) seguida por tantas `TTPOLYCURVE` estruturas quanto são necessárias para descrevê-lo. Todos os pontos são retornados como estruturas [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) e representam posições absolutas, não movimentos relativos. O ponto de `pfxStart` partida dado pelo membro da estrutura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) é o ponto em que o contorno começa. As estruturas [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) que seguem podem ser registros poliline ou registros spline. Registros poliline são uma série de pontos; linhas desenhadas entre os pontos descrevem o contorno do personagem. Os registros de spline representam as curvas quadráticas usadas pelo TrueType (ou seja, b-splines quadráticos).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC::GetGraphicsMode

Recupera o modo gráfico atual para o contexto especificado do dispositivo.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valor retornado

Retorna o modo gráfico atual com sucesso. Para obter uma lista dos valores que este método pode retornar, consulte [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Retorna 0 em falha.

Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Este método envolve a função [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)do Windows GDI .

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC::GetHalftoneBrush

Chame esta função de membro para recuperar um pincel de meio tom.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valor retornado

Um ponteiro `CBrush` para um objeto se for bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Um pincel de meio tom mostra pixels que são alternadamente em primeiro plano e cores de fundo para criar um padrão dithered. O seguinte é um exemplo de um padrão dithered criado por um pincel de meio tom.

![Detalhe de um traço de caneta dithered](../../mfc/reference/media/vc318s1.gif "Detalhe de um traço de caneta dithered")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC::GetKerningPairs

Recupera os pares de kerning de caracteres para a fonte atualmente selecionada no contexto do dispositivo especificado.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parâmetros

*nPares*<br/>
Especifica o número de estruturas [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) apontadas por *lpkrnpair*. A função não copiará mais pares de kerning do que especificados por *nPairs*.

*lpkrnpair*<br/>
Aponta para uma `KERNINGPAIR` matriz de estruturas que recebem os pares de kerning quando a função retorna. Esta matriz deve conter pelo menos tantas estruturas como especificadas por *nPairs*. Se este parâmetro for NULO, a função retorna o número total de pares de kerning para a fonte.

### <a name="return-value"></a>Valor retornado

Especifica o número de pares de kerning recuperados ou o número total de pares de kerning na fonte, se a função for bem sucedida. Zero é devolvido se a função falhar ou não houver pares de kerning para a fonte.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC::GetLayout

Ligue para esta função de membro para determinar o layout do texto e dos gráficos para um contexto de dispositivo, como uma impressora ou um metaarquivo.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valor retornado

Se for bem-sucedido, o layout sinaliza para o contexto atual do dispositivo. Caso contrário, GDI_ERROR. Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Para obter uma lista dos sinalizadores de layout, consulte [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Comentários

O layout padrão é da esquerda para a direita.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC::GetMapMode

Recupera o modo de mapeamento atual.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valor retornado

O modo de mapeamento.

### <a name="remarks"></a>Comentários

Para obter uma descrição dos modos de mapeamento, consulte a função do `SetMapMode` membro.

> [!NOTE]
> Se você chamar [SetLayout](#setlayout) para alterar o DC `SetLayout` para o layout da direita para a esquerda, altere automaticamente o modo de mapeamento para MM_ISOTROPIC. Consequentemente, qualquer chamada `GetMapMode` subseqüente retornará MM_ISOTROPIC.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC::GetMiterLimit

Retorna o limite de miter para o contexto do dispositivo.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O limite de mitra é usado ao desenhar linhas geométricas que têm adesão de mitra.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::GetNearestColor

Retorna a cor sólida que melhor corresponde a uma cor lógica especificada.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parâmetros

*Crcolor*<br/>
Especifica a cor a ser combinada.

### <a name="return-value"></a>Valor retornado

Um valor de cor RGB (vermelho, verde, azul) que define a cor sólida mais próxima do valor *crColor* que o dispositivo pode representar.

### <a name="remarks"></a>Comentários

O dispositivo dado deve ser capaz de representar esta cor.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics

Recupera informações métricas para fontes TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parâmetros

*Lpotm*<br/>
Aponta para uma matriz de estruturas [DESPORTOTEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Se esse parâmetro for NULO, a função retorna o tamanho do buffer necessário para os dados métricos recuperados.

*cbData*<br/>
Especifica o tamanho, em bytes, do buffer para o qual as informações são devolvidas.

*Lpotm*<br/>
Aponta para `OUTLINETEXTMETRIC` uma estrutura. Se este parâmetro for NULO, a função retorna o tamanho do buffer necessário para as informações métricas recuperadas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A estrutura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) contém a maioria das informações métricas de fonte fornecidas com o formato TrueType, incluindo uma estrutura [TEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-textmetricw) Os últimos quatro `OUTLINETEXTMETRIC` membros da estrutura são ponteiros para cordas. As aplicações devem alocar espaço para essas cordas, além do espaço necessário para os outros membros. Como não há um limite imposto pelo sistema para o tamanho das strings, o método mais simples para alocar memória é recuperar `GetOutlineTextMetrics` o tamanho necessário especificando NULL para *lpotm* na primeira chamada para a função.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth

Usa o contexto `m_hDC`do dispositivo de saída e recupera as larguras de caracteres individuais em um grupo consecutivo de caracteres da fonte atual.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*Nfirstchar*<br/>
Especifica o primeiro caractere em um grupo consecutivo de caracteres na fonte atual.

*Nlastchar*<br/>
Especifica o último caractere em um grupo consecutivo de caracteres na fonte atual.

*Lpbuffer*<br/>
Aponta para um buffer que receberá os valores de largura para um grupo consecutivo de caracteres na fonte atual.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Por exemplo, se *nFirstChar* identificar a letra 'a' e *nLastChar* identificar a letra 'z', a função recuperará as larguras de todos os caracteres minúsculos.

A função armazena os valores no buffer apontados por *lpBuffer*. Este buffer deve ser grande o suficiente para conter todas as larguras; ou seja, deve haver pelo menos 26 entradas no exemplo dado.

Se um caractere no grupo consecutivo de caracteres não existir em uma fonte específica, ele será atribuído ao valor de largura do caractere padrão.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC::Get'''' '''''''''''''''''''''

Chame esta função de membro para calcular a largura e a altura de uma cadeia de caracteres usando [m_hDC](#m_hdc), o contexto do dispositivo de saída.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma seqüência de caracteres a ser medida. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parâmetro.

*Ncount*<br/>
Especifica o [comprimento da seqüência](/windows/win32/gdi/specifying-length-of-text-output-string) apontou para *lpszString*.

*Ntabpositions*<br/>
Especifica o número de posições de 'stop de guia' na matriz apontada por *lpnTabStopPositions*.

*Lpntabstoppositions*<br/>
Aponta para uma matriz de inteiros contendo as posições de guia-stop em unidades lógicas. As guias devem ser classificadas em ordem crescente; o menor valor x deve ser o primeiro item na matriz. As guias de trás não são permitidas.

*Str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem medidos.

### <a name="return-value"></a>Valor retornado

As dimensões da seqüência (em unidades lógicas) em um objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

Se a seqüência contiver um ou mais caracteres de guia, a largura da seqüência será baseada nas guias de paradas especificadas pelo *lpnTabStopPositions*. A função usa a fonte selecionada no momento para calcular as dimensões da string.

A região de recorte atual não compensa `GetOutputTabbedTextExtent` a largura e a altura retornadas pela função.

Uma vez que alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles kern os caracteres), a soma das extensões dos caracteres em uma seqüência pode não ser igual à extensão da seqüência.

Se *nTabPositions* for 0 e *lpnTabStopPositions* for NULL, as guias serão expandidas para oito larguras médias de caracteres. Se *nTabPositions* for 1, as guias serão separadas pela distância especificada pelo primeiro valor na matriz para a qual *lpnTabStopPositions* aponta. Se *lpnTabStopPositions* apontar para mais de um único valor, uma parada de guia será definida para cada valor na matriz, até o número especificado por *nTabPositions*.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC::getOutputTextExtent

Ligue para esta função de membro para usar o contexto do dispositivo de saída, [m_hDC](#m_hdc)e calcular a largura e a altura de uma linha de texto, usando a fonte atual.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma série de caracteres. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parâmetro.

*Ncount*<br/>
Especifica o [comprimento da seqüência](/windows/win32/gdi/specifying-length-of-text-output-string) apontou para *lpszString*.

*Str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem medidos.

### <a name="return-value"></a>Valor retornado

As dimensões da seqüência (em unidades lógicas) retornaram em um objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

A região de recorte atual não afeta `GetOutputTextExtent`a largura e a altura retornadas por .

Uma vez que alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles realizam kerning), a soma das extensões dos caracteres em uma seqüência pode não ser igual à extensão da seqüência.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics

Recupera as métricas para a `m_hDC`fonte atual usando , o contexto do dispositivo de saída.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parâmetros

*lpMetrics*<br/>
Aponta para a estrutura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recebe as métricas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC::GetPath

Recupera as coordenadas que definem os pontos finais das linhas e os pontos de controle das curvas encontradas no caminho selecionado no contexto do dispositivo.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma [POINT](/windows/win32/api/windef/ns-windef-point) matriz de `CPoint` estruturas de dados POINT ou objetos onde os pontos finais de linha e os pontos de controle da curva são colocados.

*lpTypes*<br/>
Aponta para uma matriz de bytes onde os tipos de vértices são colocados. Os valores são um dos seguintes:

- PT_MOVETO Especifica que o ponto correspondente em *lpPoints* inicia uma figura desarticulada.

- PT_LINETO Especifica que o ponto anterior e o ponto correspondente em *lpPoints* são os pontos finais de uma linha.

- PT_BEZIERTO Especifica que o ponto correspondente em *lpPoints* é um ponto de controle ou ponto final para uma curva Bzier.

PT_BEZIERTO tipos sempre ocorrem em conjuntos de três. O ponto no caminho imediatamente anterior a eles define o ponto de partida para a curva de Bzier. Os dois primeiros PT_BEZIERTO pontos são os pontos de controle, e o terceiro ponto PT_BEZIERTO é o ponto final (se codificado).

   Um PT_LINETO ou PT_BEZIERTO tipo pode ser combinado com o seguinte sinalizador (usando o operador bitwise **OR)** para indicar que o ponto correspondente é o último ponto de uma figura e que a figura deve ser fechada:

- PT_CLOSEFIGURE Especifica que a figura é automaticamente fechada após a linha ou curva correspondente sacada. A figura é fechada desenhando uma linha da linha ou ponto final da curva ao ponto correspondente ao último PT_MOVETO.

*Ncount*<br/>
Especifica o número total de estruturas de dados [POINT](/windows/win32/api/windef/ns-windef-point) que podem ser colocadas na matriz *lpPoints.* Este valor deve ser o mesmo que o número de bytes que podem ser colocados na matriz *lpTypes.*

### <a name="return-value"></a>Valor retornado

Se o parâmetro *nCount* não for zero, o número de pontos enumerado. Se *nCount* for 0, o número total `GetPath` de pontos no caminho (e não grava nada para os buffers). Se *nCount* não for zero e for menor que o número de pontos no caminho, o valor de retorno será de -1.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado. Os pontos do caminho são devolvidos em coordenadas lógicas. Os pontos são armazenados no caminho `GetPath` nas coordenadas do dispositivo, então altera os pontos das coordenadas do dispositivo para coordenadas lógicas usando o inverso da transformação atual. A `FlattenPath` função do membro `GetPath`pode ser chamada antes, para converter todas as curvas no caminho em segmentos de linha.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC::GetPixel

Recupera o valor de cor RGB do pixel no ponto especificado por *x* e *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto a ser examinado.

*Y*<br/>
Especifica a coordenada lógica y do ponto a ser examinado.

*Ponto*<br/>
Especifica as coordenadas lógicas x e y do ponto a ser examinado.

### <a name="return-value"></a>Valor retornado

Para qualquer versão da função, um valor de cor RGB para a cor do ponto dado. É -1 se as coordenadas não especificarem um ponto na região de recorte.

### <a name="remarks"></a>Comentários

O ponto deve ser na região de recorte. Se o ponto não estiver na região de recorte, a função não tem efeito e retorna -1.

Nem todos os dispositivos oferecem suporte à função `GetPixel`. Para obter mais informações, consulte o recurso de rasterde RC_BITBLT na função [membro GetDeviceCaps.](#getdevicecaps)

A `GetPixel` função do membro tem duas formas. O primeiro leva dois valores de coordenadas; o segundo leva uma estrutura [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC::GetPolyFillmode

Recupera o modo de enchimento do polígono atual.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valor retornado

O modo atual preenchido pelo polígono, ALTERNATE ou WINDING, se a função for bem sucedida.

### <a name="remarks"></a>Comentários

Consulte `SetPolyFillMode` a função do membro para obter uma descrição dos modos de enchimento do polígono.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::GetROP2

Recupera o modo de desenho atual.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valor retornado

O modo de desenho. Para obter uma lista dos valores do modo de desenho, consulte a função do `SetROP2` membro.

### <a name="remarks"></a>Comentários

O modo desenho especifica como as cores da caneta e o interior dos objetos preenchidos são combinados com a cor já na superfície do display.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC::GetSafeHdc

Ligue para esta função de membro para obter [m_hDC](#m_hdc), o contexto do dispositivo de saída.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valor retornado

Uma alça de contexto do dispositivo.

### <a name="remarks"></a>Comentários

Esta função de membro também funciona com ponteiros nulos.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC::GetStretchBltMode

Recupera o modo de alongamento do bitmap atual.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valor retornado

O valor de retorno especifica o modo atual de alongamento do bitmap — STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS — se a função for bem sucedida.

### <a name="remarks"></a>Comentários

O modo de alongamento do bitmap define como as informações são removidas de bitmaps esticados ou compactados pela função do `StretchBlt` membro.

Os modos STRETCH_ANDSCANS e STRETCH_ORSCANS são tipicamente usados para preservar pixels em primeiro plano em bitmaps monocromáticos. O modo STRETCH_DELETESCANS é normalmente usado para preservar cores em bitmaps de cores.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent

Chame esta função de membro para calcular a largura e a altura de uma cadeia de caracteres usando [m_hAttribDC](#m_hattribdc), o contexto do dispositivo de atributo.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma seqüência de caracteres. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parâmetro.

*Ncount*<br/>
Especifica o [comprimento da seqüência](/windows/win32/gdi/specifying-length-of-text-output-string) apontou para *lpszString*.

*Ntabpositions*<br/>
Especifica o número de posições de 'stop de guia' na matriz apontada por *lpnTabStopPositions*.

*Lpntabstoppositions*<br/>
Aponta para uma matriz de inteiros contendo as posições de guia-stop em unidades lógicas. As guias devem ser classificadas em ordem crescente; o menor valor x deve ser o primeiro item na matriz. As guias de trás não são permitidas.

*Str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem desenhados.

### <a name="return-value"></a>Valor retornado

As dimensões da seqüência (em unidades lógicas) em um objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

Se a seqüência contiver um ou mais caracteres de guia, a largura da seqüência será baseada nas guias de paradas especificadas pelo *lpnTabStopPositions*. A função usa a fonte selecionada no momento para calcular as dimensões da string.

A região de recorte atual não compensa `GetTabbedTextExtent` a largura e a altura retornadas pela função.

Uma vez que alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles kern os caracteres), a soma das extensões dos caracteres em uma seqüência pode não ser igual à extensão da seqüência.

Se *nTabPositions* for 0 e *lpnTabStopPositions* for NULL, as guias serão expandidas para oito vezes a largura média do caractere. Se *nTabPositions* for 1, as guias serão separadas pela distância especificada pelo primeiro valor na matriz para a qual *lpnTabStopPositions* aponta. Se *lpnTabStopPositions* apontar para mais de um único valor, uma parada de guia será definida para cada valor na matriz, até o número especificado por *nTabPositions*.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC::GetTextalign

Recupera o status das bandeiras de alinhamento de texto para o contexto do dispositivo.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valor retornado

O status das bandeiras de alinhamento de texto. O valor de retorno é um ou mais dos seguintes valores:

- TA_BASELINE Especifica o alinhamento do eixo x e a linha de base da fonte escolhida no retângulo delimitador.

- TA_BOTTOM Especifica o alinhamento do eixo x e a parte inferior do retângulo delimitador.

- TA_CENTER Especifica o alinhamento do eixo y e o centro do retângulo delimitador.

- TA_LEFT Especifica o alinhamento do eixo y e do lado esquerdo do retângulo delimitador.

- TA_NOUPDATECP Especifica que a posição atual não está atualizada.

- TA_RIGHT Especifica o alinhamento do eixo y e do lado direito do retângulo delimitador.

- TA_TOP Especifica o alinhamento do eixo x e a parte superior do retângulo delimitador.

- TA_UPDATECP Especifica que a posição atual está atualizada.

### <a name="remarks"></a>Comentários

As bandeiras de alinhamento `TextOut` `ExtTextOut` de texto determinam como as funções do membro alinham uma seqüência de texto em relação ao ponto de partida da string. As bandeiras de alinhamento de texto não são necessariamente bandeiras de bit único e podem ser iguais a 0. Para testar se um sinalizador está definido, um aplicativo deve seguir estas etapas:

1. Aplique o operador bitwise OR à bandeira e às suas bandeiras relacionadas, agrupadas da seguinte forma:

   - TA_LEFT, TA_CENTER e TA_RIGHT

   - TA_BASELINE, TA_BOTTOM e TA_TOP

   - TA_NOUPDATECP e TA_UPDATECP

1. Aplique o operador bitwise-AND ao resultado `GetTextAlign`e ao valor de retorno de .

1. Teste para a igualdade deste resultado e da bandeira.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra

Recupera a configuração atual para a quantidade de espaçamento entre caracteres.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valor retornado

A quantidade do espaçamento interpersonagem.

### <a name="remarks"></a>Comentários

O GDI adiciona esse espaçamento a cada caractere, incluindo caracteres de ruptura, quando grava uma linha de texto para o contexto do dispositivo.

O valor padrão para a quantidade de espaçamento de intercaracteres é 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC::GetTextColor

Recupera a cor de texto atual.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valor retornado

A cor de texto atual como um valor de cor RGB.

### <a name="remarks"></a>Comentários

A cor do texto é a cor do primeiro plano dos caracteres desenhados usando as funções de membro de saída de texto GDI [TextOut,](#textout) [ExtTextOut](#exttextout)e [TabbedTextOut](#tabbedtextout).

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC::GetTextExtent

Ligue para esta função de membro para calcular a largura e a altura de uma linha de texto usando a fonte atual para determinar as dimensões.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma série de caracteres. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parâmetro.

*Ncount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*Str*<br/>
Um `CString` objeto que contém os caracteres especificados.

### <a name="return-value"></a>Valor retornado

As dimensões da seqüência (em unidades lógicas) em um objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

As informações são obtidas a partir de [m_hAttribDC](#m_hattribdc), o contexto do dispositivo de atributo.

Por padrão, `GetTextExtent` assume que o texto para o qual ele recupera a dimensão é definido ao longo de uma linha horizontal (ou seja, a fuga é 0). Se você criar uma fonte especificando uma fuga não-zero, você deve converter o ângulo do texto explicitamente para obter as dimensões da seqüência.

A região de recorte atual não afeta `GetTextExtent`a largura e a altura retornadas por .

Uma vez que alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles realizam kerning), a soma das extensões dos caracteres em uma seqüência pode não ser igual à extensão da seqüência.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::getTextextentexPointi

Recupera o número de caracteres em uma seqüência especificada que caberá dentro de um espaço especificado e preenche uma matriz com a extensão de texto para cada um desses caracteres.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*iiIn*<br/>
Um ponteiro para uma matriz de índices de glifos para que as extensões devem ser recuperadas.

*Cgi*<br/>
Especifica o número de glifos na matriz apontada por *pgiIn*.

*Nmaxextent*<br/>
Especifica a largura máxima permitida, em unidades lógicas, da seqüência formatada.

*Lpnfit*<br/>
Um ponteiro para um inteiro que recebe uma contagem do número máximo de caracteres que se encaixam no espaço especificado por *nMaxExtent*. Quando *o lpnFit* é NULL, *nMaxExtent* é ignorado.

*alpDx*<br/>
Um ponteiro para uma matriz de inteiros que recebe extensões parciais de glifos. Cada elemento na matriz dá a distância, em unidades lógicas, entre o início da matriz de índices glifos e um dos glifos que se encaixam no espaço especificado por *nMaxExtent*. Embora esta matriz deva ter pelo menos tantos elementos quanto os índices de glifo especificados por *cgi,* a função preenche a matriz com extensões apenas para tantos índices de glifos como são especificados pelo *lpnFit*. Se *lpnDx* for NULL, a função não calculará larguras parciais de seqüência.

*lpTamanho*<br/>
Pointer para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) que recebe as dimensões da matriz de índices glifos, em unidades lógicas. Este valor não pode ser NULO.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), conforme descrito no SDK do Windows.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::getTextExtentpointI

Recupera a largura e a altura da matriz especificada de índices de glifo.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*iiIn*<br/>
Um ponteiro para uma matriz de índices de glifos para que as extensões devem ser recuperadas.

*Cgi*<br/>
Especifica o número de glifos na matriz apontada por *pgiIn*.

*lpTamanho*<br/>
Pointer para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) que recebe as dimensões da matriz de índices glifos, em unidades lógicas. Este valor não pode ser NULO.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função de membro emula a funcionalidade da função [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), conforme descrito no SDK do Windows.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC::GetTextFace

Chame esta função de membro para copiar o nome de tipo da fonte atual em um buffer.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parâmetros

*Ncount*<br/>
Especifica o tamanho do buffer (em bytes). Se o nome do tipo for maior do que o número de bytes especificados por este parâmetro, o nome será truncado.

*Lpszfacename*<br/>
Aponta para o buffer para o nome do tipo.

*rString*<br/>
Uma referência a um objeto [CString.](../../atl-mfc-shared/reference/cstringt-class.md)

### <a name="return-value"></a>Valor retornado

O número de bytes copiados para o buffer, sem incluir o caractere nulo final. É 0 se ocorrer um erro.

### <a name="remarks"></a>Comentários

O nome do tipo é copiado como uma seqüência de seqüência sumida.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC::GetTextMetrics

Recupera as métricas para a fonte atual usando o contexto do dispositivo de atributo.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parâmetros

*lpMetrics*<br/>
Aponta para a estrutura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recebe as métricas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC::GetViewportExt

Recupera as extensões x e y da porta de visualização do contexto do dispositivo.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valor retornado

As extensões x e y (em unidades `CSize` de dispositivos) como objeto.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC::GetViewportOrg

Recupera as coordenadas x e y da origem do viewport associada ao contexto do dispositivo.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valor retornado

A origem do viewport (em coordenadas `CPoint` de dispositivo) como um objeto.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC::GetWindow

Retorna a janela associada ao contexto do dispositivo de exibição.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valor retornado

Ponteiro para `CWnd` um objeto se for bem sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Esta é uma função avançada. Por exemplo, esta função de membro pode não retornar a janela de exibição ao imprimir ou na visualização de impressão. Ele sempre retorna a janela associada à saída. Funções de saída que usam o dado DC atraem para esta janela.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC::GetWindowExt

Recupera as extensões x e y da janela associadas ao contexto do dispositivo.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valor retornado

As extensões x e y (em unidades `CSize` lógicas) como um objeto.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::GetWindowOrg

Recupera as coordenadas x e y da origem da janela associada ao contexto do dispositivo.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valor retornado

A origem da janela (em coordenadas `CPoint` lógicas) como um objeto.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC::GetWorldTransform

Recupera o espaço mundial atual para a transformação do espaço de página.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a uma estrutura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) que recebe o atual espaço mundial para transformação de espaço de página.

### <a name="return-value"></a>Valor retornado

Devolve um valor não zero no sucesso.

Retorna 0 em falha.

Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Este método envolve a função [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)do Windows GDI .

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC::GradientFill

Chame esta função de membro para preencher estruturas de retângulo e triângulo com cor que desbota suavemente de um lado para o outro.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parâmetros

*pVertices*<br/>
Ponteiro para uma matriz de estruturas [TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex) que cada um define um vértice triângulo.

*nVertices*<br/>
O número de vértices.

*pMesh*<br/>
Matriz de [estruturas GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) no modo triângulo, ou uma matriz de [estruturas GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) no modo retângulo.

*nMeshElements*<br/>
O número de elementos (triângulos ou retângulos) em *pMesh*.

*Dwmode*<br/>
Especifica o modo de preenchimento do gradiente. Para obter uma lista de valores possíveis, consulte [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) no SDK do Windows.

### <a name="return-value"></a>Valor retornado

VERDADE se bem sucedido; caso contrário, FALSO.

### <a name="remarks"></a>Comentários

Para obter mais `GradientFill` informações, consulte no Windows SDK.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::GrayString

Desenha texto escurecido (cinza) no local dado, escrevendo o texto em um bitmap de memória, escurecendo o bitmap e, em seguida, copiando o bitmap para o display.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*pBrush*<br/>
Identifica o pincel a ser usado para escurecer (cinza).

*LpfnSaída*<br/>
Especifica o endereço de instância de procedimento da função de retorno de chamada fornecida pelo aplicativo que desenhará a string. Para obter mais informações, consulte `OutputFunc` a descrição da função de [retorno de chamada](callback-functions-used-by-mfc.md#graystring)do Windows . Se esse parâmetro for NULO, `TextOut` o sistema usará a função Windows para desenhar a seqüência de caracteres, e *lpData* é assumido como um ponteiro longo para a seqüência de caracteres a ser saída.

*Lpdata*<br/>
Especifica um ponteiro distante para os dados a serem passados para a função de saída. Se *lpfnOutput* for NULL, *lpData* deve ser um ponteiro longo para a seqüência de string a ser saída.

*Ncount*<br/>
Especifica o número de caracteres a serem produzidos. Se este parâmetro for `GrayString` 0, calcula o comprimento da string (assumindo que *lpData* é um ponteiro para a string). Se *nCount* for 1 e a função apontada para *LpfnOutput* retornar 0, a imagem será mostrada, mas não escurecida.

*x*<br/>
Especifica a coordenada x lógica da posição inicial do retângulo que inclui a string.

*Y*<br/>
Especifica a coordenada lógica y da posição inicial do retângulo que inclui a string.

*Nwidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo que inclui a string. Se *nWidth* for `GrayString` 0, calcula a largura da área, assumindo que *lpData* é um ponteiro para a seqüência.

*Nheight*<br/>
Especifica a altura (em unidades lógicas) do retângulo que inclui a string. Se *nHeight* for `GrayString` 0, calcula a altura da área, assumindo que *lpData* é um ponteiro para a string.

### <a name="return-value"></a>Valor retornado

Não zero se a seqüência for `TextOut` desenhada, ou 0 se a função ou a função de saída fornecida pelo aplicativo retornaram 0, ou se não havia memória suficiente para criar um bitmap de memória para escurecimento.

### <a name="remarks"></a>Comentários

A função diminui o texto independentemente do pincel e do fundo selecionados. A `GrayString` função membro usa a fonte selecionada no momento. O modo de mapeamento MM_TEXT deve ser selecionado antes de usar esta função.

Um aplicativo pode desenhar cordas escurecidas (acinzentadas) em dispositivos `GrayString` que suportam uma cor cinza sólida sem chamar a função de membro. A cor do sistema COLOR_GRAYTEXT é a cor do sistema cinza sólido usada para desenhar texto desativado. O aplicativo pode `GetSysColor` chamar a função Windows para recuperar o valor de cor de COLOR_GRAYTEXT. Se a cor for diferente de 0 (preto), o aplicativo pode chamar a `SetTextColor` função do membro para definir a cor do texto para o valor de cor e, em seguida, desenhar a seqüência diretamente. Se a cor recuperada for preta, `GrayString` o aplicativo deve chamar para escurecer (cinza) o texto.

Se *lpfnOutput* for NULL, o GDI usará a função Windows [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) e *lpData* é assumido como um ponteiro distante para o caractere a ser despontado. Se os caracteres a serem originados não puderem ser manipulados pela função `TextOut` membro (por exemplo, a seqüência de caracteres é armazenada como um bitmap), o aplicativo deve fornecer sua própria função de saída.

Observe também que todas as funções de retorno de chamada devem prender as exceções do Microsoft Foundation antes de retornar ao Windows, uma vez que as exceções não podem ser lançadas através dos limites de retorno de chamada. Para obter mais informações sobre exceções, consulte o artigo [Exceções](../../mfc/exception-handling-in-mfc.md).

A função de `GrayString` retorno de `__stdcall` chamada aprovada deve usar `__declspec`a convenção de chamada e deve ser exportada com .

Quando a estrutura está no modo `GrayString` de visualização, uma `TextOut` chamada para a função membro é traduzida para uma chamada e a função de retorno de chamada não é chamada.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC::HIMETRICtoDP

Use esta função quando converter tamanhos HIMÉTRICOs de OLE para pixels.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpTamanho*<br/>
Aponta para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

Se o modo de mapeamento do objeto de contexto do dispositivo for MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, então a conversão é baseada no número de pixels na polegada física. Se o modo de mapeamento for um dos outros modos não restritos (por exemplo, MM_TEXT), então a conversão é baseada no número de pixels na polegada lógica.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC::HIMETRICtoLP

Chame esta função para converter unidades HIMETRIC em unidades lógicas.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpTamanho*<br/>
Aponta para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

Use esta função quando você obter tamanhos HIMETRIC do OLE e deseja convertê-los para o modo de mapeamento natural do seu aplicativo.

A conversão é realizada primeiro convertendo as unidades HIMETRIC em pixels e, em seguida, convertendo essas unidades em unidades lógicas usando as unidades de mapeamento atuais do contexto do dispositivo. Observe que a extensão da janela e da porta de exibição do dispositivo afetará o resultado.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC::IntersectClipRect

Cria uma nova região de recorte formando a intersecção da região atual e o retângulo especificado por *x1*, *y1*, *x2*e *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y1*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo.

*y2*<br/>
Especifica a coordenada lógica y do canto inferior direito do retângulo.

*Lprect*<br/>
Especifica o retângulo. Você pode passar `CRect` um objeto ou `RECT` um ponteiro para uma estrutura para este parâmetro.

### <a name="return-value"></a>Valor retornado

O novo tipo de região de recorte. Pode ser qualquer um dos seguintes valores:

- REGIÃO COMPLEXA Nova região de recorte tem fronteiras sobrepostas.

- ERRO O contexto do dispositivo não é válido.

- NULLREGION Nova região de recorte está vazia.

- REGIÃO SIMPLES Nova região de recorte não tem fronteiras sobrepostas.

### <a name="remarks"></a>Comentários

GDI corta toda a saída subseqüente para caber dentro do novo limite. A largura e a altura não devem exceder 32.767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC::InvertRect

Inverte o conteúdo do retângulo dado.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para `RECT` um que contém as coordenadas lógicas do retângulo a ser invertido. Você também pode `CRect` passar um objeto para este parâmetro.

### <a name="remarks"></a>Comentários

Inversão é uma operação NÃO lógica e vira os bits de cada pixel. Em displays monocromáticos, a função torna os pixels brancos preto saem de pixels pretos e pretos. Nas telas de cores, a inversão depende de como as cores são geradas para o display. Chamar `InvertRect` duas vezes com o mesmo retângulo restaura o display às cores anteriores.

Se o retângulo estiver vazio, nada será desenhado.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC::InvertRgn

Inverte as cores na região especificada por *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parâmetros

*Prgn*<br/>
Identifica a região a ser invertida. As coordenadas para a região são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Em displays monocromáticos, a função torna os pixels brancos preto saem de pixels pretos e pretos. Nas telas de cores, a inversão depende de como as cores são geradas para o display.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::IsPrinting

Determina se o contexto do dispositivo está sendo usado para impressão.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valor retornado

Não zero `CDC` se o objeto for uma impressora DC; caso contrário, 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC::LineTo

Desenha uma linha da posição atual até, mas não incluindo, o ponto especificado por *x* e *y* (ou *ponto*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto final para a linha.

*Y*<br/>
Especifica a coordenada lógica y do ponto final para a linha.

*Ponto*<br/>
Especifica o ponto final da linha. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Não zero se a linha for desenhada; caso contrário, 0.

### <a name="remarks"></a>Comentários

A linha é desenhada com a caneta selecionada. A posição atual é definida como *x,* *y* ou a *ponto*.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

Converte unidades lógicas em unidades de dispositivos.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma série de pontos. Cada ponto na matriz é uma estrutura [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*Ncount*<br/>
O número de pontos na matriz.

*Lprect*<br/>
Aponta para uma estrutura [RECT](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect.](../../atl-mfc-shared/reference/crect-class.md) Este parâmetro é usado para o caso comum de mapear um retângulo de unidades lógicas para dispositivos.

*lpTamanho*<br/>
Aponta para uma estrutura [SIZE](/windows/win32/api/windef/ns-windef-size) ou um objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Comentários

A função mapeia as coordenadas de cada ponto, ou dimensões de um tamanho, do sistema de coordenadas lógicas do GDI em um sistema de coordenadas de dispositivos. A conversão depende do modo de mapeamento atual e das configurações das origens e extensões da janela e do viewport do dispositivo.

As coordenadas x e y de pontos são inteiros assinados por 2 bytes na faixa -32.768 a 32.767. Nos casos em que o modo de mapeamento resultaria em valores maiores que esses limites, o sistema define os valores como -32.768 e 32.767, respectivamente.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtoHIMETRIC

Chame esta função para converter unidades lógicas em unidades HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpTamanho*<br/>
Aponta para `SIZE` uma `CSize` estrutura ou um objeto.

### <a name="remarks"></a>Comentários

Use esta função quando você der tamanhos HIMETRIC para OLE, convertendo-se do modo de mapeamento natural do seu aplicativo. Observe que a extensão da janela e da porta de exibição do dispositivo afetará o resultado.

A conversão é realizada primeiro convertendo as unidades lógicas em pixels usando as unidades de mapeamento atuais do contexto do dispositivo e, em seguida, convertendo essas unidades em unidades HIMETRIC.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

O contexto do `CDC` dispositivo de atributo para este objeto.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Comentários

Por padrão, este contexto `m_hDC`do dispositivo é igual a . Em geral, `CDC` as chamadas GDI que solicitam `m_hAttribDC`informações do contexto do dispositivo são direcionadas para . Consulte a descrição da classe [CDC](../../mfc/reference/cdc-class.md) para obter mais informações sobre o uso desses dois contextos de dispositivo.

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

O contexto do `CDC` dispositivo de saída para este objeto.

```
HDC m_hDC;
```

### <a name="remarks"></a>Comentários

Por padrão, `m_hDC` é `m_hAttribDC`igual a , `CDC`o outro contexto do dispositivo embrulhado por . Em geral, `CDC` as chamadas GDI `m_hDC` que criam saída vão para o contexto do dispositivo. Você pode `m_hDC` inicializar e `m_hAttribDC` apontar para diferentes dispositivos. Consulte a descrição da classe [CDC](../../mfc/reference/cdc-class.md) para obter mais informações sobre o uso desses dois contextos de dispositivo.

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::MaskBlt

Combina os dados de cores para os bitmaps de origem e destino usando a determinada operação de máscara e raster.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo de destino.

*Y*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo de destino.

*Nwidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino e do bitmap de origem.

*Nheight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino e do bitmap de origem.

*pSrcDC*<br/>
Identifica o contexto do dispositivo a partir do qual o bitmap deve ser copiado. Deve ser zero se o parâmetro *dwRop* especificar uma operação de rasterques que não inclua uma fonte.

*xSrc*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do bitmap de origem.

*ySrc*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do bitmap de origem.

*Maskbitmap*<br/>
Identifica o bitmap de máscara monocromática combinado com o bitmap de cores no contexto do dispositivo de origem.

*xMask*<br/>
Especifica o deslocamento horizontal de pixels para o bitmap da máscara especificado pelo parâmetro *maskBitmap.*

*yMask*<br/>
Especifica o deslocamento de pixel vertical para o bitmap da máscara especificado pelo parâmetro *maskBitmap.*

*{1&amp;gt;dwRop&amp;lt;1}*<br/>
Especifica códigos de operação de rasterdes de primeiro plano e de fundo, que a função usa para controlar a combinação de dados de origem e destino. O código de operação de raster de fundo é armazenado no alto byte da palavra alta deste valor; o código de operação de raster em primeiro plano é armazenado no byte baixo da palavra alta deste valor; a palavra baixa deste valor é ignorada, e deve ser zero. A macro MAKEROP4 cria essas combinações de códigos de operação de rasterdes em primeiro plano e em segundo plano. Consulte a seção Observações para uma discussão de primeiro plano e fundo no contexto desta função. Consulte `BitBlt` a função membro para obter uma lista de códigos comuns de operação de raster.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um valor de 1 na máscara especificado pela *máscaraBitmap* indica que o código de operação de rasteres em primeiro plano especificado por *dwRop* deve ser aplicado nesse local. Um valor de 0 na máscara indica que o código de operação de raster de fundo especificado por *dwRop* deve ser aplicado nesse local. Se as operações de raster exigirem uma fonte, o retângulo da máscara deve cobrir o retângulo da fonte. Se isso não acontecer, a função falhará. Se as operações de raster não exigirem uma fonte, o retângulo da máscara deve cobrir o retângulo de destino. Se isso não acontecer, a função falhará.

Se uma transformação de rotação ou cisalhamento estiver em vigor para o contexto do dispositivo de origem quando essa função é chamada, um erro ocorrerá. No entanto, outros tipos de transformações são permitidas.

Se os formatos de cores dos bitmaps de origem, padrão e destino diferem, essa função converte o padrão ou formato de origem, ou ambos, para corresponder ao formato de destino. Se o bitmap da máscara não for um bitmap monocromático, um erro ocorrerá. Quando um metaarquivo aprimorado está sendo gravado, um erro ocorre (e a função retorna 0) se o contexto do dispositivo de origem identificar um contexto de dispositivo de metaarquivos aprimorado. Nem todos os `MaskBlt`dispositivos suportam . Um aplicativo `GetDeviceCaps` deve ligar para determinar se um dispositivo suporta essa função. Se nenhum bitmap da máscara for fornecido, `BitBlt`esta função se comporta exatamente como , usando o código de operação do raster em primeiro plano. Os pixels são deslocados no mapa bitmap da máscara até o ponto (0,0) no bitmap do contexto do dispositivo de origem. Isso é útil para casos em que um bitmap de máscara contém um conjunto de máscaras; um aplicativo pode facilmente aplicar qualquer um deles a uma tarefa de relocação de máscaras, ajustando os deslocamentos de pixels e os tamanhos de retângulo enviados para `MaskBlt`.

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::ModifyWorldTransform

Altera a transformação do mundo para um contexto de dispositivo usando o modo especificado.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a uma estrutura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) usada para modificar a transformação mundial para o determinado contexto do dispositivo.

*Imode*<br/>
Especifica como os dados de transformação modificam a transformação do mundo atual. Para obter uma lista dos valores que este parâmetro pode levar, consulte [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valor retornado

Devolve um valor não zero no sucesso.

Retorna 0 em falha.

Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Este método envolve a função Do Windows GDI [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::MoveTo

Move a posição atual para o ponto especificado por *x* e *y* (ou por *ponto*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da nova posição.

*Y*<br/>
Especifica a coordenada lógica y da nova posição.

*Ponto*<br/>
Especifica a nova posição. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

As coordenadas x e y da posição `CPoint` anterior como objeto.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::OffsetClipRgn

Move a região de recorte do contexto do dispositivo pelas compensações especificadas.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica o número de unidades lógicas para mover-se para a esquerda ou para a direita.

*Y*<br/>
Especifica o número de unidades lógicas para mover para cima ou para baixo.

*Tamanho*<br/>
Especifica o valor a ser compensado.

### <a name="return-value"></a>Valor retornado

O tipo da nova região. Pode ser qualquer um dos seguintes valores:

- REGIÃO COMPLEXA A região de recorte tem fronteiras sobrepostas.

- ERRO O contexto do dispositivo não é válido.

- NULLREGION A região de recorte está vazia.

- REGIÃO SIMPLESRegião A região de recorte não tem fronteiras sobrepostas.

### <a name="remarks"></a>Comentários

A função move as unidades da região *x* ao longo do eixo x e *unidades y* ao longo do eixo y.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC::OffsetViewportOrg

Modifica as coordenadas da origem do viewport em relação às coordenadas da origem atual do viewport.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*Nwidth*<br/>
Especifica o número de unidades do dispositivo para adicionar à coordenada x da origem atual.

*Nheight*<br/>
Especifica o número de unidades do dispositivo para adicionar à coordenada y da origem atual.

### <a name="return-value"></a>Valor retornado

A origem anterior do viewport (em `CPoint` coordenadas do dispositivo) como um objeto.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::OffsetWindowOrg

Modifica as coordenadas da origem da janela em relação às coordenadas da origem da janela atual.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*Nwidth*<br/>
Especifica o número de unidades lógicas para adicionar à coordenada x da origem atual.

*Nheight*<br/>
Especifica o número de unidades lógicas para adicionar à coordenada y da origem atual.

### <a name="return-value"></a>Valor retornado

A origem da janela anterior (em `CPoint` coordenadas lógicas) como um objeto.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC::operador HDC

Use este operador para recuperar a `CDC` alça de contexto do dispositivo do objeto.

```
operator HDC() const;
```

### <a name="return-value"></a>Valor retornado

Se for bem-sucedido, a alça do objeto de contexto do dispositivo; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Você pode usar a alça para chamar apis do Windows diretamente.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

Preenche a região especificada por *pRgn* usando o pincel atual.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parâmetros

*Prgn*<br/>
Identifica a região a ser preenchida. As coordenadas para a determinada região são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::PatBlt

Cria um pouco de padrão no dispositivo.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo que deve receber o padrão.

*Y*<br/>
Especifica a coordenada lógica y do canto superior esquerdo do retângulo que deve receber o padrão.

*Nwidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo que deve receber o padrão.

*Nheight*<br/>
Especifica a altura (em unidades lógicas) do retângulo que deve receber o padrão.

*{1&amp;gt;dwRop&amp;lt;1}*<br/>
Especifica o código de operação de raster. Os rops (Raster-operation codes, códigos de operação de raster) definem como o GDI combina cores em operações de saída que envolvem um pincel atual, um possível bitmap de origem e um bitmap de destino. Este parâmetro pode ser um dos seguintes valores:

- Patcopy Copia padrão para bitmap de destino.

- PATINVERT Combina bitmap de destino com padrão usando o operador Boolean XOR.

- DSTINVERT Inverte o bitmap de destino.

- BLACKNESS Torna toda a saída preta.

- BRANCURA Torna toda a saída branca.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O padrão é uma combinação do pincel selecionado e do padrão já no dispositivo. O código de operação de rasterespecificado pelo *dwRop* define como os padrões devem ser combinados. As operações de rasterlistadas para esta função são um subconjunto limitado dos 256 códigos completos de operação de rasterde saqueador; em particular, um código de operação rasterqueque que se refere a uma fonte não pode ser usado.

Nem todos os contextos do dispositivo suportam a `PatBlt` função. Para determinar se um `PatBlt`contexto do `GetDeviceCaps` dispositivo é suportado, ligue para a função do membro com o índice RASTERCAPS e verifique o valor de retorno do sinalizador RC_BITBLT.

## <a name="cdcpie"></a><a name="pie"></a>CDC::Pie

Desenha uma cunha em forma de torta desenhando um arco elíptico cujo centro e dois pontos finais são unidos por linhas.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*y3*<br/>
Especifica a coordenada y do ponto de partida do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*x4*<br/>
Especifica a coordenada x do ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*y4*<br/>
Especifica a coordenada y do ponto final do arco (em unidades lógicas). Este ponto não tem que mentir exatamente sobre o arco.

*Lprect*<br/>
Especifica o retângulo delimitador. Você pode passar `CRect` um objeto ou `RECT` um ponteiro para uma estrutura para este parâmetro.

*ptStart*<br/>
Especifica o ponto de partida do arco. Este ponto não tem que mentir exatamente sobre o arco. Você pode passar uma estrutura [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parâmetro.

*ptEnd*<br/>
Especifica o ponto final do arco. Este ponto não tem que mentir exatamente sobre o arco. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O centro do arco é o centro do retângulo delimitador especificado por *x1*, *y1*, *x2*e *y2* (ou por *lpRect*). Os pontos de partida e final do arco são especificados por *x3*, *y3*, *x4*e *y4* (ou por *ptStart* e *ptEnd*).

O arco é desenhado com a caneta selecionada, movendo-se no sentido anti-horário. Duas linhas adicionais são desenhadas de cada ponto final para o centro do arco. A área em forma de torta é preenchida com o pincel atual. Se *x3* é igual *a x4* e *y3* é igual *a y4*, o resultado é uma elipse com uma única linha do centro da elipse até o ponto *(x3*, *y3*) ou *(x4,* *y4*).

A figura desenhada por esta função estende-se até, mas não inclui as coordenadas direita e inferior. Isso significa que a altura da figura é *y2* - *y1* e a largura da figura é *x2* - *x1*. Tanto a largura quanto a altura do retângulo delimitador devem ser superiores a 2 unidades e inferiores a 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::PlayMetaFile

Reproduz o conteúdo do metaarquivo especificado no contexto do dispositivo.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parâmetros

*Hmf*<br/>
Identifica o metaarquivo a ser reproduzido.

*hEnhMetaFile*<br/>
Identifica o metaarquivo aprimorado.

*Lpbounds*<br/>
Aponta para `RECT` uma `CRect` estrutura ou um objeto que contém as coordenadas do retângulo delimitador usado para exibir a imagem. As coordenadas são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O metaarquivo pode ser reproduzido várias vezes.

A segunda `PlayMetaFile` versão exibe a imagem armazenada no metaarquivo de formato aprimorado dado. Quando um aplicativo chama `PlayMetaFile`a segunda versão de , O Windows usa o quadro de imagem no cabeçalho de metaarquivo aprimorado para mapear a imagem no retângulo apontado pelo parâmetro *lpBounds.* (Esta imagem pode ser regravada ou girada definindo a `PlayMetaFile`transformação do mundo no dispositivo de saída antes de chamar .) Pontos ao longo das bordas do retângulo estão incluídos na imagem. Uma imagem de metaarquivo aprimorado pode ser cortada definindo a região de recorte no dispositivo de saída antes de reproduzir o metaarquivo aprimorado.

Se um metaarquivo aprimorado contiver uma paleta opcional, um aplicativo pode obter cores consistentes configurando uma paleta de cores no dispositivo de saída antes de chamar a segunda versão de `PlayMetaFile`. Para recuperar a paleta `GetEnhMetaFilePaletteEntries` opcional, use a função Windows. Um metaarquivo aprimorado pode ser incorporado em um metaarquivo aprimorado recém-criado chamando a segunda versão e reproduzindo o metaarquivo aprimorado de `PlayMetaFile` origem no contexto do dispositivo para o novo metaarquivo aprimorado.

Os estados do contexto do dispositivo de saída são preservados por esta função. Qualquer objeto criado, mas não excluído no metaarquivo aprimorado, é excluído por esta função. Para interromper essa função, um `CancelDC` aplicativo pode chamar a função Windows de outro segmento para encerrar a operação. Neste caso, a função retorna zero.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

Executa uma transferência de bloco de bits dos bits de dados de cor do retângulo especificado no contexto do dispositivo de origem para o paralelograma especificado no contexto do dispositivo.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parâmetros

*Lppoint*<br/>
Aponta para uma matriz de três pontos no espaço lógico que identifica três cantos do paralelograma de destino. O canto superior esquerdo do retângulo de origem é mapeado para o primeiro ponto nesta matriz, o canto superior direito para o segundo ponto nesta matriz, e o canto inferior esquerdo para o terceiro ponto. O canto inferior direito do retângulo de origem é mapeado para o quarto ponto implícito no paralelograma.

*pSrcDC*<br/>
Identifica o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*Nwidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*Nheight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*Maskbitmap*<br/>
Identifica um bitmap monocromático opcional que é usado para mascarar as cores do retângulo de origem.

*xMask*<br/>
Especifica a coordenada x do canto superior esquerdo do bitmap monocromático.

*yMask*<br/>
Especifica a coordenada y do canto superior esquerdo do bitmap monocromático.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se a alça damáscara de bits dado identificar um bitmap monocromático válido, a função usará este bitmap para mascarar os bits de dados de cor do retângulo de origem.

O quarto vértice do paralelograma (D) é definido tratando os primeiros três pontos (A, B e C) como vetores e computação D = B + C - A.

Se a máscara de bits existir, um valor de 1 na máscara indica que a cor do pixel de origem deve ser copiada para o destino. Um valor de 0 na máscara indica que a cor do pixel de destino não deve ser alterada.

Se o retângulo da máscara for menor do que os retângulos de origem e destino, a função replica o padrão da máscara.

Transformações de dimensionamento, tradução e reflexão são permitidas no contexto do dispositivo de origem; no entanto, transformações de rotação e cisalhamento não são. Se o bitmap da máscara não for um bitmap monocromático, um erro ocorrerá. O modo de alongamento para o contexto do dispositivo de destino é usado para determinar como esticar ou comprimir os pixels, se necessário. Quando um metaarquivo aprimorado está sendo gravado, um erro ocorre se o contexto do dispositivo de origem identificar um contexto de dispositivo de metaarquivo aprimorado.

As coordenadas de destino são transformadas de acordo com o contexto do dispositivo de destino; as coordenadas de origem são transformadas de acordo com o contexto do dispositivo de origem. Se a transformação de origem tiver uma rotação ou cisalhamento, um erro será retornado. Se os retângulos de destino e origem `PlgBlt` não tiverem o mesmo formato de cor, converta o retângulo de origem para corresponder ao retângulo de destino. Nem todos os `PlgBlt`dispositivos suportam . Para obter mais informações, consulte a descrição da `CDC::GetDeviceCaps` capacidade de raster RC_BITBLT na função membro.

Se os contextos do dispositivo de origem `PlgBlt` e destino representarem dispositivos incompatíveis, retorne um erro.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::PolyBezier

Desenha uma ou mais linhas bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para um conjunto de estruturas de dados [POINT](/windows/win32/api/windef/ns-windef-point) que contêm os pontos finais e os pontos de controle do spline(s).

*Ncount*<br/>
Especifica o número de pontos na matriz *lpPoints.* Este valor deve ser mais de três vezes o número de splines a serem sorteados, porque cada linha bzier requer dois pontos de controle e um ponto final, e o spline inicial requer um ponto de partida adicional.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função desenha linhas bzier cúbicas usando os pontos finais e pontos de controle especificados pelo parâmetro *lpPoints.* O primeiro spline é desenhado do primeiro ponto para o quarto ponto usando o segundo e o terceiro pontos como pontos de controle. Cada spline subseqüente na sequência precisa exatamente mais três pontos: o ponto final do spline anterior é usado como ponto de partida, os próximos dois pontos na sequência são pontos de controle, e o terceiro é o ponto final.

A posição atual não é `PolyBezier` usada nem atualizada pela função. A figura não está preenchida. Esta função desenha linhas usando a caneta atual.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::PolyBezierTo

Desenha uma ou mais linhas bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma matriz de estruturas de dados [POINT](/windows/win32/api/windef/ns-windef-point) que contém os pontos finais e os pontos de controle.

*Ncount*<br/>
Especifica o número de pontos na matriz *lpPoints.* Este valor deve ser três vezes o número de linhas a serem sorteadas, porque cada linha bzier requer dois pontos de controle e um ponto final.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função desenha linhas bzier cúbicas usando os pontos de controle especificados pelo parâmetro *lpPoints.* O primeiro spline é puxado da posição atual para o terceiro ponto usando os dois primeiros pontos como pontos de controle. Para cada spline subseqüente, a função precisa exatamente de mais três pontos, e usa o ponto final do spline anterior como ponto de partida para o próximo. `PolyBezierTo`move a posição atual para o ponto final da última linha bzier. A figura não está preenchida. Esta função desenha linhas usando a caneta atual.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::PolyDraw

Desenha um conjunto de segmentos de linha e linhas bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para um conjunto de estruturas de dados [POINT](/windows/win32/api/windef/ns-windef-point) que contém os pontos finais para cada segmento de linha e os pontos finais e pontos de controle para cada spline Bzier.

*lpTypes*<br/>
Aponta para uma matriz que especifica como cada ponto na matriz *lpPoints* é usado. Pode conter um dos seguintes valores:

- PT_MOVETO Especifica que este ponto inicia uma figura desarticulada. Este ponto se torna a nova posição atual.

- PT_LINETO Especifica que uma linha deve ser desenhada da posição atual até este ponto, que se torna então a nova posição atual.

- PT_BEZIERTO Especifica que este ponto é um ponto de controle ou ponto final para uma linha bzier.

PT_BEZIERTO tipos sempre ocorrem em conjuntos de três. A posição atual define o ponto de partida para o spline bzier. Os dois primeiros PT_BEZIERTO pontos são os pontos de controle, e o terceiro ponto PT_BEZIERTO é o ponto final. O ponto final torna-se a nova posição atual. Se não houver três pontos de PT_BEZIERTO consecutivos, um erro resulta.

   Um PT_LINETO ou PT_BEZIERTO tipo pode ser combinado com a seguinte constante usando o operador bitwise OR para indicar que o ponto correspondente é o último ponto de uma figura e a figura está fechada:

- PT_CLOSEFIGURE Especifica que a figura é automaticamente fechada após a PT_LINETO ou PT_BEZIERTO tipo para este ponto ser feito. Uma linha é traçada deste ponto `MoveTo` até o mais recente PT_MOVETO ou ponto.

   Esta bandeira é combinada com o tipo PT_LINETO para uma linha, ou com o PT_BEZIERTO tipo de ponto final para uma linha bzier, usando o operador **bitwise OR.** A posição atual está definida para o ponto final da linha de fechamento.

*Ncount*<br/>
Especifica o número total de pontos na matriz *lpPoints,* o mesmo que o número de bytes na matriz *lpTypes.*

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função pode ser usada para desenhar figuras desarticuladas no lugar de chamadas consecutivas para `CDC::MoveTo`, `CDC::LineTo`e `CDC::PolyBezierTo` funções de membro. As linhas e linhas são desenhadas usando a caneta atual, e os valores não são preenchidos. Se houver um caminho ativo `CDC::BeginPath` iniciado chamando a função membro, `PolyDraw` adicione ao caminho. Os pontos contidos na matriz *lpPoints* e em *lpTypes* indicam `CDC::LineTo`se `CDC::BezierTo` cada ponto faz parte de uma `CDC::MoveTo`, a , ou uma operação. Também é possível fechar números. Esta função atualiza a posição atual.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Polygon

Desenha um polígono composto por dois ou mais pontos (vértices) conectados por linhas, usando a caneta atual.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma matriz de pontos que especifica os vértices do polígono. Cada ponto na matriz `POINT` é `CPoint` uma estrutura ou um objeto.

*Ncount*<br/>
Especifica o número de vértices na matriz.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O sistema fecha o polígono automaticamente, se necessário, desenhando uma linha do último vértice para o primeiro.

O modo de enchimento do polígono `GetPolyFillMode` atual `SetPolyFillMode` pode ser recuperado ou definido usando as funções e membros.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Polyline

Desenha um conjunto de segmentos de linha que conectam os pontos especificados por *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma `POINT` matriz `CPoint` de estruturas ou objetos a serem conectados.

*Ncount*<br/>
Especifica o número de pontos na matriz. Este valor deve ser de pelo menos 2.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As linhas são desenhadas desde o primeiro ponto até os pontos subseqüentes usando a caneta atual. Ao `LineTo` contrário da `Polyline` função de membro, a função não usa nem atualiza a posição atual.

Para obter mais informações, consulte [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) no Windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::PolylineTo

Desenha uma ou mais linhas retas.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para um conjunto de estruturas de dados [POINT](/windows/win32/api/windef/ns-windef-point) que contém os vértices da linha.

*Ncount*<br/>
Especifica o número de pontos na matriz.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Uma linha é desenhada da posição atual para o primeiro ponto especificado pelo parâmetro *lpPoints* usando a caneta atual. Para cada linha adicional, a função retira do ponto final da linha anterior para o próximo ponto especificado por *lpPoints*. `PolylineTo`move a posição atual para o ponto final da última linha. Se os segmentos de linha desenhados por esta função formarem uma figura fechada, a figura não será preenchida.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::PolyPolygon

Cria dois ou mais polígonos que são preenchidos usando o modo de enchimento do polígono atual.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma `POINT` matriz `CPoint` de estruturas ou objetos que definem os vértices dos polígonos.

*lpPolyCounts*<br/>
Aponta para uma matriz de inteiros, cada um dos quais especifica o número de pontos em um dos polígonos na matriz *lpPoints.*

*Ncount*<br/>
O número de entradas na matriz *lpPolyCounts.* Este número especifica o número de polígonos a serem sorteados. Este valor deve ser de pelo menos 2.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os polígonos podem ser desarticulados ou sobrepostos.

Cada polígono especificado em `PolyPolygon` uma chamada para a função deve ser fechado. Ao contrário dos polígonos criados pela função do `Polygon` `PolyPolygon` membro, os polígonos criados por não são fechados automaticamente.

A função cria dois ou mais polígonos. Para criar um único polígono, `Polygon` um aplicativo deve usar a função do membro.

O modo de enchimento do polígono `GetPolyFillMode` atual `SetPolyFillMode` pode ser recuperado ou definido usando as funções e membros.

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::PolyPoliline

Desenha várias séries de segmentos de linha conectada.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*Lppoints*<br/>
Aponta para uma matriz de estruturas que contém os vértices das polilinhas. As polilinhas são especificadas consecutivamente.

*lpPolyPoints*<br/>
Aponta para uma matriz de variáveis especificando o número de pontos na matriz *lpPoints* para o polígono correspondente. Cada entrada deve ser maior ou igual a 2.

*Ncount*<br/>
Especifica o número total de contagens na matriz *lpPolyPoints.*

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os segmentos de linha são desenhados usando a caneta atual. As figuras formadas pelos segmentos não estão preenchidas. A posição atual não é usada nem atualizada por esta função.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::PtVisible

Determina se o ponto dado está dentro da região de recorte do contexto do dispositivo.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto.

*Y*<br/>
Especifica a coordenada lógica y do ponto.

*Ponto*<br/>
Especifica o ponto para verificar as coordenadas lógicas. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Não zero se o ponto especificado estiver dentro da região de recorte; caso contrário, 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::QueryAbort

Chama a função abortar instalada pela função [membro SetAbortProc](#setabortproc) para um aplicativo de impressão e consulta se a impressão deve ser encerrada.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valor retornado

O valor de devolução não é zero se a impressão continuar ou se não houver procedimento de abortamento. É 0 se o trabalho de impressão deve ser encerrado. O valor de retorno é fornecido pela função abortar.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::RealizePalette

Mapeia entradas da paleta lógica atual para a paleta do sistema.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valor retornado

Indica quantas entradas na paleta lógica foram mapeadas para diferentes entradas na paleta do sistema. Isso representa o número de entradas que esta função remapeou para acomodar alterações na paleta do sistema desde que a paleta lógica foi realizada pela última vez.

### <a name="remarks"></a>Comentários

Uma paleta de cores lógica atua como um buffer entre aplicações de color-intensivo e o sistema, permitindo que um aplicativo use quantas cores necessários sem interferir com suas próprias cores exibidas ou com cores exibidas por outras janelas.

Quando uma janela tem o `RealizePalette`foco de entrada e chamadas, o Windows garante que a janela exibirá todas as cores solicitadas, até o número máximo disponível simultaneamente na tela. O Windows também exibe cores não encontradas na paleta da janela, combinando-as com as cores disponíveis.

Além disso, o Windows corresponde às cores solicitadas por janelas inativas que chamam a função o mais próximo possível das cores disponíveis. Isso reduz significativamente as alterações indesejáveis nas cores exibidas nas janelas inativas.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::Retângulo

Desenha um retângulo usando a caneta atual.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo (em unidades lógicas).

*Lprect*<br/>
Especifica o retângulo em unidades lógicas. Você pode passar `CRect` um objeto ou `RECT` um ponteiro para uma estrutura para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O interior do retângulo é preenchido usando o pincel atual.

O retângulo se estende até, mas não inclui, as coordenadas direita e inferior. Isso significa que a altura do retângulo é *y2* - *y1* e a largura do retângulo é *x2* - *x1*. Tanto a largura quanto a altura de um retângulo devem ser maiores que 2 unidades e menos de 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::RectVisible

Determina se qualquer parte do retângulo dado está dentro da região de recorte do contexto de exibição.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parâmetros

*Lprect*<br/>
Aponta para `RECT` uma `CRect` estrutura ou um objeto que contém as coordenadas lógicas do retângulo especificado.

### <a name="return-value"></a>Valor retornado

Não zero se qualquer parte do retângulo dado estiver dentro da região de recorte; caso contrário, 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::ReleaseAttribDC

Ligue para esta `m_hAttribDC` função de membro para definir como NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Comentários

Isso não faz `Detach` com que ocorra. Apenas o contexto do dispositivo `CDC` de saída é anexado ao objeto, e só ele pode ser destacado.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::ReleaseOutputDC

Chame esta função de `m_hDC` membro para definir o membro como NULA.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Comentários

Esta função de membro não pode ser chamada `CDC` quando o contexto do dispositivo de saída estiver conectado ao objeto. Use `Detach` a função de membro para desvincular o contexto do dispositivo de saída.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC::ResetDC

Ligue para esta função de membro `CDC` para atualizar o contexto do dispositivo embrulhado pelo objeto.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parâmetros

*lpDevMode*<br/>
Um ponteiro para `DEVMODE` uma estrutura do Windows.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo é atualizado a `DEVMODE` partir das informações especificadas na estrutura do Windows. Esta função de membro apenas redefine o contexto do dispositivo de atributo.

Um aplicativo normalmente `ResetDC` usará a função membro `WM_DEVMODECHANGE` quando uma janela processa uma mensagem. Você também pode usar esta função de membro para alterar a orientação de papel ou as caixas de papel durante a impressão de um documento.

Não é possível usar esta função de membro para alterar o nome do driver, o nome do dispositivo ou a porta de saída. Quando o usuário altera a conexão da porta ou o nome do dispositivo, você deve excluir o contexto original do dispositivo e criar um novo contexto do dispositivo com as novas informações.

Antes de chamar essa função de membro, você deve garantir que todos os objetos (que não os objetos de estoque) que foram selecionados no contexto do dispositivo tenham sido selecionados.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::RestoreDC

Restaura o contexto do dispositivo ao estado anterior identificado por *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parâmetros

*Nsaveddc*<br/>
Especifica o contexto do dispositivo a ser restaurado. Pode ser um valor retornado `SaveDC` por uma chamada de função anterior. Se *nSavedDC* for -1, o contexto do dispositivo salvo mais recentemente será restaurado.

### <a name="return-value"></a>Valor retornado

Não zero se o contexto especificado for restaurado; caso contrário, 0.

### <a name="remarks"></a>Comentários

`RestoreDC`restaura o contexto do dispositivo, retirando informações de estado `SaveDC` de uma pilha criada por chamadas anteriores para a função de membro.

A pilha pode conter as informações do estado para vários contextos do dispositivo. Se o contexto especificado por *nSavedDC* não estiver `RestoreDC` na parte superior da pilha, excluirá todas as informações de estado entre o contexto do dispositivo especificado por *nSavedDC* e a parte superior da pilha. As informações excluídas são perdidas.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::RoundRect

Desenha um retângulo com cantos arredondados usando a caneta atual.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo (em unidades lógicas).

*x3*<br/>
Especifica a largura da elipse usada para desenhar os cantos arredondados (em unidades lógicas).

*y3*<br/>
Especifica a altura da elipse usada para desenhar os cantos arredondados (em unidades lógicas).

*Lprect*<br/>
Especifica o retângulo delimitador em unidades lógicas. Você pode passar `CRect` um objeto ou `RECT` um ponteiro para uma estrutura para este parâmetro.

*Ponto*<br/>
A coordenada x do *ponto* especifica a largura da elipse para desenhar os cantos arredondados (em unidades lógicas). A coordenada y do *ponto* especifica a altura da elipse para desenhar os cantos arredondados (em unidades lógicas). Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O interior do retângulo é preenchido usando o pincel atual.

A figura que esta função desenha estende-se até, mas não inclui as coordenadas direita e inferior. Isso significa que a altura da figura é *y2* - *y1* e a largura da figura é *x2* - *x1*. Tanto a altura quanto a largura do retângulo delimitador devem ser superiores a 2 unidades e inferiores a 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::SaveDC

Salva o estado atual do contexto do dispositivo copiando informações do estado (como região de recorte, objetos selecionados e modo de mapeamento) para uma pilha de contexto mantida pelo Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valor retornado

Um inteiro identificando o contexto do dispositivo salvo. É 0 se ocorrer um erro. Esse valor de retorno pode ser usado `RestoreDC`para restaurar o contexto do dispositivo chamando .

### <a name="remarks"></a>Comentários

O contexto do dispositivo salvo `RestoreDC`pode ser restaurado posteriormente usando .

`SaveDC`pode ser usado várias vezes para salvar qualquer número de estados de contexto de dispositivo.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC::ScaleViewportExt

Modifica as extensões de viewport em relação aos valores atuais.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parâmetros

*xNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão x atual.

*xDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão x atual pelo valor do parâmetro *xNum.*

*yNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão y atual.

*yDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão atual y pelo valor do parâmetro *yNum.*

### <a name="return-value"></a>Valor retornado

As extensões de porta de visualização `CSize` anteriores (em unidades de dispositivos) como um objeto.

### <a name="remarks"></a>Comentários

As fórmulas são escritas da seguinte forma:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

As novas extensões de viewport são calculadas multiplicando as extensões atuais pelo numerador dado e, em seguida, dividindo-se pelo denominador dado.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::ScaleWindowExt

Modifica as extensões da janela em relação aos valores atuais.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parâmetros

*xNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão x atual.

*xDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão x atual pelo valor do parâmetro *xNum.*

*yNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão y atual.

*yDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão atual y pelo valor do parâmetro *yNum.*

### <a name="return-value"></a>Valor retornado

As extensões de janela anteriores `CSize` (em unidades lógicas) como um objeto.

### <a name="remarks"></a>Comentários

As fórmulas são escritas da seguinte forma:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

As novas extensões de janela são calculadas multiplicando as extensões atuais pelo numerador dado e, em seguida, dividindo-se pelo denominador dado.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::ScrollDC

Rola um retângulo de bits horizontal e verticalmente.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parâmetros

*Dx*<br/>
Especifica o número de unidades de rolagem horizontal.

*Dy*<br/>
Especifica o número de unidades de rolagem vertical.

*Lprectscroll*<br/>
Aponta para `RECT` a `CRect` estrutura ou objeto que contém as coordenadas do retângulo de rolagem.

*lpRectClip*<br/>
Aponta para `RECT` a `CRect` estrutura ou objeto que contém as coordenadas do retângulo de recorte. Quando este retângulo é menor do que o original apontado por *lpRectScroll,* a rolagem ocorre apenas no retângulo menor.

*Prgnupdate*<br/>
Identifica a região descoberta pelo processo de rolagem. A `ScrollDC` função define essa região; não é necessariamente um retângulo.

*Lprectupdate*<br/>
Aponta para `RECT` a `CRect` estrutura ou objeto que recebe as coordenadas do retângulo que limita a região de atualização de rolagem. Esta é a maior área retangular que requer repintura. Os valores na estrutura ou objeto quando a função retorna estão nas coordenadas do cliente, independentemente do modo de mapeamento para o determinado contexto do dispositivo.

### <a name="return-value"></a>Valor retornado

Não zero se a rolagem for executada; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se *lpRectUpdate* for NULL, o Windows não calculará o retângulo de atualização. Se tanto *pRgnUpdate* quanto *lpRectUpdate* forem NULL, o Windows não calculará a região de atualização. Se *pRgnUpdate* não for NULL, o `ScrollDC` Windows assumirá que ele contém um ponteiro válido para a região descoberta pelo processo de rolagem (definido pela função membro). A região de atualização retornada em *lpRectUpdate* pode ser passada para `CWnd::InvalidateRgn` se necessário.

Um aplicativo deve `ScrollWindow` usar a `CWnd` função de membro da classe quando for necessário percorrer toda a área do cliente de uma janela. Caso contrário, ele `ScrollDC`deve usar .

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC::SelectClipPath

Seleciona o caminho atual como uma região de recorte para o contexto do dispositivo, combinando a nova região com qualquer região de recorte existente usando o modo especificado.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parâmetros

*nMode*<br/>
Especifica a maneira de usar o caminho. Os seguintes valores são permitidos:

- RGN_AND A nova região de recorte inclui o cruzamento (áreas sobrepostas) da região de recorte atual e o caminho atual.

- RGN_COPY A nova região de recorte é o caminho atual.

- RGN_DIFF A nova região de recorte inclui as áreas da região de recorte atual, e as da rota atual são excluídas.

- RGN_OR A nova região de recorte inclui a união (áreas combinadas) da região de recorte atual e o caminho atual.

- RGN_XOR A nova região de recorte inclui a união da região de recorte atual e o caminho atual, mas sem as áreas sobrepostas.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo identificado deve conter um caminho fechado.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC::SelectClipRgn

Seleciona a região dada como a região de recorte atual para o contexto do dispositivo.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parâmetros

*Prgn*<br/>
Identifica a região a ser selecionada.

- Para a primeira versão desta função, se esse valor for NULL, toda a área do cliente será selecionada e a saída ainda será cortada na janela.

- Para a segunda versão desta função, esta alça só pode ser NULA quando o modo RGN_COPY for especificado.

*nMode*<br/>
Especifica a operação a ser executada. Deve ser um dos seguintes valores:

- RGN_AND A nova região de recorte combina as áreas sobrepostas da região de recorte atual e a região identificada pelo *pRgn*.

- RGN_COPY A nova região de recorte é uma cópia da região identificada pelo *pRgn*. Esta funcionalidade é idêntica à primeira `SelectClipRgn`versão de . Se a região identificada pelo *pRgn* for NULL, a nova região de recorte se tornará a região de recorte padrão (uma região nula).

- RGN_DIFF A nova região de recorte combina as áreas da região de recorte atual com as áreas excluídas da região identificada pelo *pRgn*.

- RGN_OR A nova região de recorte combina a região de recorte atual e a região identificada pelo *pRgn*.

- RGN_XOR A nova região de recorte combina a região de recorte atual e a região identificada pelo *pRgn,* mas exclui quaisquer áreas sobrepostas.

### <a name="return-value"></a>Valor retornado

O tipo da região. Pode ser qualquer um dos seguintes valores:

- REGIÃO COMPLEXA Nova região de recorte tem fronteiras sobrepostas.

- ERRO O contexto ou região do dispositivo não é válido.

- NULLREGION Nova região de recorte está vazia.

- REGIÃO SIMPLES Nova região de recorte não tem fronteiras sobrepostas.

### <a name="remarks"></a>Comentários

Apenas uma cópia da região selecionada é usada. A região em si pode ser selecionada para qualquer número de outros contextos de dispositivo, ou pode ser excluída.

A função pressupõe que as coordenadas para a determinada região sejam especificadas em unidades do dispositivo. Alguns dispositivos de impressora suportam a saída de texto em uma resolução maior do que a saída gráfica, a fim de manter a precisão necessária para expressar métricas de texto. Esses dispositivos relatam unidades de dispositivos com maior resolução, ou seja, em unidades de texto. Esses dispositivos então dimensionam coordenadas para gráficos de modo que várias unidades de dispositivos relatadas mapeiem para apenas 1 unidade gráfica. Você deve sempre `SelectClipRgn` chamar a função usando unidades de texto.

Os aplicativos que devem levar o dimensionamento de objetos gráficos no GDI podem usar a saída da impressora GETSCALINGFACTOR para determinar o fator de dimensionamento. Este fator de dimensionamento afeta o recorte. Se uma região é usada para cortar gráficos, o GDI divide as coordenadas pelo fator de dimensionamento. Se a região for usada para cortar texto, o GDI não faz nenhum ajuste de escala. Um fator de dimensionamento de 1 faz com que as coordenadas sejam divididas por 2; um fator de dimensionamento de 2 faz com que as coordenadas sejam divididas por 4; e assim por diante.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC::SelectObject

Seleciona um objeto no contexto do dispositivo.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parâmetros

*pPen*<br/>
Um ponteiro para um objeto [CPen](../../mfc/reference/cpen-class.md) a ser selecionado.

*pBrush*<br/>
Um ponteiro para um objeto [CBrush](../../mfc/reference/cbrush-class.md) a ser selecionado.

*fonte p*<br/>
Um ponteiro para um objeto [CFont](../../mfc/reference/cfont-class.md) a ser selecionado.

*Pbitmap*<br/>
Um ponteiro para um objeto [CBitmap](../../mfc/reference/cbitmap-class.md) a ser selecionado.

*Prgn*<br/>
Um ponteiro para um objeto [CRgn](../../mfc/reference/crgn-class.md) a ser selecionado.

*Pobject*<br/>
Um ponteiro para um objeto [CGdiObject](../../mfc/reference/cgdiobject-class.md) a ser selecionado.

### <a name="return-value"></a>Valor retornado

Um ponteiro para o objeto sendo substituído. Este é um ponteiro para um objeto de `CGdiObject`uma `CPen`das classes derivadas, como, dependendo de qual versão da função é usada. O valor de devolução é NULO se houver um erro. Esta função pode retornar um ponteiro para um objeto temporário. Este objeto temporário só é válido durante o processamento de uma mensagem do Windows. Para obter mais informações, consulte `CGdiObject::FromHandle`.

A versão da função membro que leva um parâmetro `SelectClipRgn` de região executa a mesma tarefa que a função do membro. Seu valor de retorno pode ser qualquer um dos seguintes:

- REGIÃO COMPLEXA Nova região de recorte tem fronteiras sobrepostas.

- ERRO O contexto ou região do dispositivo não é válido.

- NULLREGION Nova região de recorte está vazia.

- REGIÃO SIMPLES Nova região de recorte não tem fronteiras sobrepostas.

### <a name="remarks"></a>Comentários

A `CDC` classe fornece cinco versões especializadas para tipos específicos de objetos GDI, incluindo canetas, pincéis, fontes, bitmaps e regiões. O objeto recém-selecionado substitui o objeto anterior do mesmo tipo. Por exemplo, se *pObject* da `SelectObject` versão geral de pontos para um objeto [CPen,](../../mfc/reference/cpen-class.md) a função substituirá a caneta atual pela caneta especificada por *pObject*.

Um aplicativo pode selecionar um bitmap apenas em contextos de dispositivos de memória e em apenas um contexto de dispositivo de memória por vez. O formato do bitmap deve ser monocromático ou compatível com o contexto do dispositivo; se não for, `SelectObject` retorna um erro.

Para o Windows 3.1 `SelectObject` e posterior, a função retorna o mesmo valor, quer seja usada em um metaarquivo ou não. Nas versões `SelectObject` anteriores do Windows, retornou um valor não zero para o sucesso e 0 para falha quando foi usado em um metaarquivo.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::SelectPaleta

Seleciona a paleta lógica especificada por *pPalette* como o objeto de paleta selecionado do contexto do dispositivo.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parâmetros

*Ppalette*<br/>
Identifica a paleta lógica a ser selecionada. Esta paleta já deve ter `CPalette` sido criada com a função de membro [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*Bforcebackground*<br/>
Especifica se a paleta lógica é forçada a ser uma paleta de fundo. Se *bForceBackground* não for zero, a paleta selecionada será sempre uma paleta de fundo, independentemente de a janela ter o foco de entrada. Se *bForceBackground* for 0 e o contexto do dispositivo estiver conectado a uma janela, a paleta lógica será uma paleta de primeiro plano quando a janela tiver o foco de entrada.

### <a name="return-value"></a>Valor retornado

Um ponteiro `CPalette` para um objeto que identifica a paleta lógica substituída pela paleta especificada por *pPalette*. É NULO se houver um erro.

### <a name="remarks"></a>Comentários

A nova paleta torna-se o objeto de paleta usado pelo GDI para controlar as cores exibidas no contexto do dispositivo e substitui a paleta anterior.

Um aplicativo pode selecionar uma paleta lógica em mais de um contexto de dispositivo. No entanto, alterações em uma paleta lógica afetarão todos os contextos do dispositivo para os quais ele é selecionado. Se um aplicativo selecionar uma paleta em mais de um contexto de dispositivo, os contextos do dispositivo devem pertencer ao mesmo dispositivo físico.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC::SelectStockObject

Seleciona um objeto [CGdiObject](../../mfc/reference/cgdiobject-class.md) que corresponde a uma das canetas de estoque, pincéis ou fontes predefinidas.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parâmetros

*nIndex*<br/>
Especifica o tipo de objeto de estoque desejado. Pode ser um dos seguintes valores:

- BLACK_BRUSH pincel Preto.

- DKGRAY_BRUSH pincel cinza escuro.

- GRAY_BRUSH pincel Gray.

- HOLLOW_BRUSH escova Hollow.

- LTGRAY_BRUSH pincel cinza claro.

- NULL_BRUSH escova Nula.

- WHITE_BRUSH pincel branco.

- BLACK_PEN caneta Black.

- NULL_PEN caneta Nula.

- WHITE_PEN caneta Branca.

- ANSI_FIXED_FONT fonte do sistema fixo ANSI.

- ANSI_VAR_FONT fonte do sistema variável ANSI.

- DEVICE_DEFAULT_FONT fonte dependente do dispositivo.

- OEM_FIXED_FONT fonte fixa dependente do OEM.

- SYSTEM_FONT a fonte do sistema. Por padrão, o Windows usa a fonte do sistema para desenhar menus, controles de caixa de diálogo e outros textos. É melhor, no entanto, não confiar em SYSTEM_FONT para obter a fonte usada por diálogos e janelas. Em vez `SystemParametersInfo` disso, use a função com o parâmetro SPI_GETNONCLIENTMETRICS para recuperar a fonte atual. `SystemParametersInfo`leva em conta o tema atual e fornece informações de fonte para legendas, menus e diálogos de mensagens.

- SYSTEM_FIXED_FONT A fonte do sistema de largura fixa usada no Windows antes da versão 3.0. Este objeto está disponível para compatibilidade com versões anteriores do Windows.

- DEFAULT_PALETTE Paleta de cores padrão. Esta paleta consiste nas 20 cores estáticas na paleta do sistema.

### <a name="return-value"></a>Valor retornado

Um ponteiro `CGdiObject` para o objeto que foi substituído se a função for bem sucedida. O objeto real apontado é um objeto [CPen,](../../mfc/reference/cpen-class.md) [CBrush](../../mfc/reference/cbrush-class.md)ou [CFont.](../../mfc/reference/cfont-class.md) Se a chamada não for bem sucedida, o valor de devolução será NULA.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::SetAbortProc

Instala o procedimento de abortagem para o trabalho de impressão.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parâmetros

*Lpfn*<br/>
Um ponteiro para a função abortar para instalar como procedimento de abortamento. Para obter mais informações sobre a função de retorno de chamada, consulte [função de retorno de chamada para CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valor retornado

Especifica o resultado `SetAbortProc` da função. Alguns dos seguintes valores são mais prováveis do que outros, mas todos são possíveis.

- SP_ERROR erro geral.

- SP_OUTOFDISK Não há espaço em disco suficiente atualmente disponível para spooling, e não haverá mais espaço disponível.

- SP_OUTOFMEMORY Não há memória suficiente disponível para spooling.

- SP_USERABORT Usuário encerrou o trabalho através do Gerenciador de Impressão.

### <a name="remarks"></a>Comentários

Se um aplicativo permitir que o trabalho de impressão seja cancelado durante o spooling, ele deve definir a função de abortar antes que o trabalho de impressão seja iniciado com a função de membro [do StartDoc.](#startdoc) O Gerenciador de impressão chama a função abortar durante o spooling para permitir que o aplicativo cancele o trabalho de impressão ou processe condições fora do espaço do disco. Se nenhuma função de abortar for definida, o trabalho de impressão falhará se não houver espaço em disco suficiente para spooling.

Observe que os recursos do Microsoft Visual C++ simplificam `SetAbortProc`a criação da função de retorno de chamada passada para . O endereço passado `EnumObjects` para a função de membro `__declspec(dllexport)` é um `__stdcall` ponteiro para uma função exportada com e com a convenção de chamada.

Você também não precisa exportar o nome da função em uma declaração **EXPORTS** no arquivo de definição de módulo do aplicativo. Em vez disso, você pode usar o modificador de função **EXPORT,** como em

**EXPORTAção DE RETORNO DE CHAMADA BOOL** AFunction **(HDC),** `int` **);**

para fazer com que o compilador emita o registro de exportação adequado para exportação por nome sem aliasing. Isso funciona para a maioria das necessidades. Para alguns casos especiais, como exportar uma função por ordinal ou aliasing a exportação, você ainda precisa usar uma declaração **EXPORTS** em um arquivo de definição de módulo.

As interfaces de registro de retorno de chamada agora são seguras para o tipo (você deve passar em um ponteiro de função que aponta para o tipo certo de função para o retorno de chamada específico).

Observe também que todas as funções de retorno de chamada devem prender as exceções do Microsoft Foundation antes de retornar ao Windows, uma vez que as exceções não podem ser lançadas através dos limites de retorno de chamada. Para obter mais informações sobre exceções, consulte o artigo [Exceções](../../mfc/exception-handling-in-mfc.md).

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC::SetArcDirection

Define a direção do desenho a ser usada para funções de arco e retângulo.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parâmetros

*nArcDirection*<br/>
Especifica a nova direção do arco. Este parâmetro pode ser um dos seguintes valores:

- AD_COUNTERCLOCKWISE Figuras desenhadas no sentido anti-horário.

- AD_CLOCKWISE figuras desenhadas no sentido horário.

### <a name="return-value"></a>Valor retornado

Especifica a direção do arco antigo, se bem sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A direção padrão é no sentido anti-horário. A `SetArcDirection` função especifica a direção na qual as seguintes funções desenham:

|Arc|Pizza|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::SetAttribDC

Chame esta função para definir `m_hAttribDC`o contexto do dispositivo de atributo, .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*Hdc*<br/>
Um contexto de dispositivo Windows.

### <a name="remarks"></a>Comentários

Esta função de membro não anexa `CDC` o contexto do dispositivo ao objeto. Apenas o contexto do dispositivo `CDC` de saída é anexado a um objeto.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::SetBkColor

Define a cor de fundo atual para a cor especificada.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*Crcolor*<br/>
Especifica a nova cor de fundo.

### <a name="return-value"></a>Valor retornado

A cor de fundo anterior como um valor de cor RGB. Se ocorrer um erro, o valor de retorno é 0x800000000.

### <a name="remarks"></a>Comentários

Se o modo de fundo for OPAQUE, o sistema usa a cor de fundo para preencher as lacunas em linhas estilizadas, as lacunas entre linhas eclodidas em pincéis e o fundo nas células de caracteres. O sistema também usa a cor de fundo ao converter bitmaps entre contextos de dispositivos monocromáticos e de cores.

Se o dispositivo não puder exibir a cor especificada, o sistema definirá a cor de fundo para a cor física mais próxima.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::SetBkMode

Define o modo de fundo.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parâmetros

*nBkMode*<br/>
Especifica o modo a ser definido. Este parâmetro pode ser um dos seguintes valores:

- O fundo opaque é preenchido com a cor de fundo atual antes que o texto, o pincel eclodido ou a caneta seja desenhada. Este é o modo de fundo padrão.

- O fundo transparente não é alterado antes do desenho.

### <a name="return-value"></a>Valor retornado

O modo de fundo anterior.

### <a name="remarks"></a>Comentários

O modo de fundo define se o sistema remove as cores de fundo existentes na superfície do desenho antes de desenhar texto, pincéis eclodidos ou qualquer estilo de caneta que não seja uma linha sólida.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::SetBoundsRect

Controla o acúmulo de informações de limitadore-retângulo para o contexto especificado do dispositivo.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parâmetros

*lpRectBounds*<br/>
Aponta para `RECT` uma `CRect` estrutura ou objeto que é usado para definir o retângulo delimitador. As dimensões do retângulo são dadas em coordenadas lógicas. Este parâmetro pode ser NULO.

*Sinalizadores*<br/>
Especifica como o novo retângulo será combinado com o retângulo acumulado. Este parâmetro pode ser uma combinação dos seguintes valores:

- DCB_ACCUMULATE Adicionar o retângulo especificado por *lpRectBounds* ao retângulo delimitador (usando uma operação retângulo-união).

- DCB_DISABLE Desligue o acúmulo de limites.

- DCB_ENABLE Ligue o acúmulo de limites. (A configuração padrão para acumulação de limites está desativada.)

### <a name="return-value"></a>Valor retornado

O estado atual do retângulo delimitador, se a função for bem sucedida. Como *sinalizadores,* o valor de retorno pode ser uma combinação de **valores DCB_:**

- DCB_ACCUMULATE O retângulo delimitador não está vazio. Este valor será sempre definido.

- DCB_DISABLE acúmulo de Limites está cancelado.

- DCB_ENABLE acúmulo de Limites está ligado.

### <a name="remarks"></a>Comentários

As janelas podem manter um retângulo delimitador para todas as operações de desenho. Este retângulo pode ser consultado e redefinido pelo aplicativo. Os limites de desenho são úteis para invalidar caches de bitmap.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::Setbrushorg

Especifica a origem que o GDI atribuirá ao próximo pincel que o aplicativo seleciona no contexto do dispositivo.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades de dispositivo) da nova origem. Este valor deve estar na faixa 0-7.

*Y*<br/>
Especifica a coordenada y (em unidades de dispositivo) da nova origem. Este valor deve estar na faixa 0-7.

*Ponto*<br/>
Especifica as coordenadas x e y da nova origem. Cada valor deve estar na faixa 0-7. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

A origem anterior da escova em unidades do dispositivo.

### <a name="remarks"></a>Comentários

As coordenadas padrão para a origem do pincel são (0, 0). Para alterar a origem de `UnrealizeObject` um pincel, chame a função para o `CBrush` objeto, chame `SetBrushOrg`e, em seguida, chame a função do `SelectObject` membro para selecionar o pincel no contexto do dispositivo.

Não use `SetBrushOrg` com `CBrush` objetos de estoque.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::Ajuste de cores definida

Define os valores de ajuste de cor para o contexto do dispositivo usando os valores especificados.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parâmetros

*lpColorAdjust*<br/>
Aponta para uma estrutura de dados [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) contendo os valores de ajuste de cor.

### <a name="return-value"></a>Valor retornado

Não zero se bem sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os valores de ajuste de cor são usados para `CDC::StretchBlt` ajustar a cor de entrada do bitmap de origem para chamadas para a função do membro quando o modo HALFTONE estiver definido.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::SetDCBrushColor

Define a cor do pincel de contexto do dispositivo atual (DC) para o valor de cor especificado.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*Crcolor*<br/>
Especifica a nova cor do pincel.

### <a name="return-value"></a>Valor retornado

Se a função for bem-sucedida, o valor de retorno especificará a cor do pincel DC anterior como um valor COLORREF.

Se a função falhar, o valor de retorno será CLR_INVALID.

### <a name="remarks"></a>Comentários

Este método emula a funcionalidade da função [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), conforme descrito no SDK do Windows.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::SetDCPenColor

Define a cor da caneta DC (current device context) para o valor de cor especificado.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*Crcolor*<br/>
Especifica a nova cor da caneta.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função de membro utiliza a função Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), conforme descrito no SDK do Windows.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::SetGraphicsMode

Define o modo gráfico para o contexto do dispositivo especificado.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parâmetros

*Imode*<br/>
Especifica o modo gráfico. Para obter uma lista dos valores que este parâmetro pode levar, consulte [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valor retornado

Retorna o antigo modo gráfico com sucesso.

Retorna 0 em falha. Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Este método envolve a função [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)do Windows GDI .

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::SetLayout

Chame esta função de membro para alterar o layout do texto e gráficos para um contexto de dispositivo para a direita para a esquerda, o layout padrão para culturas como árabe e hebraico.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parâmetros

*dwLayout*<br/>
Layout do contexto do dispositivo e sinalizadores de controle de bitmap. Pode ser uma combinação dos seguintes valores.

|Valor|Significado|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Desativa qualquer reflexão para chamadas para [CDC::BitBlt](#bitblt) e [CDC::StretchBlt](#stretchblt).|
|Layout_rtl|Define o layout horizontal padrão para ser da direita para a esquerda.|
|LAYOUT_LTR|Define o layout padrão para ser da esquerda para a direita.|

### <a name="return-value"></a>Valor retornado

Se for bem sucedido, o layout anterior do contexto do dispositivo.

Se não tiver sucesso, GDI_ERROR. Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Normalmente, você `SetLayout` não pediria uma janela. Em vez disso, você controla o layout da direita para a esquerda em uma janela, definindo os [estilos de janela estendidos,](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) como WS_EX_RTLREADING. Um contexto de dispositivo, como uma impressora ou um metaarquivo, não herda esse layout. A única maneira de definir o contexto do dispositivo para `SetLayout`um layout da direita para a esquerda é ligando .

Se você chamar **SetLayout(LAYOUT_RTL),** `SetLayout` automaticamente mudará o modo de mapeamento para MM_ISOTROPIC. Como resultado, uma chamada subseqüente para [getMapMode](#getmapmode) retornará MM_ISOTROPIC em vez de MM_TEXT.

Em alguns casos, como com muitos bitmaps, você pode querer preservar o layout da esquerda para a direita. Nestes casos, renderize `BitBlt` a `StretchBlt`imagem chamando ou, em seguida, defina o sinalizador de controle do bitmap para *dwLayout* para LAYOUT_BITMAPORIENTATIONPRESERVED.

Uma vez que você altera o layout com a bandeira LAYOUT_RTL, as bandeiras normalmente especificando direita ou esquerda são invertidas. Para evitar confusão, você pode querer definir nomes alternativos para as bandeiras padrão. Para obter uma lista de nomes de bandeiras alternativos sugeridos, consulte [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) no SDK do Windows.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC::SetMapMode

Define o modo de mapeamento.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parâmetros

*nMapMode*<br/>
Especifica o novo modo de mapeamento. Pode ser qualquer um dos seguintes valores:

- MM_ANISOTROPIC Unidades lógicas são convertidas em unidades arbitrárias com eixos arbitrariamente dimensionados. Definir o modo de mapeamento para MM_ANISOTROPIC não altera as configurações atuais da janela ou do viewport. Para alterar as unidades, orientação e dimensionamento, ligue para as funções de membro [SetWindowExt](#setwindowext) e [SetViewportExt.](#setviewportext)

- MM_HIENGLISH Cada unidade lógica é convertida em 0,001 polegada. X positivo é para a direita; y positivo é para cima.

- MM_HIMETRIC Cada unidade lógica é convertida em 0,01 milímetros. X positivo é para a direita; y positivo é para cima.

- MM_ISOTROPIC Unidades lógicas são convertidas em unidades arbitrárias com eixos igualmente dimensionados; ou seja, 1 unidade ao longo do eixo x é igual a 1 unidade ao longo do eixo y. Use `SetWindowExt` as `SetViewportExt` funções e o membro para especificar as unidades desejadas e a orientação dos eixos. O GDI faz ajustes conforme necessário para garantir que as unidades x e y permaneçam do mesmo tamanho.

- MM_LOENGLISH Cada unidade lógica é convertida em 0,01 polegada. X positivo é para a direita; y positivo é para cima.

- MM_LOMETRIC Cada unidade lógica é convertida em 0,1 milímetro. X positivo é para a direita; y positivo é para cima.

- MM_TEXT Cada unidade lógica é convertida em 1 pixel de dispositivo. X positivo é para a direita; y positivo está para baixo.

- MM_TWIPS Cada unidade lógica é convertida em 1/20 de um ponto. (Como um ponto é de 1/72 polegadas, um twip é de 1/1440 polegadas.) X positivo é para a direita; y positivo é para cima.

### <a name="return-value"></a>Valor retornado

O modo de mapeamento anterior.

### <a name="remarks"></a>Comentários

O modo mapeamento define a unidade de medida utilizada para converter unidades lógicas em unidades de dispositivos; também define a orientação dos eixos x e y do dispositivo. O GDI usa o modo de mapeamento para converter coordenadas lógicas nas coordenadas apropriadas do dispositivo. O modo MM_TEXT permite que as aplicações funcionem em pixels do dispositivo, onde 1 unidade é igual a 1 pixel. O tamanho físico de um pixel varia de dispositivo para dispositivo.

Os modos MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC e MM_TWIPS são úteis para aplicações que devem ser sorteadas em unidades fisicamente significativas (como polegadas ou milímetros). O modo MM_ISOTROPIC garante uma proporção 1:1, o que é útil quando é importante preservar a forma exata de uma imagem. O modo MM_ANISOTROPIC permite que as coordenadas x e y sejam ajustadas independentemente.

> [!NOTE]
> Se você chamar [SetLayout](#setlayout) para alterar o DC (contexto do `SetLayout` dispositivo) para o layout da direita para a esquerda, altere automaticamente o modo de mapeamento para MM_ISOTROPIC.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::SetMapperFlags

Altera o método usado pelo mapeador de fontes quando converte uma fonte lógica em uma fonte física.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parâmetros

*Dwflag*<br/>
Especifica se o mapeador de fontes tenta corresponder a altura e largura de aspecto de uma fonte ao dispositivo. Quando esse valor é ASPECT_FILTERING, o mapeador seleciona apenas fontes cujo aspecto x e aspecto y correspondem exatamente aos do dispositivo especificado.

### <a name="return-value"></a>Valor retornado

O valor anterior do sinalizador de mapeador de fontes.

### <a name="remarks"></a>Comentários

Um aplicativo `SetMapperFlags` pode ser usado para fazer com que o mapeador de fontes tente escolher apenas uma fonte física que corresponda exatamente à proporção do dispositivo especificado.

Um aplicativo que usa apenas fontes rasteras pode usar a `SetMapperFlags` função para garantir que a fonte selecionada pelo mapeador de fontes seja atraente e legível no dispositivo especificado. Aplicativos que usam fontes escaláveis (TrueType) normalmente `SetMapperFlags`não usam .

Se nenhuma fonte física tiver uma proporção que corresponda à especificação na fonte lógica, o GDI escolherá uma nova proporção e selecionará uma fonte que corresponda a essa nova proporção.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::SetMiterLimit

Define o limite para o comprimento das adesões de miter para o contexto do dispositivo.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parâmetros

*fMiterLimit*<br/>
Especifica o novo limite de miter para o contexto do dispositivo.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O comprimento da mitra é definido como a distância da intersecção das paredes da linha no interior da junta para a intersecção das paredes da linha na parte externa da junta. O limite de mitra é a razão máxima permitida do comprimento da mitra para a largura da linha. O limite padrão de miter é 10.0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::SetOutputDC

Chame esta função de membro para `m_hDC`definir o contexto do dispositivo de saída, .

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*Hdc*<br/>
Um contexto de dispositivo Windows.

### <a name="remarks"></a>Comentários

Essa função de membro só pode ser chamada quando `CDC` um contexto do dispositivo não tiver sido anexado ao objeto. Esta função `m_hDC` de membro define, mas `CDC` não anexa o contexto do dispositivo ao objeto.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::SetPixel

Define o pixel no ponto especificado para a aproximação mais próxima da cor especificada por *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto a ser definido.

*Y*<br/>
Especifica a coordenada lógica y do ponto a ser definido.

*Crcolor*<br/>
Um valor COLORREF RGB que especifica a cor usada para pintar o ponto. Consulte [COLORREF](/windows/win32/gdi/colorref) no Windows SDK para obter uma descrição deste valor.

*Ponto*<br/>
Especifica as coordenadas lógicas x e y do ponto a ser definido. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

Um valor RGB para a cor que o ponto é realmente pintado. Este valor pode ser diferente do especificado pelo *crColor* se uma aproximação dessa cor for usada. Se a função falhar (se o ponto estiver fora da região de recorte), o valor de retorno será de -1.

### <a name="remarks"></a>Comentários

O ponto deve ser na região de recorte. Se o ponto não estiver na região de recorte, a função não faz nada.

Nem todos os dispositivos oferecem suporte à função `SetPixel`. Para determinar se um `SetPixel`dispositivo `GetDeviceCaps` é suportado, ligue para a função do membro com o índice RASTERCAPS e verifique o valor de retorno do sinalizador RC_BITBLT.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::SetPixelV

Define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x, em unidades lógicas, do ponto a ser definido.

*Y*<br/>
Especifica a coordenada y, em unidades lógicas, do ponto a ser definido.

*Crcolor*<br/>
Especifica a cor a ser usada para pintar o ponto.

*Ponto*<br/>
Especifica as coordenadas lógicas x e y do ponto a ser definido. Você pode passar uma estrutura de dados [POINT](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parâmetro.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O ponto deve estar tanto na região de recorte quanto na parte visível da superfície do dispositivo. Nem todos os dispositivos suportam a função do membro. Para obter mais informações, consulte `CDC::GetDeviceCaps` a capacidade RC_BITBLT na função membro. `SetPixelV`é mais `SetPixel` rápido do que porque não precisa devolver o valor de cor do ponto realmente pintado.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::SetPolyFillmode

Define o modo de enchimento do polígono.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parâmetros

*nPolyFillMode*<br/>
Especifica o novo modo de enchimento. Este valor pode ser ALTERNATIVO ou ENROLAMENTO. O modo padrão definido no Windows é ALTERNATE.

### <a name="return-value"></a>Valor retornado

O modo de enchimento anterior, se bem sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

Quando o modo de enchimento do polígono é ALTERNATIVO, o sistema preenche a área entre lados de polígono numerados ímpares e numerados em cada linha de varredura. Ou seja, o sistema preenche a área entre o primeiro e o segundo lado, entre o terceiro e o quarto lado, e assim por diante. Esse modo é o padrão.

Quando o modo de enchimento do polígono é WINDING, o sistema usa a direção na qual uma figura foi desenhada para determinar se deve preencher uma área. Cada segmento de linha em um polígono é desenhado no sentido horário ou no sentido anti-horário. Sempre que uma linha imaginária desenhada de uma área fechada para o exterior de uma figura passa por um segmento de linha no sentido horário, uma contagem é incrementada. Quando a linha passa por um segmento de linha no sentido anti-horário, a contagem é decretada. A área é preenchida se a contagem não for zero quando a linha atingir o exterior da figura.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::SetROP2

Define o modo de desenho atual.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parâmetros

*nDrawMode*<br/>
Especifica o novo modo de desenho. Pode ser qualquer um dos seguintes valores:

- R2_BLACK Pixel é sempre preto.

- R2_WHITE Pixel é sempre branco.

- R2_NOP Pixel permanece inalterado.

- R2_NOT Pixel é o inverso da cor da tela.

- R2_COPYPEN Pixel é a cor da caneta.

- R2_NOTCOPYPEN Pixel é o inverso da cor da caneta.

- R2_MERGEPENNOT Pixel é uma combinação da cor da caneta e do inverso da cor da tela (pixel final = (NÃO pixel de tela) OU caneta).

- R2_MASKPENNOT Pixel é uma combinação das cores comuns tanto à caneta quanto ao inverso da tela (pixel final = (NÃO pixel de tela) E caneta).

- R2_MERGENOTPEN Pixel é uma combinação da cor da tela e do inverso da cor da caneta (pixel final = (NÃO caneta) OU pixel da tela).

- R2_MASKNOTPEN Pixel é uma combinação das cores comuns tanto à tela quanto ao inverso da caneta (pixel final = (NÃO caneta) E pixel da tela).

- R2_MERGEPEN Pixel é uma combinação da cor da caneta e da cor da tela (pixel final = caneta OU pixel de tela).

- R2_NOTMERGEPEN Pixel é o inverso da cor R2_MERGEPEN (pixel final = NÃO(caneta ou pixel de tela)).

- R2_MASKPEN Pixel é uma combinação das cores comuns tanto à caneta quanto à tela (pixel final = caneta e pixel de tela).

- R2_NOTMASKPEN Pixel é o inverso da cor R2_MASKPEN (pixel final = NÃO(caneta E pixel da tela)).

- R2_XORPEN Pixel é uma combinação das cores que estão na caneta ou na tela, mas não em ambas (pixel final = caneta XOR pixel).

- R2_NOTXORPEN Pixel é o inverso da cor R2_XORPEN (pixel final = NÃO(pen XOR screen pixel)).

### <a name="return-value"></a>Valor retornado

O modo de desenho anterior.

Pode ser qualquer um dos valores dados no Windows SDK.

### <a name="remarks"></a>Comentários

O modo desenho especifica como as cores da caneta e o interior dos objetos preenchidos são combinados com a cor já na superfície do display.

O modo de desenho é apenas para dispositivos rasterizados; não se aplica a dispositivos vetores. Os modos de desenho são códigos binários de operação de raster representando todas as combinações booleanas possíveis de duas variáveis, usando os operadores binários E, OR e XOR (OR exclusivo), e a operação unary NOT.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::SetStretchBltMode

Define o modo de alongamento `StretchBlt` do bitmap para a função do membro.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parâmetros

*nStretchMode*<br/>
Especifica o modo de alongamento. Pode ser qualquer um dos seguintes valores:

|Valor|Descrição|
|-----------|-----------------|
|BLACKONWHITE|Executa uma operação Boolean And usando os valores de cor para os pixels eliminados e existentes. Se o bitmap é um bitmap monocromático, este modo preserva pixels pretos em detrimento de pixels brancos.|
|COLORONCOLOR|Exclui os pixels. Este modo exclui todas as linhas eliminadas de pixels sem tentar preservar suas informações.|
|Halftone|Mapeia pixels do retângulo de origem em blocos de pixels no retângulo de destino. A cor média sobre o bloco de destino dos pixels aproxima-se da cor dos pixels de origem.|
||Depois de definir o modo de alongamento HALFTONE, um aplicativo deve chamar a função [Win32 SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) para definir a origem da escova. Se não o fizer, ocorre um desalinhamento da escova.|
|Stretch_andscans|**Windows 95/98**: O mesmo que BLACKONWHITE|
|Stretch_deletescans|**Windows 95/98**: O mesmo que COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: O mesmo que HALFTONE.|
|Stretch_orscans|**Windows 95/98**: O mesmo que WHITEONBLACK|
|Whiteonblack|Executa uma operação Boolean OR usando os valores de cor para os pixels eliminados e existentes. Se o bitmap é um bitmap monocromático, este modo preserva pixels brancos em detrimento de pixels pretos.|

### <a name="return-value"></a>Valor retornado

O modo de alongamento anterior. Pode ser STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS.

### <a name="remarks"></a>Comentários

O modo de alongamento do bitmap define como as informações são removidas de bitmaps que são compactados usando a função.

Os modos BLACKONWHITE (STRETCH_ANDSCANS) e WHITEONBLACK (STRETCH_ORSCANS) são tipicamente usados para preservar pixels em primeiro plano em bitmaps monocromáticos. O modo COLORONCOLOR (STRETCH_DELETESCANS) é normalmente usado para preservar cores em bitmaps de cores.

O modo HALFTONE requer mais processamento da imagem de origem do que os outros três modos; é mais lento que os outros, mas produz imagens de maior qualidade. Observe também `SetBrushOrgEx` que deve ser chamado após a configuração do modo HALFTONE para evitar o desalinhamento da escova.

Modos adicionais de alongamento também podem estar disponíveis dependendo das capacidades do driver do dispositivo.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::SetTextalign

Define as bandeiras de alinhamento de texto.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parâmetros

*Nflags*<br/>
Especifica sinalizadores de alinhamento de texto. As bandeiras especificam a relação entre um ponto e um retângulo que limita o texto. O ponto pode ser a posição atual ou as coordenadas especificadas por uma função de saída de texto. O retângulo que limita o texto é definido pelas células de caractere adjacentes na seqüência de texto. O parâmetro *nFlags* pode ser uma ou mais bandeiras das três categorias seguintes. Escolha apenas uma bandeira de cada categoria. A primeira categoria afeta o alinhamento de texto na direção x:

- TA_CENTER Alinha o ponto com o centro horizontal do retângulo delimitador.

- TA_LEFT Alinhe o ponto com o lado esquerdo do retângulo delimitador. Essa é a configuração padrão.

- TA_RIGHT Alinha o ponto com o lado direito do retângulo delimitador.

A segunda categoria afeta o alinhamento do texto na direção y:

- TA_BASELINE Alinhe o ponto com a linha de base da fonte escolhida.

- TA_BOTTOM Alinhe o ponto com a parte inferior do retângulo delimitador.

- TA_TOP Alinha o ponto com a parte superior do retângulo delimitador. Essa é a configuração padrão.

A terceira categoria determina se a posição atual é atualizada quando o texto é escrito:

- TA_NOUPDATECP Não atualiza a posição atual após cada chamada para uma função de saída de texto. Essa é a configuração padrão.

- TA_UPDATECP Atualiza a posição x atual após cada chamada para uma função de saída de texto. A nova posição está no lado direito do retângulo delimitador para o texto. Quando este sinalizador é definido, as coordenadas `TextOut` especificadas nas chamadas para a função membro são ignoradas.

### <a name="return-value"></a>Valor retornado

A configuração anterior de alinhamento de texto, se bem sucedida. O byte de baixa ordem contém a configuração horizontal e o byte de alta ordem contém a configuração vertical; caso contrário, 0.

### <a name="remarks"></a>Comentários

As `TextOut` `ExtTextOut` funções e membro usam esses sinalizadores ao posicionar uma seqüência de texto em um display ou dispositivo. As bandeiras especificam a relação entre um ponto específico e um retângulo que limita o texto. As coordenadas deste ponto são passadas como parâmetros para a função do `TextOut` membro. O retângulo que limita o texto é formado pelas células de caractereadjacentes na seqüência de texto.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra

Define a quantidade de espaçamento entre personagens.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parâmetros

*nCharExtra*<br/>
Especifica a quantidade de espaço extra (em unidades lógicas) a ser adicionada a cada caractere. Se o modo de `MM_TEXT`mapeamento atual não for, *o nCharExtra* será transformado e arredondado para o pixel mais próximo.

### <a name="return-value"></a>Valor retornado

O valor do espaçamento intercará anterior.

### <a name="remarks"></a>Comentários

O GDI adiciona esse espaçamento a cada caractere, incluindo caracteres de ruptura, quando grava uma linha de texto para o contexto do dispositivo. O valor padrão para a quantidade de espaçamento de intercaracteres é 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC::SetTextColor

Define a cor do texto para a cor especificada.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*Crcolor*<br/>
Especifica a cor do texto como um valor de cor RGB.

### <a name="return-value"></a>Valor retornado

Um valor RGB para a cor do texto anterior.

### <a name="remarks"></a>Comentários

O sistema usará essa cor de texto ao escrever texto para este contexto do dispositivo e também ao converter bitmaps entre contextos de dispositivos monocromáticos e de cores.

Se o dispositivo não puder representar a cor especificada, o sistema definirá a cor do texto para a cor física mais próxima. A cor de fundo de um `SetBkColor` `SetBkMode` caractere é especificada pelas funções e membro.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::SetTextJustificativa

Adiciona espaço aos caracteres de ruptura em uma seqüência.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parâmetros

*nBreakExtra*<br/>
Especifica o espaço extra total a ser adicionado à linha de texto (em unidades lógicas). Se o modo de `MM_TEXT`mapeamento atual não for, o valor dado por este parâmetro é convertido para o modo de mapeamento atual e arredondado para a unidade do dispositivo mais próximo.

*nBreakCount*<br/>
Especifica o número de caracteres de ruptura na linha.

### <a name="return-value"></a>Valor retornado

Uma se a função for bem sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um aplicativo pode `GetTextMetrics` usar as funções do membro para recuperar o caractere de ruptura de uma fonte.

Depois `SetTextJustification` que a função de membro é chamada, uma `TextOut`chamada para uma função de saída de texto (como ) distribui o espaço extra especificado uniformemente entre o número especificado de caracteres de ruptura. O caractere de ruptura é geralmente o caractere espacial (ASCII 32), mas pode ser definido por uma fonte como algum outro personagem.

A função `GetTextExtent` do membro `SetTextJustification`é normalmente usada com . `GetTextExtent`calcula a largura de uma determinada linha antes do alinhamento. Um aplicativo pode determinar quanto espaço para especificar no parâmetro *nBreakExtra* `GetTextExtent` subtraindo o valor retornado da largura da string após o alinhamento.

A `SetTextJustification` função pode ser usada para alinhar uma linha que contém várias correções em diferentes fontes. Neste caso, a linha deve ser criada em pedaços, alinhando e escrevendo cada execução separadamente.

Como erros de arredondamento podem ocorrer durante o alinhamento, o sistema mantém um termo de erro em execução que define o erro atual. Ao alinhar uma linha que `GetTextExtent` contém várias corridas, use automaticamente este termo de erro quando calcular a extensão da próxima execução. Isso permite que a função de saída de texto misture o erro na nova execução.

Depois que cada linha tiver sido alinhada, este termo de erro deve ser limpo para evitar que seja incorporado na próxima linha. O termo pode ser `SetTextJustification` compensado ligando com *nBreakExtra* definido como 0.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::SetViewportExt

Define as extensões x e y do viewport do contexto do dispositivo.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*Cx*<br/>
Especifica a extensão x da porta de exibição (em unidades do dispositivo).

*Cy*<br/>
Especifica a extensão y da porta de exibição (em unidades de dispositivo).

*Tamanho*<br/>
Especifica as extensões x e y da porta de exibição (em unidades do dispositivo).

### <a name="return-value"></a>Valor retornado

As extensões anteriores do viewport como um objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md) Quando ocorre um erro, as coordenadas x e `CSize` y do objeto retornado são definidas como 0.

### <a name="remarks"></a>Comentários

A porta de visualização, juntamente com a janela de contexto do dispositivo, define como o GDI mapeia pontos no sistema de coordenadas lógicos para pontos no sistema de coordenadas do dispositivo real. Em outras palavras, eles definem como o GDI converte coordenadas lógicas em coordenadas de dispositivos.

Quando os seguintes modos de `SetWindowExt` `SetViewportExt` mapeamento são definidos, as chamadas são ignoradas e ignoradas:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|Mm_himetric|Mm_text|
|Mm_loenglish|Mm_twips|

Quando MM_ISOTROPIC modo estiver definido, `SetWindowExt` um aplicativo deve `SetViewportExt`chamar a função de membro antes de ser chamada .

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::SetViewportOrg

Define a origem do viewport do contexto do dispositivo.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades de dispositivo) da origem do viewport. O valor deve estar dentro do intervalo do sistema de coordenadas do dispositivo.

*Y*<br/>
Especifica a coordenada y (em unidades de dispositivo) da origem do viewport. O valor deve estar dentro do intervalo do sistema de coordenadas do dispositivo.

*Ponto*<br/>
Especifica a origem do viewport. Os valores devem estar dentro do intervalo do sistema de coordenadas do dispositivo. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

A origem anterior da porta de exibição `CPoint` (em coordenadas de dispositivo) como um objeto.

### <a name="remarks"></a>Comentários

A porta de visualização, juntamente com a janela de contexto do dispositivo, define como o GDI mapeia pontos no sistema de coordenadas lógicos para pontos no sistema de coordenadas do dispositivo real. Em outras palavras, eles definem como o GDI converte coordenadas lógicas em coordenadas de dispositivos.

A origem do viewport marca o ponto no sistema de coordenadas do dispositivo ao qual `SetWindowOrg` o GDI mapeia a origem da janela, um ponto no sistema de coordenadas lógica especificado pela função do membro. O GDI mapeia todos os outros pontos seguindo o mesmo processo necessário para mapear a origem da janela até a origem do viewport. Por exemplo, todos os pontos em um círculo ao redor do ponto de origem da janela estarão em um círculo em torno do ponto de origem do viewport. Da mesma forma, todos os pontos em uma linha que passa pela origem da janela estarão em uma linha que passa pela origem do viewport.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::SetWindowExt

Define as extensões x e y da janela associadas ao contexto do dispositivo.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*Cx*<br/>
Especifica a extensão x (em unidades lógicas) da janela.

*Cy*<br/>
Especifica a extensão y (em unidades lógicas) da janela.

*Tamanho*<br/>
Especifica as extensões x e y (em unidades lógicas) da janela.

### <a name="return-value"></a>Valor retornado

As extensões anteriores da janela (em `CSize` unidades lógicas) como um objeto. Se ocorrer um erro, as coordenadas x e `CSize` y do objeto retornado serão definidas como 0.

### <a name="remarks"></a>Comentários

A janela, juntamente com a porta de visualização do contexto do dispositivo, define como o GDI mapeia pontos no sistema de coordenadas lógicas para pontos no sistema de coordenadas do dispositivo.

Quando os seguintes modos de `SetWindowExt` `SetViewportExt` mapeamento são definidos, as chamadas e as funções são ignoradas:

- MM_HIENGLISH

- Mm_himetric

- Mm_loenglish

- MM_LOMETRIC

- Mm_text

- Mm_twips

Quando MM_ISOTROPIC modo estiver definido, `SetWindowExt` um aplicativo `SetViewportExt`deve chamar a função de membro antes de chamar .

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::SetWindowOrg

Define a origem da janela do contexto do dispositivo.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da nova origem da janela.

*Y*<br/>
Especifica a coordenada lógica y da nova origem da janela.

*Ponto*<br/>
Especifica as coordenadas lógicas da nova origem da janela. Você pode passar `POINT` uma `CPoint` estrutura ou um objeto para este parâmetro.

### <a name="return-value"></a>Valor retornado

A origem anterior da `CPoint` janela como um objeto.

### <a name="remarks"></a>Comentários

A janela, juntamente com a porta de visualização do contexto do dispositivo, define como o GDI mapeia pontos no sistema de coordenadas lógicas para pontos no sistema de coordenadas do dispositivo.

A origem da janela marca o ponto no sistema de coordenadas lógico a partir do qual `SetWindowOrg` o GDI mapeia a origem do viewport, um ponto no sistema de coordenadas do dispositivo especificado pela função. O GDI mapeia todos os outros pontos seguindo o mesmo processo necessário para mapear a origem da janela até a origem do viewport. Por exemplo, todos os pontos em um círculo ao redor do ponto de origem da janela estarão em um círculo em torno do ponto de origem do viewport. Da mesma forma, todos os pontos em uma linha que passa pela origem da janela estarão em uma linha que passa pela origem do viewport.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::SetWorldTransform

Define uma transformação linear bidimensional entre o espaço do mundo e o espaço de página para o contexto especificado do dispositivo. Essa transformação pode ser usada para dimensionar, girar, cisariar ou traduzir saída gráfica.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a uma estrutura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) que contém os dados de transformação.

### <a name="return-value"></a>Valor retornado

Devolve um valor não zero no sucesso.

Retorna 0 em falha.

Para obter informações de erro estendidas, ligue para [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Este método envolve a função GDI do Windows [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::StartDoc

Informa o driver do dispositivo que um novo `StartPage` `EndPage` trabalho de impressão está começando e `EndDoc` que todas as chamadas subsequentes devem ser realizadas sob o mesmo trabalho até que ocorra uma chamada.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parâmetros

*lpDocInfo*<br/>
Aponta para uma estrutura [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) contendo o nome do arquivo do documento e o nome do arquivo de saída.

*lpszDocName*<br/>
Ponteiro para uma seqüência contendo o nome do arquivo do documento.

### <a name="return-value"></a>Valor retornado

Se a função for bem sucedida, o valor de retorno é maior que zero. Este valor é o identificador de trabalho impresso para o documento.

Se a função falhar, o valor de retorno é menor ou igual a zero.

### <a name="remarks"></a>Comentários

Isso garante que documentos com mais de uma página não serão intercalados com outros trabalhos.

Para as versões 3.1 do Windows e posteriores, esta função substitui a saída da impressora STARTDOC. O uso desta função garante que os documentos que contenham mais de uma página não sejam intercalados com outros trabalhos de impressão.

`StartDoc`não devem ser usados dentro de metaarquivos.

### <a name="example"></a>Exemplo

Este fragmento de código recebe a impressora padrão, abre um trabalho de impressão e faz uma página com "Olá, Mundo!" sobre ele. Como o texto impresso por este código não é dimensionado para as unidades lógicas da impressora, o texto de saída pode estar em letras tão pequenas que o resultado é ilegível. As funções de dimensionamento `SetViewportOrg`do `SetWindowExt`CDC, tais como `SetMapMode`, e , podem ser usadas para corrigir o dimensionamento.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::StartPage

Ligue para esta função de membro para preparar o driver da impressora para receber dados.

```
int StartPage();
```

### <a name="return-value"></a>Valor retornado

Maior ou igual a 0 se a função for bem sucedida, ou um valor negativo se ocorreu um erro.

### <a name="remarks"></a>Comentários

`StartPage`substitui as saídas NEWFRAME e BANDINFO.

Para obter uma visão geral da seqüência de chamadas de impressão, consulte a função do membro [StartDoc.](#startdoc)

O sistema desativa a função do `ResetDC` membro entre chamadas para `StartPage` e `EndPage`.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC:::StretchBlt

Copia um bitmap de um retângulo de origem em um retângulo de destino, alongando-o ou compactando-o, se necessário, para ajustá-lo às dimensões do retângulo de destino.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades lógicas) do canto esquerdo superior do retângulo de destino.

*Y*<br/>
Especifica a coordenada y (em unidades lógicas) do canto esquerdo superior do retângulo de destino.

*Nwidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de destino.

*Nheight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de destino.

*pSrcDC*<br/>
Especifica o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x (em unidades lógicas) do canto esquerdo superior do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y (em unidades lógicas) do canto esquerdo superior do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de origem.

*{1&amp;gt;dwRop&amp;lt;1}*<br/>
Especifica a operação de varredura a ser executada. Os códigos da operação de varredura definem como a GDI combina cores nas operações de saída que envolvem um pincel, um possível bitmap de origem e um bitmap de destino. Esse parâmetro pode ser um dos seguintes valores:

- BLACKNESS Torna toda a saída preta.

- DSTINVERT Inverte o bitmap de destino.

- MERGECOPY Combina o padrão e o bitmap de origem usando o operador Boolean And.

- MERGEPAINT Combina o bitmap de origem invertida com o bitmap de destino usando o operador Boolean OR.

- NOTSRCCOPY Copia o bitmap de origem invertida para o destino.

- NOTSRCERASE Inverte o resultado da combinação dos bitmaps de destino e origem usando o operador Boolean OR.

- PATCOPY Copia o padrão para o bitmap de destino.

- PATINVERT Combina o bitmap de destino com o padrão usando o operador Boolean XOR.

- PATPAINT Combina o bitmap de origem invertida com o padrão usando o operador Boolean OR. Combina o resultado dessa operação com o bitmap de destino usando o operador OR booliano.

- SRCAND Combina pixels dos bitmaps de destino e fonte usando o operador Boolean And.

- SRCCOPY Copia o bitmap de origem para o bitmap de destino.

- SRCERASE Inverte o bitmap de destino e combina o resultado com o bitmap de origem usando o operador Boolean And.

- SRCINVERT Combina pixels dos bitmaps de destino e fonte usando o operador Boolean XOR.

- SRCPAINT Combina pixels dos bitmaps de destino e fonte usando o operador Boolean OR.

- BRANCURA Torna toda a saída branca.

### <a name="return-value"></a>Valor retornado

Diferente de zero se o bitmap for desenhado; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função usa o modo de alongamento do contexto do dispositivo de destino (definido por `SetStretchBltMode`) para determinar como alongar ou compactar o bitmap.

A `StretchBlt` função move o bitmap do dispositivo de origem dado pelo *pSrcDC* para o dispositivo de destino representado pelo objeto de contexto do dispositivo cuja função de membro está sendo chamada. Os *parâmetros xSrc,* *ySrc,* *nSrcWidth*e *nSrcHeight* definem o canto superior esquerdo e as dimensões do retângulo de origem. Os parâmetros *x,* *y,* *nLargura*e *nHeight* dão o canto superior esquerdo e as dimensões do retângulo de destino. A operação de rasteres especificada pelo *dwRop* define como o bitmap de origem e os bits já no dispositivo de destino são combinados.

A `StretchBlt` função cria uma imagem espelhada de um bitmap se os sinais dos *parâmetros nSrcWidth* e *nWidth* ou *nSrcHeight* e *nHeight* diferem. Se *nSrcWidth* e *nWidth* tiverem sinais diferentes, a função criará uma imagem espelhada do bitmap ao longo do eixo x. Se *nSrcHeight* e *nHeight* tiverem sinais diferentes, a função criará uma imagem espelhada do bitmap ao longo do eixo y.

A função `StretchBlt` alonga ou compacta o bitmap de origem na memória e copia o resultado no destino. Se um padrão deve ser mesclado com o resultado, ele não será mesclado até que o bitmap de origem alongado seja copiado no destino. Se um pincel for usado, é o pincel selecionado no contexto do dispositivo de destino. As coordenadas de destino são transformadas de acordo com o contexto do dispositivo de destino; as coordenadas de origem são transformadas de acordo com o contexto do dispositivo de origem.

Se os bitmaps de destino, origem e padrão não tiverem o mesmo formato de cor, `StretchBlt` converterá os bitmaps de origem e padrão para correspondência com os bitmaps de destino. As cores do primeiro plano e do plano de fundo do contexto do dispositivo de destino são usadas na conversão.

Se `StretchBlt` precisar converter um bitmap monocromático em colorido, ele definirá bits brancos (1) para a cor do plano de fundo e bits pretos (0) para a cor do primeiro plano. Para converter o colorido em monocromático, ele define pixels que correspondam à cor do plano de fundo para branco (1) e define todos os outros pixels para preto (0). As cores do primeiro plano e do plano de fundo do contexto do dispositivo com cor são usadas.

Nem todos os dispositivos oferecem suporte à função `StretchBlt`. Para determinar se um `StretchBlt`dispositivo `GetDeviceCaps` é suportado, ligue para a função do membro com o índice RASTERCAPS e verifique o valor de retorno do sinalizador de RC_STRETCHBLT.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC::StrokeandFillPath

Fecha quaisquer figuras abertas em um caminho, traça o contorno do caminho usando a caneta atual e preenche seu interior usando o pincel atual.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado. A `StrokeAndFillPath` função do membro tem o mesmo efeito de fechar todas as figuras abertas no caminho, e acariciar e preencher o caminho separadamente, exceto que a região preenchida não se sobrepõe à região acariciada mesmo que a caneta seja larga.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::StrokePath

Renderiza o caminho especificado usando a caneta atual.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC::GuiasTextOut

Chame esta função de membro para gravar uma seqüência de caracteres no local especificado, expandindo as guias para os valores especificados na matriz de posições de parada de guia.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto de partida da string.

*Y*<br/>
Especifica a coordenada lógica y do ponto de partida da string.

*lpszString*<br/>
Aponta para a seqüência de caracteres para desenhar. Você pode passar um ponteiro para uma matriz de caracteres ou um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parâmetro.

*Ncount*<br/>
Especifica o [comprimento da seqüência](/windows/win32/gdi/specifying-length-of-text-output-string) apontou para *lpszString*.

*Ntabpositions*<br/>
Especifica o número de valores na matriz de posições de parada de guias.

*Lpntabstoppositions*<br/>
Aponta para uma matriz que contém as posições de guia-stop (em unidades lógicas). As guias devem ser classificadas em ordem crescente; o menor valor x deve ser o primeiro item na matriz.

*nTabOrigin*<br/>
Especifica a coordenada x da posição inicial a partir da qual as guias são expandidas (em unidades lógicas).

*Str*<br/>
Um `CString` objeto que contém os caracteres especificados.

### <a name="return-value"></a>Valor retornado

As dimensões da string (em unidades `CSize` lógicas) como um objeto.

### <a name="remarks"></a>Comentários

O texto é escrito na fonte selecionada no momento. Se *nTabPositions* for 0 e *lpnTabStopPositions* for NULL, as guias serão expandidas para oito vezes a largura média do caractere.

Se *nTabPositions* for 1, as guias serão separadas pela distância especificada pelo primeiro valor no array *lpnTabStopPositions.* Se o array *lpnTabStopPositions* contiver mais de um valor, uma parada de guia será definida para cada valor na matriz, até o número especificado por *nTabPositions*. O parâmetro *nTabOrigin* permite que `TabbedTextOut` um aplicativo chame a função várias vezes para uma única linha. Se o aplicativo chamar a função mais de uma vez com o *nTabOrigin* definido para o mesmo valor cada vez, a função expande todas as guias em relação à posição especificada por *nTabOrigin*.

Por padrão, a posição atual não é usada nem atualizada pela função. Se um aplicativo precisar atualizar a posição atual quando ele chamar a função, o aplicativo pode chamar a função de membro [SetTextAlign](#settextalign) com *nFlags* definido sTA_UPDATECP. Quando este sinalizador é definido, o Windows ignora `TabbedTextOut`os parâmetros *x* e *y* em chamadas subseqüentes para , usando a posição atual em vez disso.

## <a name="cdctextout"></a><a name="textout"></a>CDC::TextOut

Grava uma cadeia de caracteres no local especificado usando a fonte selecionada no momento.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto de partida do texto.

*Y*<br/>
Especifica a coordenada y lógica do ponto de partida do texto.

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhada.

*Ncount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*Str*<br/>
Um objeto `CString` que contém os caracteres a serem desenhados.

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As origens do caractere estão no canto superior esquerdo da célula do caractere. Por padrão, a posição atual não é usada nem atualizada pela função.

Se um aplicativo precisar atualizar a `TextOut`posição atual quando `SetTextAlign` ele chamar, o aplicativo pode chamar a função de membro com *nFlags* definido para TA_UPDATECP. Quando este sinalizador é definido, o Windows ignora `TextOut`os parâmetros *x* e *y* em chamadas subseqüentes para , usando a posição atual em vez disso.

### <a name="example"></a>Exemplo

  Veja o exemplo [de CDC::BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::TransparentBlt

Ligue para esta função de membro para transferir um bit-block dos dados de cor, que corresponde a um retângulo de pixels do contexto do dispositivo de origem especificado, para um contexto do dispositivo de destino.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parâmetros

*xDest*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*yDest*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*nDestWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino.

*nDestHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino.

*pSrcDC*<br/>
Ponteiro para o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*clrTransparent*<br/>
A cor RGB no bitmap de origem para tratar como transparente.

### <a name="return-value"></a>Valor retornado

VERDADE se bem sucedido; caso contrário, FALSO.

### <a name="remarks"></a>Comentários

`TransparentBlt`permite transparência; ou seja, a cor RGB indicada pelo *clrTransparent* é transparente para a transferência.

Para obter mais informações, consulte [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) no Windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC::UpdateCores

Atualiza a área cliente do contexto do dispositivo combinando as cores atuais na área do cliente com a paleta do sistema em uma base pixel por pixel.

```
void UpdateColors();
```

### <a name="remarks"></a>Comentários

Uma janela inativa com uma `UpdateColors` paleta lógica realizada pode chamar como uma alternativa para redesenhar sua área cliente quando a paleta do sistema mudar.

Para obter mais informações sobre o uso de paletas de cores, consulte [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) no Windows SDK.

A `UpdateColors` função membro normalmente atualiza uma área cliente mais rápido do que redesenhar a área. No entanto, como a função executa a tradução de cores com base na cor de cada pixel antes da paleta do sistema mudar, cada chamada para esta função resulta na perda de alguma precisão de cor.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC::WidenPath

Redefine o caminho atual como a área que seria pintada se o caminho fosse traçado usando a caneta atualmente selecionada no contexto do dispositivo.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valor retornado

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Esta função só é bem sucedida se a caneta atual `CreatePen` for uma caneta geométrica criada pela segunda `CreatePen` versão da função do membro, ou se a caneta for criada com a primeira versão e tiver uma largura, em unidades do dispositivo, maior que 1. O contexto do dispositivo deve conter um caminho fechado. Todas as curvas de Bzier no caminho são convertidas em seqüências de linhas retas aproximando as curvas ampliadas. Como tal, nenhuma curva de Bzier `WidenPath` permanece no caminho depois que é chamado.

## <a name="see-also"></a>Confira também

[Classe CObject](../../mfc/reference/cobject-class.md)<br/>
[Gráfico da hierarquia](../../mfc/hierarchy-chart.md)<br/>
[Classe CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Classe CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Classe CClientDC](../../mfc/reference/cclientdc-class.md)<br/>
[Classe CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)
