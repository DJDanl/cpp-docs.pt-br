---
title: Classe CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: bae2f9a5a4f39c4eeffe68cc33e744e44c6800c8
ms.sourcegitcommit: 389c559918d9bfaf303d262ee5430d787a662e92
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/25/2019
ms.locfileid: "69507009"
---
# <a name="cdc-class"></a>Classe CDC

Define uma classe de objetos de contexto de dispositivo.

## <a name="syntax"></a>Sintaxe

```
class CDC : public CObject
```

## <a name="members"></a>Membros

### <a name="public-constructors"></a>Construtores públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::CDC](#cdc)|Constrói um objeto `CDC`.|

### <a name="public-methods"></a>Métodos públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Encerra o trabalho de impressão atual, apagando tudo o que o aplicativo gravou no dispositivo desde a última chamada da `StartDoc` função membro.|
|[CDC::AbortPath](#abortpath)|Fecha e descarta todos os caminhos no contexto do dispositivo.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copia o comentário de um buffer para um metarquivo de formato avançado especificado.|
|[CDC::AlphaBlend](#alphablend)|Exibe os bitmaps que têm pixels transparentes ou semitransparentes.|
|[CDC::AngleArc](#anglearc)|Desenha um segmento de linha e um arco e move a posição atual para o ponto final do arco.|
|[CDC::Arc](#arc)|Desenha um arco elíptico.|
|[CDC::ArcTo](#arcto)|Desenha um arco elíptico. Essa função é semelhante a `Arc`, exceto que a posição atual é atualizada.|
|[CDC::Attach](#attach)|Anexa um contexto de dispositivo do Windows a `CDC` este objeto.|
|[CDC::BeginPath](#beginpath)|Abre um colchete de caminho no contexto do dispositivo.|
|[CDC::BitBlt](#bitblt)|Copia um bitmap de um contexto de dispositivo especificado.|
|[CDC::Chord](#chord)|Desenha uma corda (uma figura fechada limitada pela interseção de uma elipse e um segmento de linha).|
|[CDC::CloseFigure](#closefigure)|Fecha uma figura aberta em um caminho.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Cria um contexto de dispositivo de memória que é compatível com outro contexto de dispositivo. Você pode usá-lo para preparar imagens na memória.|
|[CDC::CreateDC](#createdc)|Cria um contexto de dispositivo para um dispositivo específico.|
|[CDC::CreateIC](#createic)|Cria um contexto de informações para um dispositivo específico. Isso fornece uma maneira rápida de obter informações sobre o dispositivo sem criar um contexto de dispositivo.|
|[CDC::DeleteDC](#deletedc)|Exclui o contexto de dispositivo do Windows associado `CDC` a este objeto.|
|[CDC::DeleteTempMap](#deletetempmap)|Chamado pelo `CWinApp` manipulador de tempo ocioso para excluir qualquer objeto temporário `CDC` criado pelo. `FromHandle` Também desanexa o contexto do dispositivo.|
|[CDC::Detach](#detach)|Desanexa o contexto de dispositivo do `CDC` Windows deste objeto.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Converte unidades de dispositivo em unidades HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Converte unidades de dispositivo em unidades lógicas.|
|[CDC::Draw3dRect](#draw3drect)|Desenha um retângulo tridimensional.|
|[CDC::DrawDragRect](#drawdragrect)|Apaga e redesenha um retângulo conforme ele é arrastado.|
|[CDC::DrawEdge](#drawedge)|Desenha as bordas de um retângulo.|
|[CDC::DrawEscape](#drawescape)|Acessa os recursos de desenho de uma exibição de vídeo que não estão diretamente disponíveis por meio da GDI (Graphics Device Interface).|
|[CDC::DrawFocusRect](#drawfocusrect)|Desenha um retângulo no estilo usado para indicar o foco.|
|[CDC::DrawFrameControl](#drawframecontrol)|Desenhe um controle de quadro.|
|[CDC::DrawIcon](#drawicon)|Desenha um ícone.|
|[CDC::DrawState](#drawstate)|Exibe uma imagem e aplica um efeito visual para indicar um estado.|
|[CDC::D rawText](#drawtext)|Desenha texto formatado no retângulo especificado.|
|[CDC::DrawTextEx](#drawtextex)|Desenha o texto formatado no retângulo especificado usando formatos adicionais.|
|[CDC::Ellipse](#ellipse)|Desenha uma elipse.|
|[CDC::EndDoc](#enddoc)|Finaliza um trabalho de impressão iniciado pela `StartDoc` função de membro.|
|[CDC::EndPage](#endpage)|Informa ao driver de dispositivo que uma página está terminando.|
|[CDC::EndPath](#endpath)|Fecha um colchete de caminho e seleciona o caminho definido pelo colchete no contexto do dispositivo.|
|[CDC:: EnumObjects](#enumobjects)|Enumera as canetas e os pincéis disponíveis em um contexto de dispositivo.|
|[CDC::Escape](#escape)|Permite que os aplicativos acessem recursos que não estão diretamente disponíveis de um dispositivo específico por meio do GDI. Também permite o acesso a funções de escape do Windows. Chamadas de escape feitas por um aplicativo são convertidas e enviadas para o driver de dispositivo.|
|[CDC::ExcludeClipRect](#excludecliprect)|Cria uma nova região de recorte que consiste na região de recorte existente menos o retângulo especificado.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Impede o desenho em áreas inválidas de uma janela, excluindo uma região atualizada na janela de uma região de recorte.|
|[CDC::ExtFloodFill](#extfloodfill)|Preenche uma área com o pincel atual. Fornece mais flexibilidade do que a função de membro [CDC:: FloodFill](#floodfill) .|
|[CDC::ExtTextOut](#exttextout)|Grava uma cadeia de caracteres em uma região retangular usando a fonte atualmente selecionada.|
|[CDC::FillPath](#fillpath)|Fecha as figuras abertas no caminho atual e preenche o interior do caminho usando o pincel atual e o modo de preenchimento de polígono.|
|[CDC::FillRect](#fillrect)|Preenche um retângulo determinado usando um pincel específico.|
|[CDC::FillRgn](#fillrgn)|Preenche uma região específica com o pincel especificado.|
|[CDC::FillSolidRect](#fillsolidrect)|Preenche um retângulo com uma cor sólida.|
|[CDC::FlattenPath](#flattenpath)|Transforma todas as curvas no caminho selecionado no contexto do dispositivo atual e ativa cada curva em uma sequência de linhas.|
|[CDC::FloodFill](#floodfill)|Preenche uma área com o pincel atual.|
|[CDC::FrameRect](#framerect)|Desenha uma borda em torno de um retângulo.|
|[CDC::FrameRgn](#framergn)|Desenha uma borda em torno de uma região específica usando um pincel.|
|[CDC::FromHandle](#fromhandle)|Retorna um ponteiro para um `CDC` objeto quando um identificador para um contexto de dispositivo é fornecido. Se um `CDC` objeto não estiver anexado ao identificador, um objeto temporário `CDC` será criado e anexado.|
|[CDC::GetArcDirection](#getarcdirection)|Retorna a direção do arco atual para o contexto do dispositivo.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Recupera a configuração do filtro de taxa de proporção atual.|
|[CDC::GetBkColor](#getbkcolor)|Recupera a cor do plano de fundo atual.|
|[CDC::GetBkMode](#getbkmode)|Recupera o modo em segundo plano.|
|[CDC::GetBoundsRect](#getboundsrect)|Retorna o retângulo delimitador acumulado atual para o contexto de dispositivo especificado.|
|[CDC::GetBrushOrg](#getbrushorg)|Recupera a origem do pincel atual.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Recupera as larguras, em unidades lógicas, de caracteres consecutivos em um determinado intervalo da fonte atual.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Recupera as larguras, em unidades lógicas, de índices de glifos consecutivos em um intervalo especificado da fonte TrueType atual.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Recupera vários tipos de informações em uma cadeia de caracteres.|
|[CDC::GetCharWidth](#getcharwidth)|Recupera as larguras fracionárias de caracteres consecutivos em um determinado intervalo da fonte atual.|
|[CDC::GetCharWidthI](#getcharwidthi)|Recupera as larguras, em coordenadas lógicas, de índices de glifos consecutivos em um intervalo especificado da fonte atual.|
|[CDC::GetClipBox](#getclipbox)|Recupera as dimensões do retângulo delimitador mais rígido em torno do limite de recorte atual.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Recupera os valores de ajuste de cor para o contexto do dispositivo.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retorna um ponteiro para o objeto atualmente `CBitmap` selecionado.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retorna um ponteiro para o objeto atualmente `CBrush` selecionado.|
|[CDC::GetCurrentFont](#getcurrentfont)|Retorna um ponteiro para o objeto atualmente `CFont` selecionado.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retorna um ponteiro para o objeto atualmente `CPalette` selecionado.|
|[CDC::GetCurrentPen](#getcurrentpen)|Retorna um ponteiro para o objeto atualmente `CPen` selecionado.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Recupera a posição atual da caneta (em coordenadas lógicas).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Recupera a cor atual do pincel.|
|[CDC::GetDCPenColor](#getdcpencolor)|Recupera a cor atual da caneta.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Recupera um tipo especificado de informações específicas do dispositivo sobre os recursos de um determinado dispositivo de vídeo.|
|[CDC::GetFontData](#getfontdata)|Recupera informações de métricas de fonte de um arquivo de fonte escalonável. As informações a serem recuperadas são identificadas especificando um deslocamento no arquivo de fonte e o comprimento das informações a serem retornadas.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retorna informações sobre a fonte selecionada no momento para o contexto de exibição especificado.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Recupera a curva de estrutura de tópicos ou bitmap para um caractere de estrutura de tópicos na fonte atual.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Recupera o modo gráfico atual para o contexto do dispositivo especificado.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Recupera um pincel de meio-tom.|
|[CDC::GetKerningPairs](#getkerningpairs)|Recupera os pares de kerning de caracteres para a fonte selecionada no momento no contexto do dispositivo especificado.|
|[CDC::GetLayout](#getlayout)|Recupera o layout de um DC (contexto de dispositivo). O layout pode ser da esquerda para a direita (padrão) ou da direita para a esquerda (espelhado).|
|[CDC::GetMapMode](#getmapmode)|Recupera o modo de mapeamento atual.|
|[CDC::GetMiterLimit](#getmiterlimit)|Retorna o limite de mitra para o contexto do dispositivo.|
|[CDC::GetNearestColor](#getnearestcolor)|Recupera a cor lógica mais próxima para uma cor lógica especificada que o determinado dispositivo pode representar.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Recupera informações de métrica de fonte para fontes TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Recupera as larguras de caracteres individuais em um grupo consecutivo de caracteres da fonte atual usando o contexto do dispositivo de saída.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Computa a largura e a altura de uma cadeia de caracteres no contexto do dispositivo de saída.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Computa a largura e a altura de uma linha de texto no contexto do dispositivo de saída usando a fonte atual para determinar as dimensões.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Recupera as métricas da fonte atual do contexto do dispositivo de saída.|
|[CDC::GetPath](#getpath)|Recupera as coordenadas definindo os pontos de extremidade de linhas e os pontos de controle das curvas encontradas no caminho selecionado no contexto do dispositivo.|
|[CDC::GetPixel](#getpixel)|Recupera o valor de cor RGB do pixel no ponto especificado.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Recupera o modo de preenchimento de polígono atual.|
|[CDC::GetROP2](#getrop2)|Recupera o modo de desenho atual.|
|[CDC::GetSafeHdc](#getsafehdc)|Retorna [CDC:: m_hDC](#m_hdc), o contexto do dispositivo de saída.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Recupera o modo de alongamento de bitmaps atual.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Computa a largura e a altura de uma cadeia de caracteres no contexto do dispositivo de atributo.|
|[CDC::GetTextAlign](#gettextalign)|Recupera os sinalizadores de alinhamento de texto.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Recupera a configuração atual para a quantidade de espaçamento entre caracteres.|
|[CDC::GetTextColor](#gettextcolor)|Recupera a cor do texto atual.|
|[CDC::GetTextExtent](#gettextextent)|Computa a largura e a altura de uma linha de texto no contexto do dispositivo de atributo usando a fonte atual para determinar as dimensões.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Recupera o número de caracteres em uma cadeia de caracteres especificada que se ajustará em um espaço especificado e preencherá uma matriz com a extensão de texto para cada um desses caracteres.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Recupera a largura e a altura da matriz especificada de índices de glifos.|
|[CDC::GetTextFace](#gettextface)|Copia o nome de tipo da fonte atual em um buffer como uma cadeia de caracteres terminada em nulo.|
|[CDC::GetTextMetrics](#gettextmetrics)|Recupera as métricas da fonte atual do contexto do dispositivo de atributo.|
|[CDC::GetViewportExt](#getviewportext)|Recupera as extensões x e y do visor.|
|[CDC::GetViewportOrg](#getviewportorg)|Recupera as coordenadas x e y da origem do visor.|
|[CDC::GetWindow](#getwindow)|Retorna a janela associada ao contexto do dispositivo de vídeo.|
|[CDC::GetWindowExt](#getwindowext)|Recupera as extensões x e y da janela associada.|
|[CDC::GetWindowOrg](#getwindoworg)|Recupera as coordenadas x e y da origem da janela associada.|
|[CDC::GetWorldTransform](#getworldtransform)|Recupera a transformação espaço mundial atual para a página-espaço.|
|[CDC::GradientFill](#gradientfill)|Preenche as estruturas de retângulo e triângulo com uma cor gradating.|
|[CDC::GrayString](#graystring)|Desenha texto esmaecido (cinza) no local especificado.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Converte unidades HIMETRIC em unidades de dispositivo.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Converte unidades HIMETRIC em unidades lógicas.|
|[CDC::IntersectClipRect](#intersectcliprect)|Cria uma nova região de recorte ao formar a interseção da região atual e um retângulo.|
|[CDC::InvertRect](#invertrect)|Inverte o conteúdo de um retângulo.|
|[CDC::InvertRgn](#invertrgn)|Inverte as cores em uma região.|
|[CDC::IsPrinting](#isprinting)|Determina se o contexto do dispositivo está sendo usado para impressão.|
|[CDC::LineTo](#lineto)|Desenha uma linha da posição atual até, mas não incluindo, um ponto.|
|[CDC::LPtoDP](#lptodp)|Converte unidades lógicas em unidades de dispositivo.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Converte unidades lógicas em unidades HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Combina os dados de cor dos bitmaps de origem e de destino usando a máscara e a operação de varredura fornecidas.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Altera a transformação mundial para um contexto de dispositivo usando o modo especificado.|
|[CDC::MoveTo](#moveto)|Move a posição atual.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Move a região de recorte do dispositivo especificado.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifica a origem do visor em relação às coordenadas da origem do visor atual.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifica a origem da janela em relação às coordenadas da origem da janela atual.|
|[CDC::PaintRgn](#paintrgn)|Preenche uma região com o pincel selecionado.|
|[CDC::PatBlt](#patblt)|Cria um padrão de bit.|
|[CDC::Pie](#pie)|Desenha uma fatia em formato de pizza.|
|[CDC::PlayMetaFile](#playmetafile)|Reproduz o conteúdo do metarquivo especificado no dispositivo fornecido. A versão aprimorada `PlayMetaFile` do exibe a imagem armazenada no metarquivo de formato avançado fornecido. O metarquivo pode ser reproduzido várias vezes.|
|[CDC::PlgBlt](#plgblt)|Executa uma transferência de bloco de bits dos dados de cor do retângulo especificado no contexto do dispositivo de origem para o paralelogramo especificado no contexto do dispositivo fornecido.|
|[CDC::PolyBezier](#polybezier)|Desenha um ou mais Bziers de linha. A posição atual não é usada nem atualizada.|
|[CDC::PolyBezierTo](#polybezierto)|Desenha uma ou mais Bziers e move a posição atual para o ponto final do último Bzier spline.|
|[CDC::PolyDraw](#polydraw)|Desenha um conjunto de segmentos de linha e Bzier de linhas. Essa função atualiza a posição atual.|
|[CDC::Polygon](#polygon)|Desenha um polígono que consiste em dois ou mais pontos (vértices) conectados por linhas.|
|[CDC::Polyline](#polyline)|Desenha um conjunto de segmentos de linha conectando os pontos especificados.|
|[CDC::PolylineTo](#polylineto)|Desenha uma ou mais linhas retas e move a posição atual para o ponto final da última linha.|
|[CDC::PolyPolygon](#polypolygon)|Cria dois ou mais polígonos que são preenchidos usando o modo de preenchimento de polígono atual. Os polígonos podem ser não contíguos ou podem se sobrepor.|
|[CDC::PolyPolyline](#polypolyline)|Desenha várias séries de segmentos de linha conectados. A posição atual não é usada nem atualizada por essa função.|
|[CDC::PtVisible](#ptvisible)|Especifica se o ponto determinado está dentro da região de recorte.|
|[CDC::RealizePalette](#realizepalette)|Mapeia entradas da paleta na paleta lógica atual para a paleta do sistema.|
|[CDC::Rectangle](#rectangle)|Desenha um retângulo usando a caneta atual e a preenche usando o pincel atual.|
|[CDC::RectVisible](#rectvisible)|Determina se alguma parte do retângulo fornecido está dentro da região de recorte.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Versões `m_hAttribDC`, o contexto do dispositivo de atributo.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Libera `m_hDC`, o contexto do dispositivo de saída.|
|[CDC::ResetDC](#resetdc)|Atualiza o `m_hAttribDC` contexto do dispositivo.|
|[CDC::RestoreDC](#restoredc)|Restaura o contexto do dispositivo para um estado anterior salvo com `SaveDC`.|
|[CDC::RoundRect](#roundrect)|Desenha um retângulo com cantos arredondados usando a caneta atual e preenchido usando o pincel atual.|
|[CDC::SaveDC](#savedc)|Salva o estado atual do contexto do dispositivo.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifica a extensão do visor relativa aos valores atuais.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modifica as extensões de janela relativas aos valores atuais.|
|[CDC::ScrollDC](#scrolldc)|Rola um retângulo de bits horizontal e verticalmente.|
|[CDC::SelectClipPath](#selectclippath)|Seleciona o caminho atual como uma região de recorte para o contexto do dispositivo, combinando a nova região com qualquer região de recorte existente usando o modo especificado.|
|[CDC::SelectClipRgn](#selectcliprgn)|Combina a região especificada com a região de recorte atual usando o modo especificado.|
|[CDC::SelectObject](#selectobject)|Seleciona um objeto de desenho GDI, como uma caneta.|
|[CDC::SelectPalette](#selectpalette)|Seleciona a paleta lógica.|
|[CDC::SelectStockObject](#selectstockobject)|Seleciona uma das canetas, pincéis ou fontes de ações predefinidas fornecidas pelo Windows.|
|[CDC::SetAbortProc](#setabortproc)|Define uma função de retorno de chamada fornecida pelo programador que o Windows chama se um trabalho de impressão deve ser anulado.|
|[CDC::SetArcDirection](#setarcdirection)|Define a direção do desenho a ser usada para as funções Arc e Rectangle.|
|[CDC::SetAttribDC](#setattribdc)|Define `m_hAttribDC`, o contexto do dispositivo de atributo.|
|[CDC::SetBkColor](#setbkcolor)|Define a cor do plano de fundo atual.|
|[CDC::SetBkMode](#setbkmode)|Define o modo de segundo plano.|
|[CDC::SetBoundsRect](#setboundsrect)|Controla a acumulação de informações de retângulo delimitador para o contexto de dispositivo especificado.|
|[CDC::SetBrushOrg](#setbrushorg)|Especifica a origem do próximo pincel selecionado em um contexto de dispositivo.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Define os valores de ajuste de cor para o contexto do dispositivo usando os valores especificados.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Define a cor do pincel atual.|
|[CDC::SetDCPenColor](#setdcpencolor)|Define a cor da caneta atual.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Define o modo gráfico atual para o contexto do dispositivo especificado.|
|[CDC::SetLayout](#setlayout)|Altera o layout de um contexto de dispositivo (DC).|
|[CDC::SetMapMode](#setmapmode)|Define o modo de mapeamento atual.|
|[CDC::SetMapperFlags](#setmapperflags)|Altera o algoritmo que o mapeador de fontes usa ao mapear fontes lógicas para fontes físicas.|
|[CDC::SetMiterLimit](#setmiterlimit)|Define o limite para o comprimento de junções de Mitre para o contexto do dispositivo.|
|[CDC::SetOutputDC](#setoutputdc)|Define `m_hDC`, o contexto do dispositivo de saída.|
|[CDC::SetPixel](#setpixel)|Define o pixel no ponto especificado para a aproximação mais próxima da cor especificada.|
|[CDC::SetPixelV](#setpixelv)|Define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. `SetPixelV`é mais rápido `SetPixel` do que porque não precisa retornar o valor de cor do ponto realmente pintado.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Define o modo de preenchimento de polígono.|
|[CDC::SetROP2](#setrop2)|Define o modo de desenho atual.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Define o modo de alongamento de bitmap.|
|[CDC::SetTextAlign](#settextalign)|Define os sinalizadores de alinhamento de texto.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Define a quantidade de espaçamento entre caracteres.|
|[CDC::SetTextColor](#settextcolor)|Define a cor do texto.|
|[CDC::SetTextJustification](#settextjustification)|Adiciona espaço aos caracteres de quebra em uma cadeia de caracteres.|
|[CDC::SetViewportExt](#setviewportext)|Define as extensões x e y do visor.|
|[CDC::SetViewportOrg](#setviewportorg)|Define a origem do visor.|
|[CDC::SetWindowExt](#setwindowext)|Define as extensões x e y da janela associada.|
|[CDC::SetWindowOrg](#setwindoworg)|Define a origem da janela do contexto do dispositivo.|
|[CDC::SetWorldTransform](#setworldtransform)|Define o espaço mundial atual para a transformação de espaço de página.|
|[CDC::StartDoc](#startdoc)|Informa o driver de dispositivo que um novo trabalho de impressão está iniciando.|
|[CDC::StartPage](#startpage)|Informa ao driver de dispositivo que uma nova página está iniciando.|
|[CDC::StretchBlt](#stretchblt)|Move um bitmap de um retângulo de origem e um dispositivo para um retângulo de destino, alongando ou compactando o bitmap, se necessário, para se ajustar às dimensões do retângulo de destino.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Fecha as figuras abertas em um caminho, atinge o contorno do caminho usando a caneta atual e preenche seu interior usando o pincel atual.|
|[CDC::StrokePath](#strokepath)|Renderiza o caminho especificado usando a caneta atual.|
|[CDC::TabbedTextOut](#tabbedtextout)|Grava uma cadeia de caracteres em um local especificado, expandindo as guias para os valores especificados em uma matriz de posições de parada de tabulação.|
|[CDC::TextOut](#textout)|Grava uma cadeia de caracteres em um local especificado usando a fonte atualmente selecionada.|
|[CDC::TransparentBlt](#transparentblt)|Transfere um bloco de bits de dados de cor do contexto do dispositivo de origem especificado para um contexto de dispositivo de destino, Renderizando uma cor transparente especificada na transferência.|
|[CDC::UpdateColors](#updatecolors)|Atualiza a área do cliente do contexto do dispositivo, combinando as cores atuais na área do cliente para a paleta do sistema em uma base de pixel por pixel.|
|[CDC::WidenPath](#widenpath)|Redefine o caminho atual como a área que seria pintada se o caminho tivesse sido traçado usando a caneta atualmente selecionada no contexto do dispositivo.|

### <a name="public-operators"></a>Operadores públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC:: Operator HDC](#operator_hdc)|Recupera o identificador do contexto do dispositivo.|

### <a name="public-data-members"></a>Membros de Dados Públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|O contexto do dispositivo de atributo usado por `CDC` este objeto.|
|[CDC::m_hDC](#m_hdc)|O contexto do dispositivo de saída usado por `CDC` este objeto.|

## <a name="remarks"></a>Comentários

O `CDC` objeto fornece funções de membro para trabalhar com um contexto de dispositivo, como uma exibição ou impressora, bem como membros para trabalhar com um contexto de exibição associado à área do cliente de uma janela.

Faça todo o desenho através das funções de membro `CDC` de um objeto. A classe fornece funções de membro para operações de contexto de dispositivo, trabalhando com ferramentas de desenho, seleção de objeto de interface de dispositivo de gráficos seguro (GDI) e trabalho com cores e paletas. Ele também fornece funções de membro para obter e definir atributos de desenho, mapear, trabalhar com o visor, trabalhar com a extensão da janela, converter coordenadas, trabalhar com regiões, recorte, linhas de desenho e desenhar formas simples, reticências e polígonos. As funções de membro também são fornecidas para o desenho de texto, o trabalho com fontes, o uso de escapes de impressora, rolagem e reprodução de metaarquivos.

Para usar um `CDC` objeto, construí-lo e, em seguida, chamar suas funções de membro que funções paralelas do Windows que usam contextos de dispositivo.

> [!NOTE]
>  No Windows 95/98, todas as coordenadas de tela são limitadas a 16 bits. Portanto, um **int** passado para uma `CDC` função de membro deve estar no intervalo de-32768 a 32767.

Para usos específicos, o biblioteca MFC fornece várias classes derivadas de `CDC` . `CPaintDC`Encapsula chamadas para `BeginPaint` e `EndPaint`. `CClientDC`gerencia um contexto de exibição associado à área do cliente da janela. `CWindowDC`gerencia um contexto de exibição associado a uma janela inteira, incluindo seu quadro e controles. `CMetaFileDC`associa um contexto de dispositivo a um metarquivo.

`CDC`fornece duas funções de membro [GetLayout](#getlayout), e  [SetLayout](#setlayout), para reverter o layout de um contexto de dispositivo, que não herda seu layout de uma janela. Essa orientação da direita para a esquerda é necessária para aplicativos escritos para culturas, como árabe ou Hebraico, em que o layout do caractere não é o padrão europeu.

`CDC`contém dois contextos de dispositivo, [m_hDC](#m_hdc) e [m_hAttribDC](#m_hattribdc), que, na criação de `CDC` um objeto, referem-se ao mesmo dispositivo. `CDC`direciona todas as chamadas GDI de saída `m_hDC` para e a maioria das chamadas `m_hAttribDC`GDI de atributo para. (Um exemplo de uma chamada de atributo `GetTextColor`é, `SetTextColor` enquanto é uma chamada de saída).

Por exemplo, a estrutura usa esses dois contextos de dispositivo para implementar `CMetaFileDC` um objeto que enviará a saída para um metarquivo durante a leitura de atributos de um dispositivo físico. A visualização de impressão é implementada na estrutura de maneira semelhante. Você também pode usar os dois contextos de dispositivo de forma semelhante no código específico do aplicativo.

Há ocasiões em que você pode precisar de informações de métrica de texto de `m_hDC` ambos `m_hAttribDC` os contextos de dispositivo. Os seguintes pares de funções fornecem esse recurso:

|Usa m_hAttribDC|Usa m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Para obter mais informações `CDC`sobre o, consulte [contextos de dispositivo](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hierarquia de herança

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Requisitos

**Cabeçalho:** Afxwin. h

##  <a name="abortdoc"></a>  CDC::AbortDoc

Encerra o trabalho de impressão atual e apaga tudo o que o aplicativo gravou no dispositivo desde a última chamada para a função de membro [StartDoc](#startdoc) .

```
int AbortDoc();
```

### <a name="return-value"></a>Valor de retorno

Um valor maior ou igual a 0 se for bem-sucedido ou um valor negativo se ocorrer um erro. A lista a seguir mostra os valores de erro comuns e seus significados:

- Erro geral de SP_ERROR.

- SP_OUTOFDISK espaço em disco insuficiente atualmente está disponível para o spool e não haverá mais espaço disponível.

- SP_OUTOFMEMORY não há memória suficiente disponível para o spool.

- O usuário SP_USERABORT encerrou o trabalho por meio do Gerenciador de impressão.

### <a name="remarks"></a>Comentários

Essa função de membro substitui o escape de impressora ABORTDOC.

`AbortDoc`deve ser usado para encerrar o seguinte:

- Operações de impressão que não especificam uma função Abort usando [SetAbortProc](#setabortproc).

- Operações de impressão que ainda não atingiram sua primeira chamada de escape NEWFRAME ou NEXTBAND.

Se um aplicativo encontrar um erro de impressão ou uma operação de impressão cancelada, ele não deverá tentar encerrar a operação usando as funções [EndDoc](#enddoc) ou membro `AbortDoc` da classe `CDC`. O GDI encerra automaticamente a operação antes de retornar o valor do erro.

Se o aplicativo exibir uma caixa de diálogo para permitir que o usuário cancele a operação de impressão, ele `AbortDoc` deverá chamar antes de destruir a caixa de diálogo.

Se o Gerenciador de impressão foi usado para iniciar o trabalho de `AbortDoc` impressão, chamar apaga todo o trabalho de spool – a impressora recebe nada. Se o Gerenciador de impressão não foi usado para iniciar o trabalho de impressão, os dados podem ter sido enviados para `AbortDoc` a impressora antes de serem chamados. Nesse caso, o driver de impressora teria redefinido a impressora (quando possível) e fechado o trabalho de impressão.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: StartDoc](#startdoc).

##  <a name="abortpath"></a>  CDC::AbortPath

Fecha e descarta todos os caminhos no contexto do dispositivo.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se houver um colchete de abertura de caminho no contexto do dispositivo, o colchete de caminho será fechado e o caminho será Descartado. Se houver um caminho fechado no contexto do dispositivo, o caminho será Descartado.

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

Copia o comentário de um buffer para um metarquivo de formato avançado especificado.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parâmetros

*nDataSize*<br/>
Especifica o comprimento do buffer de comentário, em bytes.

*pCommentData*<br/>
Aponta para o buffer que contém o comentário.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um comentário pode incluir qualquer informação particular — por exemplo, a origem da imagem e a data em que ela foi criada. Um comentário deve começar com uma assinatura de aplicativo, seguida pelos dados. Os comentários não devem conter dados específicos da posição. Dados específicos da posição especifica o local de um registro e não deve ser incluído porque um metarquivo pode ser inserido em outro metarquivo. Essa função só pode ser usada com metarquivos avançados.

##  <a name="alphablend"></a>  CDC::AlphaBlend

Chame essa função de membro para exibir bitmaps com pixels transparentes ou semitransparentes.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parâmetros

*xDest*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*yDest*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*nDestWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino.

*nDestHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino.

*pSrcDC*<br/>
Um ponteiro para o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*fusão*<br/>
Especifica uma estrutura [BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction) .

### <a name="return-value"></a>Valor de retorno

Verdadeiro se for bem-sucedido; caso contrário, FALSE.

### <a name="remarks"></a>Comentários

Consulte [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) no SDK do Windows para obter mais informações.

##  <a name="anglearc"></a>  CDC::AngleArc

Desenha um segmento de linha e um arco.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do centro do círculo.

*y*<br/>
Especifica a coordenada y lógica do centro do círculo.

*nRadius*<br/>
Especifica o raio do círculo em unidades lógicas. Esse valor deve ser positivo.

*fStartAngle*<br/>
Especifica o ângulo inicial em graus em relação ao eixo x.

*fSweepAngle*<br/>
Especifica o ângulo de flecha em graus em relação ao ângulo inicial.

### <a name="return-value"></a>Valor de retorno

Diferente de zero, se for bem-sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

O segmento de linha é desenhado a partir da posição atual até o início do arco. O arco é desenhado ao longo do perímetro de um círculo com o raio e o centro fornecidos. O comprimento do arco é definido pelos ângulos de início e de limpeza fornecidos.

`AngleArc`move a posição atual para o ponto final do arco. O arco desenhado por essa função pode parecer elíptico, dependendo do modo de transformação e de mapeamento atual. Antes de desenhar o arco, essa função desenha o segmento de linha da posição atual até o início do arco. O arco é desenhado pela construção de um círculo imaginário com o raio especificado em redor do ponto central especificado. O ponto inicial do arco é determinado pela medição no sentido anti-horário do eixo x do círculo pelo número de graus no ângulo inicial. O ponto final está localizado da mesma forma medindo o sentido anti-horário do ponto de partida pelo número de graus no ângulo de flecha.

Se o ângulo de flecha for maior que 360 graus, o arco será removido várias vezes. Essa função desenha linhas usando a caneta atual. A figura não está preenchida.

##  <a name="arc"></a>  CDC::Arc

Desenha um arco elíptico.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*Y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*y3*<br/>
Especifica a coordenada y do ponto que define o ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*Y4*<br/>
Especifica a coordenada y do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um objeto LPRECT ou [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco. Você pode passar uma estrutura de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para esse parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que definem o ponto final do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O arco desenhado usando a função é um segmento da elipse definida pelo retângulo delimitador especificado.

O ponto inicial real do arco é o ponto em que um raio desenhado do centro do retângulo delimitador por meio do ponto de partida especificado cruza a elipse. O ponto final real do arco é o ponto em que um raio desenhado do centro do retângulo delimitador por meio do ponto final especificado cruza a elipse. O arco é desenhado em uma direção no sentido anti-horário. Como um arco não é uma figura fechada, ele não é preenchido. A largura e a altura do retângulo devem ser maiores que 2 unidades e menos de 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

Desenha um arco elíptico.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*Y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*y3*<br/>
Especifica a coordenada y do ponto que define o ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*Y4*<br/>
Especifica a coordenada y do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para uma estrutura de dados [Rect](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco. Você pode passar uma estrutura de dados de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para esse parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que definem o ponto final do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco. Você pode passar uma `POINT` estrutura de dados ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função é semelhante a `CDC::Arc`, exceto que a posição atual é atualizada. Os pontos ( *X1*, *Y1*) e ( *X2*, *Y2*) especificam o retângulo delimitador. Uma elipse formada pelo retângulo delimitador fornecido define a curva do arco. O arco se estende no sentido anti-horário (a direção do arco padrão) a partir do ponto em que ele cruza a linha radial do centro do retângulo delimitador para ( *X3*, *y3*). O arco termina onde ele cruza a linha radial do centro do retângulo delimitador para ( *X4*, *Y4*). Se o ponto inicial e o ponto final forem iguais, uma elipse completa será desenhada.

Uma linha é desenhada da posição atual para o ponto inicial do arco. Se nenhum erro ocorrer, a posição atual será definida como o ponto final do arco. O arco é desenhado usando a caneta atual; Ele não está preenchido.

##  <a name="attach"></a>  CDC::Attach

Use essa função de membro para anexar um *HDC* ao `CDC` objeto.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Um contexto de dispositivo do Windows.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O *HDC* é armazenado em ambos `m_hDC`, no contexto do dispositivo de saída e `m_hAttribDC`no, no contexto do dispositivo de atributo.

##  <a name="beginpath"></a>  CDC::BeginPath

Abre um colchete de caminho no contexto do dispositivo.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Depois que um colchete de caminho é aberto, um aplicativo pode começar a chamar funções de desenho GDI para definir os pontos que estão no caminho. Um aplicativo pode fechar um colchete de abertura de caminho chamando `EndPath` a função de membro. Quando um aplicativo chama `BeginPath`, todos os caminhos anteriores são descartados.

Consulte [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) no SDK do Windows para obter uma lista das funções de desenho que definem pontos em um caminho.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

Copia um bitmap do contexto do dispositivo de origem para este contexto do dispositivo atual.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo de destino.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo de destino.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de destino e o bitmap de origem.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de destino e o bitmap de origem.

*pSrcDC*<br/>
Ponteiro para um `CDC` objeto que identifica o contexto do dispositivo do qual o bitmap será copiado. Ele deverá ser nulo se *dwRop* especificar uma operação de varredura que não inclua uma origem.

*xSrc*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do bitmap de origem.

*ySrc*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do bitmap de origem.

*dwRop*<br/>
Especifica a operação de varredura a ser executada. Os códigos de operação de rasterização definem como a GDI combina cores nas operações de saída que envolvem um pincel atual, um possível bitmap de origem e um bitmap de destino. Consulte [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) no SDK do Windows para obter uma lista dos códigos de operação de varredura para *dwRop* e suas descrições

Para obter uma lista completa de códigos de operação de varredura, consulte [sobre os códigos de operação de varredura](/windows/win32/gdi/raster-operation-codes) no SDK do Windows.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O aplicativo pode alinhar as áreas do Windows ou do cliente em limites de bytes `BitBlt` para garantir que as operações ocorram em retângulos alinhados em bytes. (Defina os sinalizadores CS_BYTEALIGNWINDOW ou CS_BYTEALIGNCLIENT ao registrar as classes de janela.)

`BitBlt`as operações em retângulos alinhados em bytes são consideravelmente `BitBlt` mais rápidas do que as operações em retângulos que não são alinhadas em bytes. Se você quiser especificar estilos de classe, como o alinhamento de byte para seu próprio contexto de dispositivo, será necessário registrar uma classe de janela em vez de depender das classes do Microsoft Foundation para fazer isso por você. Use a função global [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

O GDI transforma *nWidth* e *nHeight*, uma vez usando o contexto do dispositivo de destino e uma vez usando o contexto do dispositivo de origem. Se as extensões resultantes não corresponderem, o GDI usará a função do Windows `StretchBlt` para compactar ou ampliar o bitmap de origem, conforme necessário.

Se os bitmaps de destino, origem e padrão não tiverem o mesmo formato de cor, `BitBlt` a função converterá os bitmaps de origem e de padrão para corresponder ao destino. As cores de primeiro e segundo plano do bitmap de destino são usadas na conversão.

Quando a `BitBlt` função converte um bitmap monocromático em cor, ela define os bits brancos (1) para a cor do plano de fundo e os bits pretos (0) para a cor do primeiro plano. As cores de primeiro e segundo plano do contexto do dispositivo de destino são usadas. Para converter cor em monocromático, `BitBlt` define os pixels que correspondem à cor do plano de fundo como branco e define todos os outros pixels como preto. `BitBlt`usa as cores de primeiro e segundo plano do contexto do dispositivo de cores para converter de cor em monocromático.

Observe que nem todos os contextos de `BitBlt`dispositivo dão suporte. Para verificar se um determinado contexto de dispositivo oferece `BitBlt`suporte, use `GetDeviceCaps` a função membro e especifique o índice RasterCaps.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: CreateCompatibleDC](#createcompatibledc).

##  <a name="cdc"></a>  CDC::CDC

Constrói um objeto `CDC`.

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

Desenha uma corda (uma figura fechada limitada pela interseção de uma elipse e um segmento de linha).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador da corda (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador da corda (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador da corda (em unidades lógicas).

*Y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador da corda (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o ponto inicial da corda (em unidades lógicas).

*y3*<br/>
Especifica a coordenada y do ponto que define o ponto inicial da corda (em unidades lógicas).

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto de extremidade da corda (em unidades lógicas).

*Y4*<br/>
Especifica a coordenada y do ponto que define o ponto de extremidade da corda (em unidades lógicas).

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um objeto LPRECT ou [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o ponto inicial da corda (em unidades lógicas). Esse ponto não precisa estar exatamente na corda. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto final da corda (em unidades lógicas). Esse ponto não precisa estar exatamente na corda. Você pode passar uma estrutura de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os parâmetros ( *X1*, *Y1*) e ( *X2*, *Y2*) especificam os cantos superior esquerdo e inferior direito, respectivamente, de um retângulo que está delimitando a elipse que faz parte da corda. Os parâmetros ( *X3*, *y3*) e ( *X4*, *Y4*) especificam os pontos de extremidade de uma linha que interseccionam a elipse. A corda é desenhada usando a caneta selecionada e preenchida usando o pincel selecionado.

A figura desenhada `Chord` pela função se estende até, mas não inclui as coordenadas direita e inferior. Isso significa que a altura da figura é *Y2* - *Y1* e a largura da figura é *X2* - *X1*.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>CDC:: CloseFigure

Fecha uma figura aberta em um caminho.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função fecha a figura desenhando uma linha da posição atual para o primeiro ponto da figura (geralmente, o ponto especificado pela chamada mais recente para a `MoveTo` função membro) e conecta as linhas usando o estilo de junção de linha. Se uma figura for fechada usando a função `LineTo` de membro em vez `CloseFigure`de, as extremidades finais serão usadas para criar o canto em vez de uma junção. `CloseFigure`Só deverá ser chamado se houver um colchete de abertura no contexto do dispositivo.

Uma figura em um caminho é aberta, a menos que seja explicitamente fechada usando essa função. (Uma figura pode ser aberta mesmo que o ponto atual e o ponto inicial da figura sejam os mesmos.) Qualquer linha ou curva adicionada ao caminho depois `CloseFigure` de iniciar uma nova figura.

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

Cria um contexto de dispositivo de memória que é compatível com o dispositivo especificado pelo *PDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parâmetros

*pDC*<br/>
Um ponteiro para um contexto de dispositivo. Se o *PDC* for nulo, a função criará um contexto de dispositivo de memória compatível com a exibição do sistema.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um contexto de dispositivo de memória é um bloco de memória que representa uma superfície de exibição. Ele pode ser usado para preparar imagens na memória antes de copiá-las para a superfície de dispositivo real do dispositivo compatível.

Quando um contexto de dispositivo de memória é criado, o GDI seleciona automaticamente um bitmap de estoque monocromático 1 por 1 para ele. As funções de saída do GDI podem ser usadas com um contexto de dispositivo de memória somente se um bitmap tiver sido criado e selecionado nesse contexto.

Essa função só pode ser usada para criar contextos de dispositivo compatíveis para dispositivos que dão suporte a operações de varredura. Consulte a função de membro [CDC:: BitBlt](#bitblt) para obter informações sobre transferências de bloco de bits entre contextos de dispositivo. Para determinar se um contexto de dispositivo dá suporte a operações de varredura, consulte a funcionalidade de rasterização RC_BITBLT na função `CDC::GetDeviceCaps`membro.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

Cria um contexto de dispositivo para o dispositivo especificado.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parâmetros

*lpszDriverName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome de arquivo (sem extensão) do driver de dispositivo (por exemplo, "EPSON"). Você também pode passar um `CString` objeto para esse parâmetro.

*lpszDeviceName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do dispositivo específico a ser suportado (por exemplo, "EPSON FX-80"). O parâmetro *lpszDeviceName* será usado se o módulo der suporte a mais de um dispositivo. Você também pode passar um `CString` objeto para esse parâmetro.

*lpszOutput*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do arquivo ou do dispositivo para o meio de saída física (porta de arquivo ou saída). Você também pode passar um `CString` objeto para esse parâmetro.

*lpInitData*<br/>
Aponta para uma `DEVMODE` estrutura que contém dados de inicialização específicos do dispositivo para o driver de dispositivo. A função `DocumentProperties` do Windows recupera essa estrutura preenchida para um determinado dispositivo. O parâmetro *lpInitData* deverá ser nulo se o driver de dispositivo for usar a inicialização padrão (se houver) especificada pelo usuário por meio do painel de controle.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A impressão. O arquivo de cabeçalho H será necessário se a estrutura [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) for usada.

Os nomes de dispositivo seguem estas convenções: um dois pontos finais (:) é recomendado, mas opcional. O Windows retira os dois-pontos de terminação para que um nome de dispositivo que termina com dois-pontos seja mapeado para a mesma porta com o mesmo nome sem dois-pontos. Os nomes de driver e porta não devem conter espaços à esquerda ou à direita. As funções de saída do GDI não podem ser usadas com contextos de informações.

##  <a name="createic"></a>  CDC::CreateIC

Cria um contexto de informações para o dispositivo especificado.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parâmetros

*lpszDriverName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome de arquivo (sem extensão) do driver de dispositivo (por exemplo, "EPSON"). Você pode passar um `CString` objeto para esse parâmetro.

*lpszDeviceName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do dispositivo específico a ser suportado (por exemplo, "EPSON FX-80"). O parâmetro *lpszDeviceName* será usado se o módulo der suporte a mais de um dispositivo. Você pode passar um `CString` objeto para esse parâmetro.

*lpszOutput*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do arquivo ou do dispositivo para a mídia de saída física (arquivo ou porta). Você pode passar um `CString` objeto para esse parâmetro.

*lpInitData*<br/>
Aponta para dados de inicialização específicos do dispositivo para o driver de dispositivo. O parâmetro *lpInitData* deverá ser nulo se o driver de dispositivo for usar a inicialização padrão (se houver) especificada pelo usuário por meio do painel de controle. Consulte `CreateDC` para obter o formato de dados para inicialização específica do dispositivo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero, se for bem-sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto de informações fornece uma maneira rápida de obter informações sobre o dispositivo sem criar um contexto de dispositivo.

Os nomes de dispositivo seguem estas convenções: um dois pontos finais (:) é recomendado, mas opcional. O Windows retira os dois-pontos de terminação para que um nome de dispositivo que termina com dois-pontos seja mapeado para a mesma porta com o mesmo nome sem dois-pontos. Os nomes de driver e porta não devem conter espaços à esquerda ou à direita. As funções de saída do GDI não podem ser usadas com contextos de informações.

##  <a name="deletedc"></a>  CDC::DeleteDC

Em geral, não chame essa função; o destruidor fará isso para você.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for concluída com êxito; caso contrário, 0.

### <a name="remarks"></a>Comentários

A `DeleteDC` função membro exclui os contextos de dispositivo do Windows que estão `m_hDC` associados ao no `CDC` objeto atual. Se esse `CDC` objeto for o último contexto de dispositivo ativo para um determinado dispositivo, o dispositivo será notificado e todos os recursos de armazenamento e sistema usados pelo dispositivo serão liberados.

Um aplicativo não deve chamar `DeleteDC` se os objetos foram selecionados no contexto do dispositivo. Os objetos devem primeiro ser selecionados fora do contexto do dispositivo antes de serem excluídos.

Um aplicativo não deve excluir um contexto de dispositivo cujo identificador foi obtido chamando [CWnd:: GetDC](../../mfc/reference/cwnd-class.md#getdc). Em vez disso, ele deve chamar [CWnd:: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) para liberar o contexto do dispositivo. As classes [CClientDC](../../mfc/reference/cclientdc-class.md) e [CWindowDC](../../mfc/reference/cwindowdc-class.md) são fornecidas para encapsular essa funcionalidade.

A `DeleteDC` função é geralmente usada para excluir contextos de dispositivo criados com [CreateDC](#createdc), [createal](#createic)ou [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CPrintDialog:: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

Chamado automaticamente pelo `CWinApp` manipulador de tempo ocioso `hDC`, `DeleteTempMap` exclui todos os objetos `CDC` temporários criados `FromHandle`pelo, mas não destrói os identificadores de contexto de dispositivo temporariamente associados ao`CDC` objetos.

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

Chame `m_hDC` essa função para desanexar (o contexto do dispositivo de saída) `CDC` do objeto e `m_hDC` defina `m_hAttribDC` e como NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Valor de retorno

Um contexto de dispositivo do Windows.

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

Use essa função quando você fornecer tamanhos de HIMETRIC para OLE, convertendo pixels em HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

Se o modo de mapeamento do objeto de contexto do dispositivo for MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, a conversão será baseada no número de pixels na polegada física. Se o modo de mapeamento for um dos outros modos não restritos (por exemplo, MM_TEXT), a conversão será baseada no número de pixels na polegada lógica.

##  <a name="dptolp"></a>  CDC::DPtoLP

Converte unidades de dispositivo em unidades lógicas.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas de [ponto](/windows/win32/api/windef/ns-windef-point) ou objetos [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
O número de pontos na matriz.

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) . Esse parâmetro é usado para o caso simples de converter um retângulo de pontos de dispositivo em pontos lógicos.

*lpSize*<br/>
Aponta para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

A função mapeia as coordenadas de cada ponto, ou dimensão de um tamanho, do sistema de coordenadas do dispositivo para o sistema de coordenadas lógica da GDI. A conversão depende do modo de mapeamento atual e das configurações das origens e das extensões da janela e do visor do dispositivo.

##  <a name="draw3drect"></a>  CDC::Draw3dRect

Chame essa função de membro para desenhar um retângulo tridimensional.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

*clrTopLeft*<br/>
Especifica a cor dos lados superior e esquerdo do retângulo tridimensional.

*clrBottomRight*<br/>
Especifica a cor dos lados inferior e direito do retângulo tridimensional.

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo tridimensional.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo tridimensional.

*cx*<br/>
Especifica a largura do retângulo tridimensional.

*cy*<br/>
Especifica a altura do retângulo tridimensional.

### <a name="remarks"></a>Comentários

O retângulo será desenhado com os lados superior e esquerdo na cor especificada por *clrTopLeft* e os lados inferior e direito na cor especificada por *clrBottomRight*.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

Chame essa função de membro repetidamente para redesenhar um retângulo de arrastar.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica as coordenadas lógicas de um retângulo — nesse caso, a posição final do retângulo que está sendo redesenhado.

*size*<br/>
Especifica o deslocamento do canto superior esquerdo da borda externa para o canto superior esquerdo da borda interna (ou seja, a espessura da borda) de um retângulo de.

*lpRectLast*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica as coordenadas lógicas da posição de um retângulo — nesse caso, a posição original do retângulo que está sendo redesenhado.

*sizeLast*<br/>
Especifica o deslocamento do canto superior esquerdo da borda externa para o canto superior esquerdo da borda interna (ou seja, a espessura da borda) do retângulo original que está sendo redesenhado.

*pBrush*<br/>
Ponteiro para um objeto de pincel. Defina como nulo para usar o pincel de meio-tom padrão.

*pBrushLast*<br/>
Ponteiro para o último objeto de pincel usado. Defina como nulo para usar o pincel de meio-tom padrão.

### <a name="remarks"></a>Comentários

Chame-o em um loop à medida que você exemplo de posição do mouse para fornecer comentários visuais. Quando você chama `DrawDragRect`, o retângulo anterior é apagado e um novo é desenhado. Por exemplo, como o usuário arrasta um retângulo pela tela, `DrawDragRect` apagará o retângulo original e redesenhará um novo em sua nova posição. Por padrão, `DrawDragRect` desenha o retângulo usando um pincel de meio-tom para eliminar a cintilação e criar a aparência de um retângulo de movimentação suave.

Na primeira vez que você `DrawDragRect`chama, o parâmetro *lpRectLast* deve ser nulo.

##  <a name="drawedge"></a>  CDC::DrawEdge

Chame essa função de membro para desenhar as bordas de um retângulo do tipo e do estilo especificados.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Um ponteiro para uma `RECT` estrutura que contém as coordenadas lógicas do retângulo.

*nEdge*<br/>
Especifica o tipo de borda interna e externa a ser desenhada. Esse parâmetro deve ser uma combinação de um sinalizador de borda interna e um sinalizador de borda externa. Consulte [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) no SDK do Windows para obter uma tabela dos tipos de parâmetro.

*nFlags*<br/>
Os sinalizadores que especificam o tipo de borda a ser desenhada. Consulte `DrawEdge` na SDK do Windows para obter uma tabela dos valores do parâmetro. Para linhas diagonais, os sinalizadores BF_RECT especificam o ponto de extremidade do vetor limitado pelo parâmetro Rectangle.

### <a name="return-value"></a>Valor de retorno

Diferente de zero, se for bem-sucedido; caso contrário, 0.

##  <a name="drawescape"></a>  CDC::DrawEscape

Acessa os recursos de desenho de uma exibição de vídeo que não estão diretamente disponíveis por meio da GDI (Graphics Device Interface).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parâmetros

*nEscape*<br/>
Especifica a função de escape a ser executada.

*nInputSize*<br/>
Especifica o número de bytes de dados apontados pelo parâmetro *lpszInputData* .

*lpszInputData*<br/>
Aponta para a estrutura de entrada necessária para o escape especificado.

### <a name="return-value"></a>Valor de retorno

Especifica o resultado da função. Maior que zero se for bem-sucedido, exceto para o escape QUERYESCSUPPORT Draw, que verifica apenas a implementação; ou zero se o escape não for implementado; ou menor que zero se ocorreu um erro.

### <a name="remarks"></a>Comentários

Quando um aplicativo chama `DrawEscape`, os dados identificados por *nInputSize* e *lpszInputData* são passados diretamente para o driver de vídeo especificado.

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

Desenha um retângulo no estilo usado para indicar que o retângulo tem o foco.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica as coordenadas lógicas do retângulo a ser desenhado.

### <a name="remarks"></a>Comentários

Como essa é uma função XOR booliana, chamar essa função uma segunda vez com o mesmo retângulo remove o retângulo da exibição. O retângulo desenhado por esta função não pode ser rolado. Para rolar uma área que contém um retângulo desenhado por essa função, primeiro `DrawFocusRect` chame para remover o retângulo da exibição, role a área e, em seguida, `DrawFocusRect` chame novamente para desenhar o retângulo na nova posição.

> [!CAUTION]
> `DrawFocusRect`funciona somente no modo MM_TEXT. Em outros modos, essa função não desenha o retângulo de foco corretamente, mas não retorna valores de erro.

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

Chame essa função de membro para desenhar um controle frame do tipo e do estilo especificados.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Um ponteiro para uma `RECT` estrutura que contém as coordenadas lógicas do retângulo.

*nType*<br/>
Especifica o tipo de controle de quadro a ser desenhado. Consulte o parâmetro *uType* em [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) no SDK do Windows para obter uma lista dos possíveis valores do parâmetro.

*nState*<br/>
Especifica o estado inicial do controle de quadro. Pode ser um ou mais dos valores descritos para o parâmetro *uState* no `DrawFrameControl` no SDK do Windows. Use o valor *NSTATE* DFCS_ADJUSTRECT para ajustar o retângulo delimitador para excluir a borda ao redor do botão de ação.

### <a name="return-value"></a>Valor de retorno

Diferente de zero, se for bem-sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

Em vários casos, o *nState* depende do parâmetro *ndeclarações* . A lista a seguir mostra a relação entre os quatro valores *ndeclarações* e *nState*:

- DFC_BUTTON

    - Botão de três Estados do DFCS_BUTTON3STATE

    - Caixa de seleção DFCS_BUTTONCHECK

    - Botão de ação DFCS_BUTTONPUSH

    - Botão de opção DFCS_BUTTONRADIO

    - Imagem DFCS_BUTTONRADIOIMAGE para botão de opção (imagem de necessidades não quadradas)

    - Máscara de DFCS_BUTTONRADIOMASK para botão de opção (máscara de necessidades não quadradas)

- DFC_CAPTION

    - Botão de fechamento do DFCS_CAPTIONCLOSE

    - Botão de ajuda do DFCS_CAPTIONHELP

    - Botão Maximizar DFCS_CAPTIONMAX

    - Botão de minimizar DFCS_CAPTIONMIN

    - Botão de restauração do DFCS_CAPTIONRESTORE

- DFC_MENU

    - Seta do submenu DFCS_MENUARROW

    - DFCS_MENUBULLET com marcador

    - DFCS_MENUCHECK Marca de seleção

- DFC_SCROLL

    - Barra de rolagem da caixa de combinação DFCS_SCROLLCOMBOBOX

    - DFCS_SCROLLDOWN seta para baixo da barra de rolagem

    - DFCS_SCROLLLEFT Seta para a esquerda da barra de rolagem

    - DFCS_SCROLLRIGHT seta para a direita da barra de rolagem

    - Alça de tamanho do DFCS_SCROLLSIZEGRIP no canto inferior direito da janela

    - DFCS_SCROLLUP seta para cima da barra de rolagem

### <a name="example"></a>Exemplo

Esse código desenha a garra de tamanho no canto inferior direito da sua janela. É apropriado para o `OnPaint` manipulador de uma caixa de diálogo, que não tem estilos e normalmente não contém outros controles (como uma barra de status) que possam dar uma garra de tamanho.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

Desenha um ícone no dispositivo representado pelo objeto atual `CDC` .

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do ícone.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do ícone.

*hIcon*<br/>
Identifica o identificador do ícone a ser desenhado.

*point*<br/>
Especifica as coordenadas x-e y lógicas do canto superior esquerdo do ícone. Você pode passar uma estrutura de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for concluída com êxito; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função coloca o canto superior esquerdo do ícone no local especificado por *x* e *y*. O local está sujeito ao modo de mapeamento atual do contexto do dispositivo.

O recurso de ícone deve ter sido carregado anteriormente usando as funções `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`ou `CWinApp::LoadOEMIcon`. O `MM_TEXT` modo de mapeamento deve ser selecionado antes de usar essa função.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CWnd:: Isicony](../../mfc/reference/cwnd-class.md#isiconic).

##  <a name="drawstate"></a>  CDC::DrawState

Chame essa função de membro para exibir uma imagem e aplicar um efeito visual para indicar um estado, como um estado desabilitado ou padrão.

> [!NOTE]
>  Para todos os Estados *nalização* , exceto DSS_NORMAL, a imagem é convertida em monocromático antes que o efeito visual seja aplicado.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parâmetros

*pt*<br/>
Especifica o local da imagem.

*size*<br/>
Especifica o tamanho da imagem.

*hBitmap*<br/>
Um identificador para um bitmap.

*nFlags*<br/>
Sinalizadores que especificam o tipo e o estado da imagem. Consulte [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) no SDK do Windows para os possíveis tipos e Estados de *nFlags* .

*hBrush*<br/>
Um identificador para um pincel.

*pBitmap*<br/>
Um ponteiro para um objeto CBitmap.

*pBrush*<br/>
Um ponteiro para um objeto CBrush.

*hIcon*<br/>
Um identificador para um ícone.

*lpszText*<br/>
Um ponteiro para texto.

*bPrefixText*<br/>
Texto que pode conter um mnemônico de acelerador. O parâmetro *lData* especifica o endereço da cadeia de caracteres e o parâmetro *nTextLen* especifica o comprimento. Se *nTextLen* for 0, a cadeia de caracteres será considerada como terminada em nulo.

*nTextLen*<br/>
Comprimento da cadeia de texto apontada por *lpszText*. Se *nTextLen* for 0, a cadeia de caracteres será considerada como terminada em nulo.

*lpDrawProc*<br/>
Um ponteiro para uma função de retorno de chamada usada para renderizar uma imagem. Esse parâmetro será necessário se o tipo de imagem em *nFlags* for DST_COMPLEX. É opcional e pode ser NULL se o tipo de imagem for DST_TEXT. Para todos os outros tipos de imagem, esse parâmetro é ignorado. Para obter mais informações sobre a função de retorno de chamada, consulte a função [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) no SDK do Windows.

*lData*<br/>
Especifica informações sobre a imagem. O significado desse parâmetro depende do tipo de imagem.

### <a name="return-value"></a>Valor de retorno

Diferente de zero, se for bem-sucedido; caso contrário, 0.

##  <a name="drawtext"></a>CDC::D rawText

Chame essa função de membro para formatar texto no retângulo fornecido. Para especificar opções de formatação adicionais, use [CDC::D rawtextex](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhada. Se *nCount* for-1, a cadeia de caracteres deverá ser terminada em nulo.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* for-1, *lpszString* será considerado um ponteiro longo para uma cadeia de caracteres terminada em nulo e `DrawText` calculará automaticamente a contagem de caracteres.

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contém o retângulo (em coordenadas lógicas) no qual o texto deve ser formatado.

*str*<br/>
Um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que contém os caracteres especificados a serem desenhados.

*nFormat*<br/>
Especifica o método de formatação do texto. Pode ser qualquer combinação dos valores descritos para o parâmetro *uFormat* em [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) no SDK do Windows. (Combine usando o operador OR

> [!NOTE]
>  Algumas combinações de sinalizador *uFormat* podem fazer com que a cadeia de caracteres passada seja modificada. O uso de DT_MODIFYSTRING com DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS pode fazer com que a cadeia de caracteres seja modificada, `CString` causando uma asserção na substituição. Os valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP e DT_NOPREFIX não podem ser usados com o valor DT_TABSTOP.

### <a name="return-value"></a>Valor de retorno

A altura do texto se a função for bem-sucedida.

### <a name="remarks"></a>Comentários

Ele formata o texto expandindo as guias para os espaços apropriados, alinhando o texto à esquerda, à direita ou no centro do retângulo fornecido e dividindo o texto em linhas que se enquadram dentro do retângulo fornecido. O tipo de formatação é especificado por *nFormat*.

Essa função de membro usa a fonte selecionada, a cor do texto e a cor do plano de fundo do contexto do dispositivo para desenhar o texto. A menos que o formato DT_NOCLIP seja `DrawText` usado, o cortará o texto para que o texto não apareça fora do retângulo fornecido. É presumida que toda a formatação tenha várias linhas, a menos que o formato DT_SINGLELINE seja fornecido.

Se a fonte selecionada for muito grande para o retângulo especificado, a `DrawText` função de membro não tentará substituir uma fonte menor.

Se o sinalizador DT_CALCRECT for especificado, o retângulo especificado por *lpRect* será atualizado para refletir a largura e a altura necessárias para desenhar o texto.

Se o sinalizador de alinhamento de texto TA_UPDATECP tiver sido definido (consulte [CDC:: SetTextAlign](#settextalign)) `DrawText` , o exibirá o texto que começa na posição atual, e não à esquerda do retângulo especificado. `DrawText`não quebrará o texto quando o sinalizador TA_UPDATECP tiver sido definido (ou seja, o sinalizador DT_WORDBREAK não terá nenhum efeito).

A cor do texto pode ser definida por [CDC:: SetTextColor](#settextcolor).

##  <a name="drawtextex"></a>  CDC::DrawTextEx

Formata o texto no retângulo fornecido.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhada. Se *nCount* for-1, a cadeia de caracteres deverá ser terminada como nula.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* for-1, *lpszString* será considerado um ponteiro longo para uma cadeia de caracteres terminada em nulo e `DrawText` calculará automaticamente a contagem de caracteres.

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contém o retângulo (em coordenadas lógicas) no qual o texto deve ser formatado.

*str*<br/>
Um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que contém os caracteres especificados a serem desenhados.

*nFormat*<br/>
Especifica o método de formatação do texto. Pode ser qualquer combinação dos valores descritos para o parâmetro *uFormat* em [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) no SDK do Windows. (Combine usando **o operador OR**

> [!NOTE]
>  Algumas combinações de sinalizador *uFormat* podem fazer com que a cadeia de caracteres passada seja modificada. O uso de DT_MODIFYSTRING com DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS pode fazer com que a cadeia de caracteres seja modificada, `CString` causando uma asserção na substituição. Os valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP e DT_NOPREFIX não podem ser usados com o valor DT_TABSTOP.

*lpDTParams*<br/>
Ponteiro para uma estrutura [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) que especifica opções de formatação adicionais. Esse parâmetro pode ser nulo.

### <a name="remarks"></a>Comentários

Ele formata o texto expandindo as guias para os espaços apropriados, alinhando o texto à esquerda, à direita ou no centro do retângulo fornecido e dividindo o texto em linhas que se enquadram dentro do retângulo fornecido. O tipo de formatação é especificado por *nFormat* e *lpDTParams*. Para obter mais informações, consulte [CDC::D rawtext](#drawtext) e [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) no SDK do Windows.

A cor do texto pode ser definida por [CDC:: SetTextColor](#settextcolor).

##  <a name="ellipse"></a>  CDC::Ellipse

Desenha uma elipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo delimitador da elipse.

*y1*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo delimitador da elipse.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo delimitador da elipse.

*Y2*<br/>
Especifica a coordenada y lógica do canto inferior direito do retângulo delimitador da elipse.

*lpRect*<br/>
Especifica o retângulo delimitador da elipse. Você também pode passar um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O centro da elipse é o centro do retângulo delimitador especificado por *X1*, *Y1*, *X2*e *Y2*ou *lpRect*. A elipse é desenhada com a caneta atual e seu interior é preenchido com o pincel atual.

A figura desenhada por essa função se estende até, mas não inclui, as coordenadas direita e inferior. Isso significa que a altura da figura é *Y2* - *Y1* e a largura da figura é *X2* - *X1*.

Se a largura ou a altura do retângulo delimitador for 0, nenhuma elipse será desenhada.

##  <a name="enddoc"></a>  CDC::EndDoc

Finaliza um trabalho de impressão iniciado por uma chamada para a função membro [StartDoc](#startdoc) .

```
int EndDoc();
```

### <a name="return-value"></a>Valor de retorno

Maior ou igual a 0 se a função for bem-sucedida ou um valor negativo se ocorrer um erro.

### <a name="remarks"></a>Comentários

Essa função de membro substitui o escape de impressora ENDDOC e deve ser chamada imediatamente após a conclusão de um trabalho de impressão bem-sucedido.

Se um aplicativo encontrar um erro de impressão ou uma operação de impressão cancelada, ele não deverá tentar encerrar a operação `EndDoc` usando o ou o [AbortDoc](#abortdoc). O GDI encerra automaticamente a operação antes de retornar o valor do erro.

Essa função não deve ser usada dentro de metaarquivos.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: StartDoc](#startdoc).

##  <a name="endpage"></a>  CDC::EndPage

Informa ao dispositivo que o aplicativo terminou de gravar em uma página.

```
int EndPage();
```

### <a name="return-value"></a>Valor de retorno

Maior ou igual a 0 se a função for bem-sucedida ou um valor negativo se ocorrer um erro.

### <a name="remarks"></a>Comentários

Essa função de membro normalmente é usada para direcionar o driver de dispositivo a avançar para uma nova página.

Essa função de membro substitui o escape de impressora NEWFRAME. Ao contrário de NEWFRAME, essa função é sempre chamada após a impressão de uma página.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: StartDoc](#startdoc).

##  <a name="endpath"></a>  CDC::EndPath

Fecha um colchete de caminho e seleciona o caminho definido pelo colchete no contexto do dispositivo.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: BeginPath](#beginpath).

##  <a name="enumobjects"></a>CDC:: EnumObjects

Enumera as canetas e os pincéis disponíveis em um contexto de dispositivo.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parâmetros

*nObjectType*<br/>
Especifica o tipo de objeto. Ele pode ter os valores OBJ_BRUSH ou OBJ_PEN.

*lpfn*<br/>
É o endereço de instância de procedimento da função de retorno de chamada fornecida pelo aplicativo. Consulte a seção "Comentários" abaixo.

*lpData*<br/>
Aponta para os dados fornecidos pelo aplicativo. Os dados são passados para a função de retorno de chamada junto com as informações do objeto.

### <a name="return-value"></a>Valor de retorno

Especifica o último valor retornado pela [função de retorno de chamada](callback-functions-used-by-mfc.md#enum_objects). Seu significado é definido pelo usuário.

### <a name="remarks"></a>Comentários

Para cada objeto de um determinado tipo, a função de retorno de chamada que você passa é chamada com as informações para esse objeto. O sistema chama a função de retorno de chamada até que não haja mais objetos ou a função de retorno de chamada retorna 0.

Observe que os novos recursos do Microsoft C++ Visual permitem que você use uma função comum como a função `EnumObjects`passada para. O endereço passado para `EnumObjects` é um ponteiro para uma função exportada com **exportação** e com a Convenção de chamada do Pascal. Em aplicativos do modo proteger, você não precisa criar essa função com a função MakeProcInstance do Windows ou liberar a função após o uso com a função FreeProcInstance do Windows.

Você também não precisa exportar o nome da função em uma instrução **Exports** no arquivo de definição de módulo do aplicativo. Em vez disso, você pode usar o modificador da função de **exportação** , como em

**exportação de retorno de chamada int** AFunction **(LPSTR**, **LPSTR);**

para fazer com que o compilador emita o registro de exportação adequado para exportação por nome sem alias. Isso funciona para a maioria das necessidades. Para alguns casos especiais, como a exportação de uma função por ordinal ou alias da exportação, você ainda precisa usar uma instrução **Exports** em um arquivo de definição de módulo.

Para compilar programas do Microsoft Foundation, você normalmente usará as opções do compilador/GA e/GEs. A opção de compilador/GW não é usada com as classes do Microsoft Foundation. (Se você usar a função `MakeProcInstance`do Windows, será necessário converter explicitamente o ponteiro de função retornado de FARPROC para o tipo necessário nesta API.) As interfaces de registro de retorno de chamada agora são de tipo seguro (você deve passar um ponteiro de função que aponta para o tipo certo de função para o retorno de chamada específico).

Observe também que todas as funções de retorno de chamada devem interceptar exceções do Microsoft Foundation antes de retornar ao Windows, pois as exceções não podem ser lançadas em limites de retorno de chamada Para obter mais informações sobre exceções, consulte o artigo [exceções](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

Essa função de membro é praticamente obsoleta para a programação Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parâmetros

*nEscape*<br/>
Especifica a função de escape a ser executada.

Para obter uma lista completa de funções de escape, consulte [escape](/windows/win32/api/wingdi/nf-wingdi-escape) no SDK do Windows.

*nCount*<br/>
Especifica o número de bytes de dados apontados por *lpszInData*.

*lpszInData*<br/>
Aponta para a estrutura de dados de entrada necessária para este escape.

*lpOutData*<br/>
Aponta para a estrutura que deve receber a saída deste escape. O parâmetro *lpOutData* será nulo se nenhum dado for retornado.

*nInputSize*<br/>
Especifica o número de bytes de dados apontados pelo parâmetro *lpszInputData* .

*lpszInputData*<br/>
Aponta para a estrutura de entrada necessária para o escape especificado.

*nOutputSize*<br/>
Especifica o número de bytes de dados apontados pelo parâmetro *lpszOutputData* .

*lpszOutputData*<br/>
Aponta para a estrutura que recebe a saída deste escape. Esse parâmetro deverá ser nulo se nenhum dado for retornado.

### <a name="return-value"></a>Valor de retorno

Um valor positivo será retornado se a função for bem-sucedida, exceto para o escape QUERYESCSUPPORT, que verifica apenas a implementação. Zero será retornado se o escape não for implementado. Um valor negativo será retornado se ocorrer um erro. Estes são os valores de erro comuns:

- Erro geral de SP_ERROR.

- SP_OUTOFDISK espaço em disco insuficiente atualmente está disponível para o spool e não haverá mais espaço disponível.

- SP_OUTOFMEMORY não há memória suficiente disponível para o spool.

- O usuário SP_USERABORT finalizou o trabalho por meio do Gerenciador de impressão.

### <a name="remarks"></a>Comentários

Dos escapes de impressora originais, somente QUERYESCSUPPORT tem suporte para aplicativos Win32. Todos os outros escapes de impressora estão obsoletos e têm suporte apenas para compatibilidade com aplicativos de 16 bits.

Para a programação Win32 `CDC` , o agora fornece seis funções de membro que substituem seus escapes de impressora correspondentes:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Além disso, [CDC:: GetDeviceCaps](#getdevicecaps) dá suporte a índices Win32 que substituem outros escapes de impressora. Consulte [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) no SDK do Windows para obter mais informações.

Essa função de membro permite que os aplicativos acessem recursos de um dispositivo específico que não estão diretamente disponíveis por meio do GDI.

Use a primeira versão se seu aplicativo usar valores de escape predefinidos. Use a segunda versão se seu aplicativo definir valores de escape privados. Consulte [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) no SDK do Windows para obter mais informações sobre a segunda versão.

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

Cria uma nova região de recorte que consiste na região de recorte existente menos o retângulo especificado.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y1*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo.

*Y2*<br/>
Especifica a coordenada y lógica do canto inferior direito do retângulo.

*lpRect*<br/>
Especifica o retângulo. Também pode ser um `CRect` objeto.

### <a name="return-value"></a>Valor de retorno

Especifica o novo tipo de região de recorte. Pode ser qualquer um dos seguintes valores:

- COMPLEXREGION a região tem bordas sobrepostas.

- ERRO nenhuma região foi criada.

- NULLREGION a região está vazia.

- SIMPLEREGION a região não tem bordas sobrepostas.

### <a name="remarks"></a>Comentários

A largura do retângulo, especificada pelo valor absoluto de *X2* - *X1*, não deve exceder 32.767 unidades. Esse limite também se aplica à altura do retângulo.

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

Impede o desenho em áreas inválidas de uma janela, excluindo uma região atualizada na janela da região de recorte `CDC` associada ao objeto.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parâmetros

*pWnd*<br/>
Aponta para o objeto de janela cuja janela está sendo atualizada.

### <a name="return-value"></a>Valor de retorno

O tipo de região excluída. Pode ser qualquer um dos seguintes valores:

- COMPLEXREGION a região tem bordas sobrepostas.

- ERRO nenhuma região foi criada.

- NULLREGION a região está vazia.

- SIMPLEREGION a região não tem bordas sobrepostas.

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

Preenche uma área da superfície de exibição com o pincel atual.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto em que o preenchimento começa.

*y*<br/>
Especifica a coordenada y lógica do ponto em que o preenchimento começa.

*crColor*<br/>
Especifica a cor do limite ou da área a ser preenchida. A interpretação de *crColor* depende do valor de *nFillType*.

*nFillType*<br/>
Especifica o tipo de preenchimento de inundação a ser executado. Deve ser um dos seguintes valores:

- FLOODFILLBORDER a área de preenchimento está limitada pela cor especificada por *crColor*. Esse estilo é idêntico ao preenchimento realizado pelo `FloodFill`.

- FLOODFILLSURFACE a área de preenchimento é definida pela cor especificada por *crColor*. O preenchimento continua para fora em todas as direções, contanto que a cor seja encontrada. Esse estilo é útil para preencher áreas com limites multicoloridos.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0 se o preenchimento não puder ser concluído, se o ponto fornecido tiver a cor de limite especificada por *crColor* (se FLOODFILLBORDER foi solicitado), se o ponto fornecido não tiver a cor especificada por *CRCOLOR* (se FLOODFILLSURFACE foi solicitado), ou se o ponto estiver fora da região de recorte.

### <a name="remarks"></a>Comentários

Essa função de membro oferece mais flexibilidade `FloodFill` do que porque você pode especificar um tipo de preenchimento em *nFillType*.

Se *nFillType* for definido como FLOODFILLBORDER, a área será considerada completamente limitada pela cor especificada por *crColor*. A função começa no ponto especificado por *x* e *y* e preenche todas as direções para o limite de cor.

Se *nFillType* for definido como FLOODFILLSURFACE, a função começará no ponto especificado por *x* e *y* e continuará em todas as direções, preenchendo todas as áreas adjacentes que contêm a cor especificada por *crColor*.

Somente os contextos de dispositivo de memória e dispositivos que dão suporte à `ExtFloodFill`tecnologia de exibição de varredura. Para obter mais informações, consulte a função membro [GetDeviceCaps](#getdevicecaps) .

##  <a name="exttextout"></a>  CDC::ExtTextOut

Chame essa função de membro para gravar uma cadeia de caracteres em uma região retangular usando a fonte atualmente selecionada.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x-a célula de caractere para o primeiro caractere na cadeia de caracteres especificada.

*y*<br/>
Especifica a coordenada y lógica da parte superior da célula de caracteres para o primeiro caractere na cadeia de caracteres especificada.

*nOptions*<br/>
Especifica o tipo de retângulo. Esse parâmetro pode ser um, ambos ou nenhum dos seguintes valores:

- ETO_CLIPPED especifica que o texto é recortado no retângulo.

- ETO_OPAQUE especifica que a cor do plano de fundo atual preenche o retângulo. (Você pode definir e consultar a cor do plano de fundo atual com as funções de membro [SetBkColor](#setbkcolor) e [GetBkColor](#getbkcolor) ).

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) que determina as dimensões do retângulo. Esse parâmetro pode ser nulo. Você também pode passar um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

*lpszString*<br/>
Aponta para a cadeia de caracteres especificada a ser desenhada. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*lpDxWidths*<br/>
Aponta para uma matriz de valores que indica a distância entre as origens de células de caracteres adjacentes. Por exemplo, *lpDxWidths*[ *i*] unidades lógicas separará as origens da célula de caractere *i* e caractere célula *i* + 1. Se *lpDxWidths* for nulo, `ExtTextOut` o usará o espaçamento padrão entre os caracteres.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem desenhados.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A região retangular pode ser opaca (preenchida com a cor do plano de fundo atual) e pode ser uma região de recorte.

Se *nOptions* for 0 e *lpRect* for NULL, a função gravará o texto no contexto do dispositivo sem usar uma região retangular. Por padrão, a posição atual não é usada nem atualizada pela função. Se um aplicativo precisar atualizar a posição atual quando ele chamar `ExtTextOut`, o aplicativo poderá chamar a função de membro`CDC` [SetTextAlign](#settextalign) com *nFlags* definido como TA_UPDATECP. Quando esse sinalizador é definido, o Windows ignora *x* e *y* nas chamadas subsequentes `ExtTextOut` para e usa a posição atual em vez disso. Quando um aplicativo usa TA_UPDATECP para atualizar a posição atual, `ExtTextOut` o define a posição atual para o final da linha anterior de texto ou para a posição especificada pelo último elemento da matriz apontada por *lpDxWidths*, o que for grande.

##  <a name="fillpath"></a>  CDC::FillPath

Fecha as figuras abertas no caminho atual e preenche o interior do caminho usando o pincel atual e o modo de preenchimento de polígono.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Depois que seu interior é preenchido, o caminho é descartado do contexto do dispositivo.

##  <a name="fillrect"></a>  CDC::FillRect

Chame essa função de membro para preencher um determinado retângulo usando o pincel especificado.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) que contém as coordenadas lógicas do retângulo a ser preenchido. Você também pode passar um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para esse parâmetro.

*pBrush*<br/>
Identifica o pincel usado para preencher o retângulo.

### <a name="remarks"></a>Comentários

A função preenche o retângulo completo, incluindo as bordas esquerda e superior, mas não preenche as bordas direita e inferior.

O pincel precisa ser criado usando as funções de membro [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)e [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou recuperado pela função do `GetStockObject` Windows.

Ao preencher o retângulo especificado, `FillRect` não inclui os lados direito e inferior do retângulo. O GDI preenche um retângulo até, mas não inclui, a coluna direita e a linha inferior, independentemente do modo de mapeamento atual. `FillRect`compara os `top`valores dos membros `left`, `bottom`, e `right` do retângulo especificado. Se `bottom` for menor ou igual a `top`, ou se `right` for menor ou igual a `left`, o retângulo não será desenhado.

`FillRect`é semelhante a [CDC:: FillSolidRect](#fillsolidrect); no entanto, `FillRect` o usa um pincel e, portanto, pode ser usado para preencher um retângulo com uma cor sólida, uma cor pontilhada, pincéis hachurados ou um padrão. `FillSolidRect`usa apenas cores sólidas (indicadas por um parâmetro COLORREF). `FillRect`geralmente é mais lento do `FillSolidRect`que.

##  <a name="fillrgn"></a>  CDC::FillRgn

Preenche a região especificada por *pRgn* com o pincel especificado por *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Um ponteiro para a região a ser preenchida. As coordenadas para a região determinada são especificadas em unidades lógicas.

*pBrush*<br/>
Identifica o pincel a ser usado para preencher a região.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O pincel deve ser criado usando as funções `CBrush` `CreateHatchBrush`de membro, `CreatePatternBrush`, `CreateSolidBrush`ou ser recuperado pelo `GetStockObject`.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CRgn:: CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

Chame essa função de membro para preencher o retângulo fornecido com a cor sólida especificada.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para uma estrutura de dados [Rect](/windows/win32/api/windef/ns-windef-rect) ou um `CRect` objeto para esse parâmetro.

*CLR* Especifica a cor a ser usada para preencher o retângulo.

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo de destino.

*cx*<br/>
Especifica a largura do retângulo.

*cy*<br/>
Especifica a altura do retângulo.

### <a name="remarks"></a>Comentários

`FillSolidRect`é muito semelhante a [CDC:: FillRect](#fillrect); no entanto, `FillSolidRect` o usa apenas cores sólidas (indicadas pelo parâmetro `FillRect` COLORREF), enquanto usa um pincel e, portanto, pode ser usado para preencher um retângulo com uma cor sólida, uma cor pontilhada, pincéis hachurados ou um padrão. `FillSolidRect`geralmente é mais rápido `FillRect`do que.

> [!NOTE]
>  Quando você chama `FillSolidRect`, a cor do plano de fundo, que foi definida anteriormente usando [SetBkColor](#setbkcolor), é definida como a cor indicada pelo *CLR*.

##  <a name="flattenpath"></a>  CDC::FlattenPath

Transforma todas as curvas no caminho selecionado no contexto do dispositivo atual e ativa cada curva em uma sequência de linhas.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="floodfill"></a>  CDC::FloodFill

Preenche uma área da superfície de exibição com o pincel atual.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto em que o preenchimento começa.

*y*<br/>
Especifica a coordenada y lógica do ponto em que o preenchimento começa.

*crColor*<br/>
Especifica a cor do limite.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0 será retornado se o preenchimento não puder ser concluído, o ponto determinado tiver a cor de limite especificada por *crColor*ou se o ponto estiver fora da região de recorte.

### <a name="remarks"></a>Comentários

Presume-se que a área esteja vinculada conforme especificado por *crColor*. A `FloodFill` função começa no ponto especificado por *x* e *y* e continua em todas as direções para o limite de cor.

Somente os contextos de dispositivo de memória e dispositivos que dão suporte à tecnologia de `FloodFill` exibição de rasterização dão suporte à função de membro. Para obter informações sobre o recurso RC_BITBLT, `GetDeviceCaps` consulte a função membro.

A `ExtFloodFill` função fornece recursos semelhantes, mas maior flexibilidade.

##  <a name="framerect"></a>  CDC::FrameRect

Desenha uma borda ao lado do retângulo especificado por *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contém as coordenadas lógicas dos cantos superior esquerdo e inferior direito do retângulo. Você também pode passar um `CRect` objeto para esse parâmetro.

*pBrush*<br/>
Identifica o pincel a ser usado para enquadrar o retângulo.

### <a name="remarks"></a>Comentários

A função usa o pincel fornecido para desenhar a borda. A largura e a altura da borda são sempre uma unidade lógica.

Se a coordenada `bottom` do retângulo for menor ou igual a `top`, ou se `right` for menor ou igual a `left`, o retângulo não será desenhado.

A borda desenhada por `FrameRect` está na mesma posição que uma borda desenhada `Rectangle` pela função membro usando as mesmas coordenadas `Rectangle` (se o usar uma caneta que tenha uma unidade lógica de largura). O interior do retângulo não é preenchido por `FrameRect`.

##  <a name="framergn"></a>  CDC::FrameRgn

Desenha uma borda em torno da região especificada por *pRgn* usando o pincel especificado por *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Aponta para o `CRgn` objeto que identifica a região a ser colocada em uma borda. As coordenadas para a região determinada são especificadas em unidades lógicas.

*pBrush*<br/>
Aponta para o `CBrush` objeto que identifica o pincel a ser usado para desenhar a borda.

*nWidth*<br/>
Especifica a largura da borda nos traços do pincel vertical nas unidades do dispositivo.

*nHeight*<br/>
Especifica a altura da borda em traços de pincel horizontais nas unidades do dispositivo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CRgn:: CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

##  <a name="fromhandle"></a>CDC:: FromHandle

Retorna um ponteiro para um `CDC` objeto quando um identificador para um contexto de dispositivo é fornecido.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Contém um identificador para um contexto de dispositivo do Windows.

### <a name="return-value"></a>Valor de retorno

O ponteiro pode ser temporário e não deve ser armazenado além do uso imediato.

### <a name="remarks"></a>Comentários

Se um `CDC` objeto não estiver anexado ao identificador, um objeto temporário `CDC` será criado e anexado.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CPrintDialog:: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

Retorna a direção do arco atual para o contexto do dispositivo.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valor de retorno

Especifica a direção do arco atual, se tiver êxito. A seguir estão os valores de retorno válidos:

- Arcos AD_COUNTERCLOCKWISE e retângulos desenhados no sentido anti-horário.

- Arcos AD_CLOCKWISE e retângulos desenhados no sentido horário.

Se ocorrer um erro, o valor de retorno será zero.

### <a name="remarks"></a>Comentários

As funções Arc e Rectangle usam a direção do arco.

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

Recupera a configuração do filtro de taxa de proporção atual.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valor de retorno

Um `CSize` objeto que representa a taxa de proporção usada pelo filtro de taxa de proporção atual.

### <a name="remarks"></a>Comentários

A taxa de proporção é a taxa formada pela largura e altura de pixel de um dispositivo. As informações sobre a taxa de proporção de um dispositivo são usadas na criação, seleção e exibição de fontes. O Windows fornece um filtro especial, o filtro de taxa de proporção, para selecionar as fontes projetadas para uma taxa de proporção específica de todas as fontes disponíveis. O filtro usa a taxa de proporção especificada pela `SetMapperFlags` função membro.

##  <a name="getbkcolor"></a>  CDC::GetBkColor

Retorna a cor do plano de fundo atual.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valor de retorno

Um valor de cor RGB.

### <a name="remarks"></a>Comentários

Se o modo em segundo plano for opaco, o sistema usará a cor do plano de fundo para preencher as lacunas nas linhas com estilo, as lacunas entre linhas hachuradas em pincéis e o plano de fundo em células de caracteres. O sistema também usa a cor do plano de fundo ao converter bitmaps entre contextos de dispositivo de cor e monocromático.

##  <a name="getbkmode"></a>  CDC::GetBkMode

Retorna o modo de segundo plano.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valor de retorno

O modo em segundo plano atual, que pode ser opaco ou transparente.

### <a name="remarks"></a>Comentários

O modo em segundo plano define se o sistema remove as cores de plano de fundo existentes na superfície de desenho antes de desenhar texto, pincéis hachurados ou qualquer estilo de caneta que não seja uma linha sólida.

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

Retorna o retângulo delimitador acumulado atual para o contexto de dispositivo especificado.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parâmetros

*lpRectBounds*<br/>
Aponta para um buffer que receberá o retângulo delimitador atual. O retângulo é retornado em coordenadas lógicas.

*flags*<br/>
Especifica se o retângulo delimitador deve ser limpo após ser retornado. Esse parâmetro deve ser zero ou definido com o seguinte valor:

- DCB_RESET força a limpeza do retângulo delimitador depois que ele é retornado.

### <a name="return-value"></a>Valor de retorno

Especifica o estado atual do retângulo delimitador se a função for bem-sucedida. Pode ser uma combinação dos seguintes valores:

- A acumulação do retângulo delimitador de DCB_ACCUMULATE está ocorrendo.

- O retângulo delimitador DCB_RESET está vazio.

- O retângulo delimitador DCB_SET não está vazio.

- A acumulação de limite de DCB_ENABLE está ativada.

- A acumulação de limite de DCB_DISABLE está desativada.

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

Recupera a origem (em unidades de dispositivo) do pincel selecionado no momento para o contexto do dispositivo.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valor de retorno

A origem atual do pincel (em unidades de dispositivo) como um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="remarks"></a>Comentários

A origem do pincel inicial está em (0, 0) da área do cliente. O valor de retorno especifica esse ponto em unidades de dispositivo relativas à origem da janela da área de trabalho.

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

Recupera vários tipos de informações em uma cadeia de caracteres.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parâmetros

*lpString*<br/>
Um ponteiro para a cadeia de caracteres a ser processada.

*nCount*<br/>
Especifica o comprimento da cadeia de caracteres. Para a versão ANSI, é uma contagem de bytes e para a função Unicode, ela é uma contagem de palavras. Para obter mais informações, consulte [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Especifica a extensão máxima (em unidades lógicas) para a qual a cadeia de caracteres é processada. Os caracteres que, se processados, excederão essa extensão serão ignorados. As computações para qualquer ordem necessária ou matrizes de glifo se aplicam somente aos caracteres incluídos. Esse parâmetro será usado somente se o valor de GCP_MAXEXTENT for especificado no parâmetro *dwFlags* . Como a função processa a cadeia de caracteres de entrada, cada caractere e sua extensão serão adicionados à saída, à extensão e a outras matrizes somente se a extensão total ainda não tiver ultrapassado o máximo. Quando o limite for atingido, o processamento será interrompido.

*lpResults*<br/>
Ponteiro para uma estrutura [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) que recebe os resultados da função.

*dwFlags*<br/>
Especifica como processar a cadeia de caracteres nas matrizes necessárias. Esse parâmetro pode ser um ou mais dos valores listados na seção *dwFlags* do tópico [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw) .

*str*<br/>
Um ponteiro para um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) a ser processado.

### <a name="return-value"></a>Valor de retorno

Se a função for bem sucedido, o valor de retorno será a largura e a altura da cadeia de caracteres em unidades lógicas.

Se a função falhar, o valor retornado será zero.

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), conforme descrito na SDK do Windows.

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

Recupera as larguras de caracteres consecutivos em um intervalo especificado da fonte TrueType atual.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parâmetros

*nFirstChar*<br/>
Especifica o primeiro caractere no intervalo de caracteres da fonte atual para a qual as larguras de caractere são retornadas.

*nLastChar*<br/>
Especifica o último caractere no intervalo de caracteres da fonte atual para a qual as larguras de caractere são retornadas.

*lpabc*<br/>
Aponta para uma matriz de estruturas [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que recebe as larguras de caracteres quando a função retorna. Essa matriz deve conter pelo menos `ABC` tantas estruturas quanto há caracteres no intervalo especificado pelos parâmetros *nFirstChar* e *nLastChar* .

*lpABCF*<br/>
Aponta para um buffer fornecido pelo aplicativo com uma matriz de estruturas [ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat) para receber as larguras de caracteres quando a função retorna. As larguras retornadas por essa função estão no formato de ponto flutuante IEEE.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As larguras são retornadas em unidades lógicas. Essa função só tem sucesso com fontes TrueType.

O rasterizador TrueType fornece o espaçamento de caracteres "ABC" após a seleção de um tamanho de ponto específico. O espaçamento "a" é a distância que é adicionada à posição atual antes de colocar o glifo. O espaçamento "B" é a largura da parte preta do glifo. O espaçamento "C" é adicionado à posição atual para considerar o espaço em branco à direita do glifo. A largura total avançada é fornecida por um + B + C.

Quando a `GetCharABCWidths` função membro recupera larguras negativas "A" ou "C" para um caractere, esse caractere inclui subtravamentos ou sobretravamentos.

Para converter as larguras ABC em unidades de design de fonte, um aplicativo deve criar uma fonte cuja altura (conforme especificado `lfHeight` no membro da estrutura [LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw) ) seja igual ao `ntmSizeEM` valor armazenado no membro de [NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) estruturá. (O valor do `ntmSizeEM` membro pode ser recuperado chamando a função [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) do Windows.)

As larguras ABC do caractere padrão são usadas para os caracteres que estão fora do intervalo da fonte atualmente selecionada.

Para recuperar as larguras de caracteres em fontes não-TrueType, os aplicativos devem usar a função [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) do Windows.

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

Recupera as larguras, em unidades lógicas, de índices de glifos consecutivos em um intervalo especificado da fonte TrueType atual.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parâmetros

*giFirst*<br/>
Especifica o primeiro índice de glifos no grupo de índices de glifos consecutivos da fonte atual. Esse parâmetro só será usado se o parâmetro *PGI* for nulo.

*cgi*<br/>
Especifica o número de índices de glifos.

*pgi*<br/>
Um ponteiro para uma matriz que contém índices de glifos. Se o valor for NULL, o parâmetro *giFirst* será usado em seu lugar. O parâmetro *CGI* especifica o número de índices de glifos nesta matriz.

*lpabc*<br/>
Ponteiro para uma matriz de estruturas [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que recebe as larguras de caracteres. Essa matriz deve conter pelo menos `ABC` tantas estruturas quanto há índices de glifos especificados pelo parâmetro *CGI* .

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), conforme descrito na SDK do Windows.

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

Recupera as larguras de caracteres individuais em um grupo consecutivo de caracteres da fonte atual, usando `m_hAttribDC`, o contexto do dispositivo de entrada.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*nFirstChar*<br/>
Especifica o primeiro caractere em um grupo de caracteres consecutivo na fonte atual.

*nLastChar*<br/>
Especifica o último caractere em um grupo de caracteres consecutivo na fonte atual.

*lpBuffer*<br/>
Aponta para um buffer que receberá os valores de largura de um grupo de caracteres consecutivo na fonte atual.

*lpFloatBuffer*<br/>
Aponta para um buffer para receber as larguras de caracteres. As larguras retornadas estão no formato de ponto flutuante IEEE de 32 bits. (As larguras são medidas ao longo da linha base dos caracteres.)

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Por exemplo, se *nFirstChar* identificar a letra ' a ' e *nLastChar* identificar a letra ' z ', a função recuperará as larguras de todos os caracteres minúsculos.

A função armazena os valores no buffer apontado por *lpBuffer*. Esse buffer deve ser grande o suficiente para conter todas as larguras. Ou seja, deve haver pelo menos 26 entradas no exemplo fornecido.

Se um caractere no grupo consecutivo de caracteres não existir em uma fonte específica, ele será atribuído ao valor de largura do caractere padrão.

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

Recupera as larguras, em coordenadas lógicas, de índices de glifos consecutivos em um intervalo especificado da fonte atual.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*giFirst*<br/>
Especifica o primeiro índice de glifos no grupo de índices de glifos consecutivos da fonte atual. Esse parâmetro só será usado se o parâmetro *PGI* for nulo.

*cgi*<br/>
Especifica o número de índices de glifos.

*pgi*<br/>
Um ponteiro para uma matriz que contém índices de glifos. Se o valor for NULL, o parâmetro *giFirst* será usado em seu lugar. O parâmetro *CGI* especifica o número de índices de glifos nesta matriz.

*lpBuffer*<br/>
Um ponteiro para um buffer que recebe as larguras.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), conforme descrito na SDK do Windows.

##  <a name="getclipbox"></a>  CDC::GetClipBox

Recupera as dimensões do retângulo delimitador mais rígido em torno do limite de recorte atual.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para a estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou o objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que deve receber as dimensões de retângulo.

### <a name="return-value"></a>Valor de retorno

O tipo da região de recorte. Pode ser qualquer um dos seguintes valores:

- A região de recorte COMPLEXREGION tem bordas sobrepostas.

- O contexto do dispositivo de erro não é válido.

- A região de recorte NULLREGION está vazia.

- A região de recorte SIMPLEREGION não tem bordas sobrepostas.

### <a name="remarks"></a>Comentários

As dimensões são copiadas para o buffer apontado por *lpRect*.

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

Recupera os valores de ajuste de cor para o contexto do dispositivo.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parâmetros

*lpColorAdjust*<br/>
Aponta para uma estrutura de dados [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) para receber os valores de ajuste de cor.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

Retorna um ponteiro para o objeto atualmente `CBitmap` selecionado.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CBitmap` objeto, se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

Retorna um ponteiro para o objeto atualmente `CBrush` selecionado.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CBrush` objeto, se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

Retorna um ponteiro para o objeto atualmente `CFont` selecionado.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CFont` objeto, se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

Retorna um ponteiro para o objeto atualmente `CPalette` selecionado.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CPalette` objeto, se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

Retorna um ponteiro para o objeto atualmente `CPen` selecionado.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CPen` objeto, se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

Recupera a posição atual (em coordenadas lógicas).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valor de retorno

A posição atual como um `CPoint` objeto.

### <a name="remarks"></a>Comentários

A posição atual pode ser definida com a `MoveTo` função de membro.

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

Recupera a cor atual do pincel.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valor de retorno

Se a função for realizada com sucesso, o valor de retorno será o valor de [COLORREF](/windows/win32/gdi/colorref) para a cor do pincel atual.

Se a função falhar, o valor de retorno será CLR_INVALID.

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), conforme descrito na SDK do Windows.

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

Recupera a cor atual da caneta.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valor de retorno

Se a função for realizada com sucesso, o valor de retorno será o valor de [COLORREF](/windows/win32/gdi/colorref) para a cor da caneta atual.

Se a função falhar, o valor de retorno será CLR_INVALID.

### <a name="remarks"></a>Comentários

Essa função de membro utiliza a função [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)do Win32, conforme descrito na SDK do Windows.

##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps

Recupera uma ampla gama de informações específicas do dispositivo sobre o dispositivo de vídeo.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parâmetros

*nIndex*<br/>
Especifica o tipo de informações a serem retornadas. Consulte [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) no SDK do Windows para obter uma lista de valores.

### <a name="return-value"></a>Valor de retorno

O valor do recurso solicitado se a função for bem-sucedida.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CPrintDialog:: GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

##  <a name="getfontdata"></a>  CDC::GetFontData

Recupera informações de métrica de fonte de um arquivo de fonte escalonável.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parâmetros

*dwTable*<br/>
Especifica o nome da tabela de métrica a ser retornada. Esse parâmetro pode ser uma das tabelas de métricas documentadas na especificação de arquivos de fontes TrueType publicada pela Microsoft Corporation. Se esse parâmetro for 0, as informações serão recuperadas começando no início do arquivo de fonte.

*dwOffset*<br/>
Especifica o deslocamento do início da tabela na qual iniciar a recuperação de informações. Se esse parâmetro for 0, as informações serão recuperadas começando no início da tabela especificada pelo parâmetro *dwTable* . Se esse valor for maior ou igual ao tamanho da tabela, `GetFontData` retornará 0.

*lpData*<br/>
Aponta para um buffer que receberá as informações de fonte. Se esse valor for nulo, a função retornará o tamanho do buffer necessário para os dados de fonte especificados no parâmetro *dwTable* .

*cbData*<br/>
Especifica o comprimento, em bytes, das informações a serem recuperadas. Se esse parâmetro for 0, `GetFontData` retornará o tamanho dos dados especificados no parâmetro *dwTable* .

### <a name="return-value"></a>Valor de retorno

Especifica o número de bytes retornados no buffer apontado por *lpData* se a função for bem-sucedida; caso contrário,-1.

### <a name="remarks"></a>Comentários

As informações a serem recuperadas são identificadas especificando um deslocamento no arquivo de fonte e o comprimento das informações a serem retornadas.

Às vezes, um aplicativo pode `GetFontData` usar a função de membro para salvar uma fonte TrueType com um documento. Para fazer isso, o aplicativo determina se a fonte pode ser inserida e, em seguida, recupera o arquivo de fonte inteiro, especificando 0 para os parâmetros *dwTable*, *dwOffset*e *cbData* .

Os aplicativos podem determinar se uma fonte pode ser inserida verificando o `otmfsType` membro da estrutura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Se o bit 1 `otmfsType` de for definido, a inserção não será permitida para a fonte. Se o bit 1 estiver claro, a fonte poderá ser inserida. Se o bit 2 for definido, a inserção será somente leitura.

Se um aplicativo tentar usar essa função para recuperar informações de uma fonte não-TrueType, a função `GetFontData` de membro retornará-1.

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

Retorna informações sobre a fonte selecionada no momento para o contexto de exibição especificado.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valor de retorno

O valor de retorno identifica as características da fonte selecionada no momento. Para obter uma lista completa dos possíveis valores, consulte [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), conforme descrito na SDK do Windows.

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

Recupera a curva de estrutura de tópicos ou bitmap para um caractere de estrutura de tópicos na fonte atual.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parâmetros

*nChar*<br/>
Especifica o caractere para o qual as informações serão retornadas.

*nFormat*<br/>
Especifica o formato no qual a função deve retornar informações. Pode ser um dos seguintes valores, ou 0:

|Valor|Significado|
|-----------|-------------|
|GGO_BITMAP|Retorna o bitmap de glifo. Quando a função retorna, o buffer apontado por *lpBuffer* contém um bitmap de 1 bit por pixel cujas linhas começam em limites doubleword.|
|GGO_NATIVE|Retorna os pontos de dados de curva no formato nativo do rasterizador, usando unidades de dispositivo. Quando esse valor é especificado, qualquer transformação especificada em *lpmat2* é ignorada.|

Quando o valor de *nFormat* é 0, a função preenche uma estrutura [GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) , mas não retorna dados de estrutura de tópicos de glifo.

*lpgm*<br/>
Aponta para uma estrutura GLYPHMETRICS que descreve o posicionamento do glifo na célula Character.

*cbBuffer*<br/>
Especifica o tamanho do buffer no qual a função copia informações sobre o caractere de estrutura de tópicos. Se esse valor for 0 e o parâmetro *nFormat* for os valores GGO_BITMAP ou GGO_NATIVE, a função retornará o tamanho necessário do buffer.

*lpBuffer*<br/>
Aponta para um buffer no qual a função copia informações sobre o caractere de estrutura de tópicos. Se *nFormat* especificar o valor de GGO_NATIVE, as informações serão copiadas na forma de estruturas TTPOLYGONHEADER e TTPOLYCURVE. Se esse valor for nulo e *nFormat* for o valor de GGO_BITMAP ou GGO_NATIVE, a função retornará o tamanho necessário do buffer.

*lpmat2*<br/>
Aponta para uma estrutura [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) que contém uma matriz de transformação para o caractere. Esse parâmetro não pode ser nulo, mesmo quando o valor de GGO_NATIVE é especificado para *nFormat*.

### <a name="return-value"></a>Valor de retorno

O tamanho, em bytes, do buffer necessário para as informações recuperadas se *cbBuffer* for 0 ou *lpBuffer* for nulo. Caso contrário, será um valor positivo se a função for bem-sucedida ou-1 se houver um erro.

### <a name="remarks"></a>Comentários

Um aplicativo pode girar os caracteres recuperados no formato de bitmap especificando uma matriz de transformação 2-by-2 na estrutura apontada por *lpmat2*.

Um contorno de glifo é retornado como uma série de contornos. Cada contorno é definido por uma estrutura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) seguida de quantas `TTPOLYCURVE` estruturas forem necessárias para descrevê-la. Todos os pontos são retornados como estruturas [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) e representam posições absolutas, não movimentações relativas. O ponto de partida fornecido pelo `pfxStart` membro da estrutura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) é o ponto em que o contorno de uma delimitação começa. As estruturas [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) que seguem podem ser registros de polilinha ou registros de spline. Os registros de polilinha são uma série de pontos; as linhas desenhadas entre os pontos descrevem a estrutura de tópicos do caractere. Os registros de spline representam as curvas quadráticas usadas por TrueType (ou seja, linhas de linha de b quadrática).

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

Recupera o modo gráfico atual para o contexto do dispositivo especificado.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valor de retorno

Retorna o modo gráfico atual em caso de sucesso. Para obter uma lista dos valores que esse método pode retornar, consulte [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Retorna 0 em caso de falha.

Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Esse método encapsula a função GDI do Windows [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

Chame essa função de membro para recuperar um pincel de meio-tom.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valor de retorno

Um ponteiro para um `CBrush` objeto se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Um pincel de meio-tom mostra pixels que são alternadamente cores de primeiro plano e plano de fundo para criar um padrão pontilhado. Veja a seguir um exemplo de um padrão pontilhado criado por um pincel de meio-tom.

![Detalhe de um traço de caneta] dificado (../../mfc/reference/media/vc318s1.gif "Detalhe de um traço de caneta") dificado

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

Recupera os pares de kerning de caracteres para a fonte selecionada no momento no contexto do dispositivo especificado.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parâmetros

*nPairs*<br/>
Especifica o número de estruturas [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) apontadas por *lpkrnpair*. A função não copiará mais pares de kerning do que o especificado por *nPairs*.

*lpkrnpair*<br/>
Aponta para uma matriz de `KERNINGPAIR` estruturas que recebe os pares de kerning quando a função retorna. Essa matriz deve conter pelo menos tantas estruturas quantas forem especificadas por *nPairs*. Se esse parâmetro for NULL, a função retornará o número total de pares de kerning para a fonte.

### <a name="return-value"></a>Valor de retorno

Especifica o número de pares de kerning recuperados ou o número total de pares de kerning na fonte, se a função for bem-sucedida. Zero será retornado se a função falhar ou não houver pares de kerning para a fonte.

##  <a name="getlayout"></a>  CDC::GetLayout

Chame essa função de membro para determinar o layout do texto e dos gráficos para um contexto de dispositivo, como uma impressora ou um metarquivo.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valor de retorno

Se for bem-sucedido, os sinalizadores de layout para o contexto do dispositivo atual. Caso contrário, GDI_ERROR. Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Para obter uma lista dos sinalizadores de layout, consulte [CDC:: SetLayout](#setlayout).

### <a name="remarks"></a>Comentários

O layout padrão é da esquerda para a direita.

##  <a name="getmapmode"></a>  CDC::GetMapMode

Recupera o modo de mapeamento atual.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valor de retorno

O modo de mapeamento.

### <a name="remarks"></a>Comentários

Para obter uma descrição dos modos de mapeamento, consulte `SetMapMode` a função membro.

> [!NOTE]
>  Se você chamar [SetLayout](#setlayout) para alterar o layout do controlador de domínio da direita para a `SetLayout` esquerda, o alterará automaticamente o modo de mapeamento para MM_ISOTROPIC. Consequentemente, qualquer chamada subsequente `GetMapMode` para retornará MM_ISOTROPIC.

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

Retorna o limite de mitra para o contexto do dispositivo.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O limite de Mitre é usado ao desenhar linhas geométricas com junções de mitra.

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

Retorna a cor sólida que melhor corresponde a uma cor lógica especificada.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a cor a ser correspondida.

### <a name="return-value"></a>Valor de retorno

Um valor de cor RGB (vermelho, verde, azul) que define a cor sólida mais próxima do valor *crColor* que o dispositivo pode representar.

### <a name="remarks"></a>Comentários

O dispositivo fornecido deve ser capaz de representar essa cor.

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

Recupera informações de métrica para fontes TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parâmetros

*lpotm*<br/>
Aponta para uma matriz de estruturas [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Se esse parâmetro for nulo, a função retornará o tamanho do buffer necessário para os dados de métrica recuperados.

*cbData*<br/>
Especifica o tamanho, em bytes, do buffer para o qual as informações são retornadas.

*lpotm*<br/>
Aponta para uma `OUTLINETEXTMETRIC` estrutura. Se esse parâmetro for nulo, a função retornará o tamanho do buffer necessário para as informações de métrica recuperadas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A estrutura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) contém a maioria das informações de métricas de fonte fornecidas com o formato TrueType, incluindo uma estrutura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) . Os últimos quatro membros da `OUTLINETEXTMETRIC` estrutura são ponteiros para cadeias de caracteres. Os aplicativos devem alocar espaço para essas cadeias de caracteres além do espaço necessário para os outros membros. Como não há limite imposto pelo sistema para o tamanho das cadeias de caracteres, o método mais simples para alocar memória é recuperar o tamanho necessário especificando NULL para *lpotm* na primeira chamada para a `GetOutlineTextMetrics` função.

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

Usa o contexto do dispositivo de `m_hDC`saída, e recupera as larguras de caracteres individuais em um grupo consecutivo de caracteres da fonte atual.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*nFirstChar*<br/>
Especifica o primeiro caractere em um grupo de caracteres consecutivo na fonte atual.

*nLastChar*<br/>
Especifica o último caractere em um grupo de caracteres consecutivo na fonte atual.

*lpBuffer*<br/>
Aponta para um buffer que receberá os valores de largura de um grupo de caracteres consecutivo na fonte atual.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Por exemplo, se *nFirstChar* identificar a letra ' a ' e *nLastChar* identificar a letra ' z ', a função recuperará as larguras de todos os caracteres minúsculos.

A função armazena os valores no buffer apontado por *lpBuffer*. Esse buffer deve ser grande o suficiente para conter todas as larguras; ou seja, deve haver pelo menos 26 entradas no exemplo fornecido.

Se um caractere no grupo consecutivo de caracteres não existir em uma fonte específica, ele será atribuído ao valor de largura do caractere padrão.

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

Chame essa função de membro para calcular a largura e a altura de uma cadeia de caracteres usando [m_hDC](#m_hdc), o contexto do dispositivo de saída.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres a ser medida. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para esse parâmetro.

*nCount*<br/>
Especifica o [comprimento da cadeia de caracteres](/windows/win32/gdi/specifying-length-of-text-output-string) apontada por *lpszString*.

*nTabPositions*<br/>
Especifica o número de posições de parada de tabulação na matriz apontada por *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Aponta para uma matriz de inteiros que contém as posições de parada de tabulação em unidades lógicas. As paradas de tabulação devem ser classificadas em ordem crescente; o menor valor x deve ser o primeiro item na matriz. Não são permitidas guias de trás.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem medidos.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) em um objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

Se a cadeia contiver um ou mais caracteres de tabulação, a largura da cadeia de caracteres será baseada nas paradas de tabulação especificadas por *lpnTabStopPositions*. A função usa a fonte atualmente selecionada para computar as dimensões da cadeia de caracteres.

A região de recorte atual não desloca a largura e a altura retornadas `GetOutputTabbedTextExtent` pela função.

Como alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles estão kerning aos caracteres), a soma das extensões dos caracteres em uma cadeia de caracteres pode não ser igual à extensão da cadeia de caracteres.

Se *nTabPositions* for 0 e *lpnTabStopPositions* for NULL, as guias serão expandidas para oito larguras de caracteres médias. Se *nTabPositions* for 1, as paradas de tabulação serão separadas pela distância especificada pelo primeiro valor da matriz para o qual *lpnTabStopPositions* aponta. Se *lpnTabStopPositions* apontar para mais de um único valor, uma parada de tabulação será definida para cada valor na matriz, até o número especificado por *nTabPositions*.

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

Chame essa função de membro para usar o contexto do dispositivo de saída, [m_hDC](#m_hdc), e computar a largura e a altura de uma linha de texto, usando a fonte atual.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para esse parâmetro.

*nCount*<br/>
Especifica o [comprimento da cadeia de caracteres](/windows/win32/gdi/specifying-length-of-text-output-string) apontada por *lpszString*.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem medidos.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) retornadas em um objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

A região de recorte atual não afeta a largura e a altura retornadas por `GetOutputTextExtent`.

Como alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles executam kerning), a soma das extensões dos caracteres em uma cadeia de caracteres pode não ser igual à extensão da cadeia de caracteres.

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

Recupera as métricas para a fonte atual usando `m_hDC`o, o contexto do dispositivo de saída.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parâmetros

*lpMetrics*<br/>
Aponta para a estrutura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recebe as métricas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="getpath"></a>  CDC::GetPath

Recupera as coordenadas definindo os pontos de extremidade de linhas e os pontos de controle das curvas encontradas no caminho selecionado no contexto do dispositivo.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas de dados ou objetos `CPoint` de [ponto](/windows/win32/api/windef/ns-windef-point)  em que os pontos de extremidade de linha e de controle de curva são colocados.

*lpTypes*<br/>
Aponta para uma matriz de bytes em que os tipos de vértice são colocados. Os valores são um dos seguintes:

- PT_MOVETO Especifica que o ponto correspondente no *lpPoints* inicia uma imagem não junção.

- PT_LINETO especifica que o ponto anterior e o ponto correspondente em *lpPoints* são os pontos de extremidade de uma linha.

- PT_BEZIERTO Especifica que o ponto correspondente em *lpPoints* é um ponto de controle ou ponto final para uma curva Bzier.

Os tipos PT_BEZIERTO sempre ocorrem em conjuntos de três. O ponto no caminho imediatamente antes que ele defina o ponto de partida para a curva Bzier. Os dois primeiros pontos PT_BEZIERTO são os pontos de controle, e o terceiro ponto de PT_BEZIERTO é o ponto de extremidade (se embutido em código).

   Um tipo de PT_LINETO ou PT_BEZIERTO pode ser combinado com o sinalizador a seguir (usando o operador bit a bit **ou**) para indicar que o ponto correspondente é o último ponto em uma figura e que a figura deve ser fechada:

- PT_CLOSEFIGURE especifica que a figura é fechada automaticamente depois que a linha ou curva correspondente é desenhada. A figura é fechada desenhando uma linha do ponto de extremidade de linha ou de curva até o ponto correspondente ao último PT_MOVETO.

*nCount*<br/>
Especifica o número total de estruturas de dados de [ponto](/windows/win32/api/windef/ns-windef-point) que podem ser colocadas na matriz *lpPoints* . Esse valor deve ser o mesmo que o número de bytes que podem ser colocados na matriz *lpTypes* .

### <a name="return-value"></a>Valor de retorno

Se o parâmetro *nCount* for diferente de zero, o número de pontos enumerados. Se *nCount* for 0, o número total de pontos no caminho (e `GetPath` não gravará nada nos buffers). Se *nCount* for diferente de zero e for menor que o número de pontos no caminho, o valor de retorno será-1.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado. Os pontos do caminho são retornados em coordenadas lógicas. Os pontos são armazenados no caminho em coordenadas de dispositivo, `GetPath` portanto, o altera os pontos de coordenadas de dispositivo para coordenadas lógicas usando o inverso da transformação atual. A `FlattenPath` função de membro pode ser chamada `GetPath`antes, para converter todas as curvas no caminho em segmentos de linha.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: BeginPath](#beginpath).

##  <a name="getpixel"></a>  CDC::GetPixel

Recupera o valor de cor RGB do pixel no ponto especificado por *x* e *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto a ser examinado.

*y*<br/>
Especifica a coordenada y lógica do ponto a ser examinado.

*point*<br/>
Especifica as coordenadas x e y lógicas do ponto a ser examinado.

### <a name="return-value"></a>Valor de retorno

Para qualquer versão da função, um valor de cor RGB para a cor do ponto determinado. Será-1 se as coordenadas não especificarem um ponto na região de recorte.

### <a name="remarks"></a>Comentários

O ponto deve estar na região de recorte. Se o ponto não estiver na região de recorte, a função não terá efeito e retornará-1.

Nem todos os dispositivos oferecem suporte à função `GetPixel`. Para obter mais informações, consulte a funcionalidade de rasterização RC_BITBLT na função membro [GetDeviceCaps](#getdevicecaps) .

A `GetPixel` função membro tem duas formas. A primeira usa dois valores de coordenadas; o segundo usa uma estrutura de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

Recupera o modo de preenchimento de polígono atual.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valor de retorno

O modo preenchido por polígono atual, alternativo ou vento, se a função for bem-sucedida.

### <a name="remarks"></a>Comentários

Consulte a `SetPolyFillMode` função membro para obter uma descrição dos modos de preenchimento de polígono.

##  <a name="getrop2"></a>  CDC::GetROP2

Recupera o modo de desenho atual.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valor de retorno

O modo de desenho. Para obter uma lista dos valores do modo de desenho, `SetROP2` consulte a função membro.

### <a name="remarks"></a>Comentários

O modo de desenho especifica como as cores da caneta e o interior dos objetos preenchidos são combinados com a cor já na superfície de exibição.

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

Chame essa função de membro para obter [m_hDC](#m_hdc), o contexto do dispositivo de saída.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valor de retorno

Um identificador de contexto de dispositivo.

### <a name="remarks"></a>Comentários

Essa função de membro também funciona com ponteiros nulos.

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

Recupera o modo de alongamento de bitmaps atual.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valor de retorno

O valor de retorno especifica o modo de alongamento de bitmaps atual — STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS — se a função for bem-sucedida.

### <a name="remarks"></a>Comentários

O modo de alongamento de bitmap define como as informações são removidas dos bitmaps que são ampliados ou compactados pela função de `StretchBlt` membro.

Os modos STRETCH_ANDSCANS e STRETCH_ORSCANS normalmente são usados para preservar pixels em primeiro plano em bitmaps monocromáticos. O modo STRETCH_DELETESCANS normalmente é usado para preservar a cor em bitmaps de cores.

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

Chame essa função de membro para calcular a largura e a altura de uma cadeia de caracteres usando [m_hAttribDC](#m_hattribdc), o contexto do dispositivo de atributo.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para esse parâmetro.

*nCount*<br/>
Especifica o [comprimento da cadeia de caracteres](/windows/win32/gdi/specifying-length-of-text-output-string) apontada por *lpszString*.

*nTabPositions*<br/>
Especifica o número de posições de parada de tabulação na matriz apontada por *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Aponta para uma matriz de inteiros que contém as posições de parada de tabulação em unidades lógicas. As paradas de tabulação devem ser classificadas em ordem crescente; o menor valor x deve ser o primeiro item na matriz. Não são permitidas guias de trás.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem desenhados.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) em um objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

Se a cadeia contiver um ou mais caracteres de tabulação, a largura da cadeia de caracteres será baseada nas paradas de tabulação especificadas por *lpnTabStopPositions*. A função usa a fonte atualmente selecionada para computar as dimensões da cadeia de caracteres.

A região de recorte atual não desloca a largura e a altura retornadas `GetTabbedTextExtent` pela função.

Como alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles estão kerning aos caracteres), a soma das extensões dos caracteres em uma cadeia de caracteres pode não ser igual à extensão da cadeia de caracteres.

Se *nTabPositions* for 0 e *lpnTabStopPositions* for NULL, as guias serão expandidas para oito vezes a largura média do caractere. Se *nTabPositions* for 1, as paradas de tabulação serão separadas pela distância especificada pelo primeiro valor da matriz para o qual *lpnTabStopPositions* aponta. Se *lpnTabStopPositions* apontar para mais de um único valor, uma parada de tabulação será definida para cada valor na matriz, até o número especificado por *nTabPositions*.

##  <a name="gettextalign"></a>  CDC::GetTextAlign

Recupera o status dos sinalizadores de alinhamento de texto para o contexto do dispositivo.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valor de retorno

O status dos sinalizadores de alinhamento de texto. O valor de retorno é um ou mais dos seguintes valores:

- TA_BASELINE especifica o alinhamento do eixo x e a linha de base da fonte escolhida dentro do retângulo delimitador.

- TA_BOTTOM especifica o alinhamento do eixo x e a parte inferior do retângulo delimitador.

- TA_CENTER especifica o alinhamento do eixo y e o centro do retângulo delimitador.

- TA_LEFT especifica o alinhamento do eixo y e o lado esquerdo do retângulo delimitador.

- TA_NOUPDATECP especifica que a posição atual não é atualizada.

- TA_RIGHT especifica o alinhamento do eixo y e o lado direito do retângulo delimitador.

- TA_TOP especifica o alinhamento do eixo x e a parte superior do retângulo delimitador.

- TA_UPDATECP Especifica que a posição atual é atualizada.

### <a name="remarks"></a>Comentários

Os sinalizadores de alinhamento de texto determinam `TextOut` como `ExtTextOut` as funções e membro alinham uma cadeia de caracteres de texto em relação ao ponto de partida da cadeia de caracteres. Os sinalizadores de alinhamento de texto não são necessariamente sinalizadores de bit único e podem ser iguais a 0. Para testar se um sinalizador está definido, um aplicativo deve seguir estas etapas:

1. Aplique o operador OR ou bit a o sinalizador e seus sinalizadores relacionados, agrupados da seguinte maneira:

    - TA_LEFT, TA_CENTER e TA_RIGHT

    - TA_BASELINE, TA_BOTTOM e TA_TOP

    - TA_NOUPDATECP e TA_UPDATECP

1. Aplique o operador-AND-bit-a-AND ao resultado e `GetTextAlign`o valor de retorno de.

1. Teste a igualdade deste resultado e o sinalizador.

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

Recupera a configuração atual para a quantidade de espaçamento entre caracteres.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valor de retorno

A quantidade do espaçamento entre caracteres.

### <a name="remarks"></a>Comentários

O GDI adiciona esse espaçamento a cada caractere, incluindo caracteres de quebra, quando grava uma linha de texto no contexto do dispositivo.

O valor padrão para a quantidade de espaçamento entre caracteres é 0.

##  <a name="gettextcolor"></a>  CDC::GetTextColor

Recupera a cor do texto atual.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valor de retorno

A cor do texto atual como um valor de cor RGB.

### <a name="remarks"></a>Comentários

A cor do texto é a cor de primeiro plano dos caracteres desenhados usando as funções de membro de saída de texto do GDI [TextOut](#textout), [ExtTextOut](#exttextout)e [TabbedTextOut](#tabbedtextout).

##  <a name="gettextextent"></a>  CDC::GetTextExtent

Chame essa função de membro para calcular a largura e a altura de uma linha de texto usando a fonte atual para determinar as dimensões.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres. Você também pode passar um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) em um objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

As informações são recuperadas de [m_hAttribDC](#m_hattribdc), o contexto do dispositivo de atributo.

Por padrão, `GetTextExtent` o assume que o texto para o qual ele recupera a dimensão é definido ao longo de uma linha horizontal (ou seja, o escape é 0). Se você criar uma fonte especificando um escape diferente de zero, deverá converter o ângulo do texto explicitamente para obter as dimensões da cadeia de caracteres.

A região de recorte atual não afeta a largura e a altura retornadas por `GetTextExtent`.

Como alguns dispositivos não colocam caracteres em matrizes de células regulares (ou seja, eles executam kerning), a soma das extensões dos caracteres em uma cadeia de caracteres pode não ser igual à extensão da cadeia de caracteres.

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

Recupera o número de caracteres em uma cadeia de caracteres especificada que se ajustará em um espaço especificado e preencherá uma matriz com a extensão de texto para cada um desses caracteres.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*pgiIn*<br/>
Um ponteiro para uma matriz de índices de glifos para os quais as extensões devem ser recuperadas.

*cgi*<br/>
Especifica o número de glifos na matriz apontados por *pgiIn*.

*nMaxExtent*<br/>
Especifica a largura máxima permitida, em unidades lógicas, da cadeia de caracteres formatada.

*lpnFit*<br/>
Um ponteiro para um inteiro que recebe uma contagem do número máximo de caracteres que se ajustarão ao espaço especificado por *nMaxExtent*. Quando *lpnFit* é nulo, *nMaxExtent* é ignorado.

*alpDx*<br/>
Um ponteiro para uma matriz de inteiros que recebe extensões de glifo parciais. Cada elemento na matriz fornece a distância, em unidades lógicas, entre o início da matriz de índices de glifo e um dos glifos que se ajustam ao espaço especificado por *nMaxExtent*. Embora essa matriz deva ter pelo menos tantos elementos quanto índices de glifos especificados pelo *CGI*, a função preenche a matriz com extensões somente para quantos índices de glifo forem especificados por *lpnFit*. Se *lpnDx* for NULL, a função não computará larguras de cadeia de caracteres parciais.

*lpSize*<br/>
Ponteiro para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) que recebe as dimensões da matriz de índices de glifo, em unidades lógicas. Esse valor não pode ser nulo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), conforme descrito na SDK do Windows.

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

Recupera a largura e a altura da matriz especificada de índices de glifos.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*pgiIn*<br/>
Um ponteiro para uma matriz de índices de glifos para os quais as extensões devem ser recuperadas.

*cgi*<br/>
Especifica o número de glifos na matriz apontados por *pgiIn*.

*lpSize*<br/>
Ponteiro para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) que recebe as dimensões da matriz de índices de glifo, em unidades lógicas. Esse valor não pode ser nulo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função de membro emula a funcionalidade da função [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), conforme descrito na SDK do Windows.

##  <a name="gettextface"></a>  CDC::GetTextFace

Chame essa função de membro para copiar o nome de tipo da fonte atual em um buffer.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parâmetros

*nCount*<br/>
Especifica o tamanho do buffer (em bytes). Se o nome da face de tipos for maior do que o número de bytes especificado por esse parâmetro, o nome será truncado.

*lpszFacename*<br/>
Aponta para o buffer para o nome da face de tipos.

*rString*<br/>
Uma referência a um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) .

### <a name="return-value"></a>Valor de retorno

O número de bytes copiados para o buffer, não incluindo o caractere nulo de terminação. Será 0 se ocorrer um erro.

### <a name="remarks"></a>Comentários

O nome da face de tipos é copiado como uma cadeia de caracteres terminada em nulo.

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

Recupera as métricas da fonte atual usando o contexto do dispositivo de atributo.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parâmetros

*lpMetrics*<br/>
Aponta para a estrutura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recebe as métricas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="getviewportext"></a>  CDC::GetViewportExt

Recupera as extensões x e y do visor do contexto do dispositivo.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valor de retorno

As extensões x e y (nas unidades do dispositivo) como um `CSize` objeto.

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

Recupera as coordenadas x e y da origem do visor associado ao contexto do dispositivo.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valor de retorno

A origem do visor (em coordenadas do dispositivo) como um `CPoint` objeto.

##  <a name="getwindow"></a>  CDC::GetWindow

Retorna a janela associada ao contexto do dispositivo de vídeo.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CWnd` objeto se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa é uma função avançada. Por exemplo, essa função de membro pode não retornar a janela de exibição ao imprimir ou na visualização de impressão. Ele sempre retorna a janela associada à saída. Funções de saída que usam o DC fornecido para essa janela.

##  <a name="getwindowext"></a>  CDC::GetWindowExt

Recupera as extensões x e y da janela associada ao contexto do dispositivo.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valor de retorno

As extensões x e y (em unidades lógicas) como um `CSize` objeto.

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

Recupera as coordenadas x e y da origem da janela associada ao contexto do dispositivo.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valor de retorno

A origem da janela (em coordenadas lógicas) como um `CPoint` objeto.

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

Recupera a transformação espaço mundial atual para a página-espaço.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a uma estrutura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) que recebe o espaço mundial atual para a transformação de espaço de página.

### <a name="return-value"></a>Valor de retorno

Retorna um valor diferente de zero em caso de êxito.

Retorna 0 em caso de falha.

Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Esse método encapsula a função GDI do Windows [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

##  <a name="gradientfill"></a>  CDC::GradientFill

Chame essa função de membro para preencher as estruturas de retângulo e triângulo com cores que esmaecem suavemente de um lado para outro.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parâmetros

*pVertices*<br/>
Ponteiro para uma matriz de estruturas de [trivértices](/windows/win32/api/wingdi/ns-wingdi-trivertex) que definem um vértice de triângulo.

*nVertices*<br/>
O número de vértices.

*pMesh*<br/>
Matriz de estruturas [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) no modo de triângulo ou uma matriz de estruturas [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) no modo de retângulo.

*nMeshElements*<br/>
O número de elementos (triângulos ou retângulos) em *pMesh*.

*dwMode*<br/>
Especifica o modo de preenchimento gradual. Para obter uma lista de valores possíveis, consulte [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) no SDK do Windows.

### <a name="return-value"></a>Valor de retorno

Verdadeiro se for bem-sucedido; caso contrário, FALSE.

### <a name="remarks"></a>Comentários

Para obter mais informações, `GradientFill` consulte na SDK do Windows.

##  <a name="graystring"></a>  CDC::GrayString

Desenha o texto esmaecido (cinza) no local determinado escrevendo o texto em um bitmap de memória, esgotando o bitmap e, em seguida, copiando o bitmap para a exibição.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*pBrush*<br/>
Identifica o pincel a ser usado para DIMM (cinza).

*lpfnOutput*<br/>
Especifica o endereço de instância de procedimento da função de retorno de chamada fornecida pelo aplicativo que irá desenhar a cadeia de caracteres. Para obter mais informações, consulte a descrição da função `OutputFunc` de [chamada de retorno](callback-functions-used-by-mfc.md#graystring)do Windows. Se esse parâmetro for NULL, o sistema usará a `TextOut` função do Windows para desenhar a cadeia de caracteres e *lpData* será considerado um ponteiro longo para a cadeia de caracteres a ser impressa.

*lpData*<br/>
Especifica um ponteiro distante para os dados a serem passados para a função de saída. Se *lpfnOutput* for nulo, *lpData* deverá ser um ponteiro longo para a cadeia de caracteres a ser impressa.

*nCount*<br/>
Especifica o número de caracteres a serem gerados. Se esse parâmetro for 0, `GrayString` o calculará o comprimento da cadeia de caracteres (supondo que *lpData* seja um ponteiro para a cadeia de caracteres). Se *nCount* for 1 e a função apontada por *lpfnOutput* retornar 0, a imagem será mostrada, mas não esmaecida.

*x*<br/>
Especifica a coordenada x-a posição de início do retângulo que inclui a cadeia de caracteres.

*y*<br/>
Especifica a coordenada y lógica da posição inicial do retângulo que inclui a cadeia de caracteres.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo que inclui a cadeia de caracteres. Se *nWidth* for 0, `GrayString` calculará a largura da área, supondo que *lpData* seja um ponteiro para a cadeia de caracteres.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo que inclui a cadeia de caracteres. Se *nHeight* for 0, `GrayString` calculará a altura da área, supondo que *lpData* seja um ponteiro para a cadeia de caracteres.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a cadeia de caracteres for desenhada `TextOut` , ou 0 se a função ou a função de saída fornecida pelo aplicativo retornar 0, ou se não houver memória suficiente para criar um bitmap de memória para o esmaecimento.

### <a name="remarks"></a>Comentários

A função escurece o texto, independentemente do pincel e do plano de fundo selecionados. A `GrayString` função de membro usa a fonte atualmente selecionada. O modo de mapeamento MM_TEXT deve ser selecionado antes de usar essa função.

Um aplicativo pode desenhar cadeias de caracteres esmaecidas (esmaecidas) em dispositivos que dão suporte a uma cor `GrayString` cinza sólida sem chamar a função de membro. A cor do sistema COLOR_GRAYTEXT é a cor do sistema cinza estável usada para desenhar texto desabilitado. O aplicativo pode chamar a `GetSysColor` função do Windows para recuperar o valor de cor de COLOR_GRAYTEXT. Se a cor for diferente de 0 (preto), o aplicativo poderá chamar a `SetTextColor` função de membro para definir a cor do texto para o valor de cor e, em seguida, desenhar a cadeia de caracteres diretamente. Se a cor recuperada for preta, o aplicativo deverá `GrayString` chamar para Dim (cinza) o texto.

Se *lpfnOutput* for NULL, GDI usará a função do Windows de [textoout](/windows/win32/api/wingdi/nf-wingdi-textoutw) e *lpData* será considerado um ponteiro distante para o caractere a ser impresso. Se os caracteres a serem gerados não puderem ser manipulados pela `TextOut` função membro (por exemplo, a cadeia de caracteres é armazenada como um bitmap), o aplicativo deverá fornecer sua própria função de saída.

Observe também que todas as funções de retorno de chamada devem interceptar exceções do Microsoft Foundation antes de retornar ao Windows, pois as exceções não podem ser lançadas em limites de retorno de chamada Para obter mais informações sobre exceções, consulte o artigo [exceções](../../mfc/exception-handling-in-mfc.md).

A função de retorno de `GrayString` chamada passada deve `__stdcall` usar a Convenção de chamada e deve `__declspec`ser exportada com.

Quando a estrutura está no modo de visualização, uma chamada para `GrayString` a função de membro é convertida em uma `TextOut` chamada e a função de retorno de chamada não é chamada.

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

Use essa função quando você converter tamanhos de HIMETRIC de OLE para pixels.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

Se o modo de mapeamento do objeto de contexto do dispositivo for MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, a conversão será baseada no número de pixels na polegada física. Se o modo de mapeamento for um dos outros modos não restritos (por exemplo, MM_TEXT), a conversão será baseada no número de pixels na polegada lógica.

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

Chame essa função para converter unidades HIMETRIC em unidades lógicas.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) ou objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

Use essa função quando você obtém tamanhos de HIMETRIC do OLE e deseja convertê-los no modo de mapeamento natural do aplicativo.

A conversão é realizada primeiro convertendo as unidades HIMETRIC em pixels e, em seguida, convertendo essas unidades em unidades lógicas usando as unidades de mapeamento atuais do contexto de dispositivo. Observe que as extensões da janela e do visor do dispositivo afetarão o resultado.

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

Cria uma nova região de recorte ao formar a interseção da região atual e o retângulo especificado por *X1*, *Y1*, *X2*e *Y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y1*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo.

*Y2*<br/>
Especifica a coordenada y lógica do canto inferior direito do retângulo.

*lpRect*<br/>
Especifica o retângulo. Você pode passar um `CRect` objeto ou um ponteiro para uma `RECT` estrutura para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

O novo tipo de região de recorte. Pode ser qualquer um dos seguintes valores:

- COMPLEXREGION nova região de recorte tem bordas sobrepostas.

- O contexto do dispositivo de erro não é válido.

- NULLREGION nova região de recorte está vazia.

- SIMPLEREGION Nova região de recorte não tem bordas sobrepostas.

### <a name="remarks"></a>Comentários

O GDI corta todas as saídas subsequentes para caber no novo limite. A largura e a altura não devem exceder 32.767.

##  <a name="invertrect"></a>  CDC::InvertRect

Inverte o conteúdo do retângulo fornecido.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um `RECT` que contém as coordenadas lógicas do retângulo a serem invertidas. Você também pode passar um `CRect` objeto para esse parâmetro.

### <a name="remarks"></a>Comentários

Inversão é uma operação não lógica e inverte os bits de cada pixel. Em monitores monocromáticos, a função torna os pixels brancos pretos e pretos em branco. Na cor exibida, a inversão depende de como as cores são geradas para a exibição. Chamar `InvertRect` duas vezes com o mesmo retângulo restaura a exibição para suas cores anteriores.

Se o retângulo estiver vazio, nada será desenhado.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

Inverte as cores na região especificada por *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Identifica a região a ser invertida. As coordenadas para a região são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Em monitores monocromáticos, a função torna os pixels brancos pretos e pretos em branco. Na cor exibida, a inversão depende de como as cores são geradas para a exibição.

##  <a name="isprinting"></a>  CDC::IsPrinting

Determina se o contexto do dispositivo está sendo usado para impressão.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero `CDC` se o objeto for um DC de impressora; caso contrário, 0.

##  <a name="lineto"></a>  CDC::LineTo

Desenha uma linha da posição atual até, mas não incluindo, o ponto especificado por *x* e *y* (ou *ponto*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto de extremidade para a linha.

*y*<br/>
Especifica a coordenada y lógica do ponto de extremidade para a linha.

*point*<br/>
Especifica o ponto de extremidade para a linha. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a linha for desenhada; caso contrário, 0.

### <a name="remarks"></a>Comentários

A linha é desenhada com a caneta selecionada. A posição atual é definida como *x*, *y* ou to *Point*.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CRect:: CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="lptodp"></a>  CDC::LPtoDP

Converte unidades lógicas em unidades de dispositivo.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de pontos. Cada ponto na matriz é uma estrutura de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
O número de pontos na matriz.

*lpRect*<br/>
Aponta para uma estrutura [Rect](/windows/win32/api/windef/ns-windef-rect) ou um objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) . Esse parâmetro é usado para o caso comum de mapeamento de um retângulo de unidades lógicas para dispositivos.

*lpSize*<br/>
Aponta para uma estrutura de [tamanho](/windows/win32/api/windef/ns-windef-size) ou um objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Comentários

A função mapeia as coordenadas de cada ponto, ou dimensões de um tamanho, do sistema de coordenadas lógicas do GDI para um sistema de coordenadas do dispositivo. A conversão depende do modo de mapeamento atual e das configurações das origens e das extensões da janela e do visor do dispositivo.

As coordenadas x e y de points são inteiros com sinal de 2 bytes no intervalo de-32.768 a 32.767. Nos casos em que o modo de mapeamento resultaria em valores maiores que esses limites, o sistema define os valores como-32.768 e 32.767, respectivamente.

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

Chame essa função para converter unidades lógicas em unidades HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para uma `SIZE` estrutura ou um `CSize` objeto.

### <a name="remarks"></a>Comentários

Use essa função quando você fornecer tamanhos de HIMETRIC para OLE, convertendo do modo de mapeamento natural do aplicativo. Observe que as extensões da janela e do visor do dispositivo afetarão o resultado.

A conversão é realizada primeiro convertendo as unidades lógicas em pixels usando as unidades de mapeamento atuais do contexto de dispositivo e, em seguida, convertendo essas unidades em unidades HIMETRIC.

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

O contexto do dispositivo de atributo `CDC` para este objeto.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Comentários

Por padrão, esse contexto de dispositivo é igual `m_hDC`a. Em geral, `CDC` as chamadas GDI que solicitam informações do contexto do dispositivo são `m_hAttribDC`direcionadas para. Consulte a descrição da classe [CDC](../../mfc/reference/cdc-class.md) para saber mais sobre o uso desses dois contextos de dispositivo.

##  <a name="m_hdc"></a>  CDC::m_hDC

O contexto do dispositivo de saída `CDC` para este objeto.

```
HDC m_hDC;
```

### <a name="remarks"></a>Comentários

Por padrão, `m_hDC` é igual a `m_hAttribDC`, o outro contexto de dispositivo encapsulado por `CDC`. Em geral, `CDC` as chamadas GDI que criam a saída vão `m_hDC` para o contexto do dispositivo. Você pode inicializar `m_hDC` e `m_hAttribDC` apontar para dispositivos diferentes. Consulte a descrição da classe [CDC](../../mfc/reference/cdc-class.md) para saber mais sobre o uso desses dois contextos de dispositivo.

##  <a name="maskblt"></a>  CDC::MaskBlt

Combina os dados de cor dos bitmaps de origem e de destino usando a máscara e a operação de varredura fornecidas.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo de destino.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo de destino.

*nWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino e do bitmap de origem.

*nHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino e do bitmap de origem.

*pSrcDC*<br/>
Identifica o contexto do dispositivo do qual o bitmap deve ser copiado. Ele deverá ser zero se o parâmetro *dwRop* especificar uma operação de varredura que não inclua uma origem.

*xSrc*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do bitmap de origem.

*ySrc*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do bitmap de origem.

*maskBitmap*<br/>
Identifica o bitmap de máscara monocromática combinado com o bitmap de cor no contexto do dispositivo de origem.

*xMask*<br/>
Especifica o deslocamento de pixel horizontal para o bitmap de máscara especificado pelo parâmetro *maskBitmap* .

*yMask*<br/>
Especifica o deslocamento de pixel vertical para o bitmap de máscara especificado pelo parâmetro *maskBitmap* .

*dwRop*<br/>
Especifica os códigos de operação de rasterização de primeiro plano e de fundo ternário, que a função usa para controlar a combinação de dados de origem e de destino. O código da operação rasterizada em segundo plano é armazenado no alto byte da palavra alta desse valor; o código de operação de varredura em primeiro plano é armazenado no byte inferior da palavra alta desse valor; a palavra inferior desse valor é ignorada e deve ser zero. A macro MAKEROP4 cria essas combinações de códigos de operação de fundo em primeiro plano e em segundo plano. Consulte a seção comentários para obter uma discussão do primeiro plano e do plano de fundo no contexto dessa função. Consulte a `BitBlt` função membro para obter uma lista de códigos de operação de varredura comuns.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um valor de 1 na máscara especificada por *maskBitmap* indica que o código de operação de varredura em primeiro plano especificado por *dwRop* deve ser aplicado nesse local. Um valor de 0 na máscara indica que o código de operação rasterizada de fundo especificado por *dwRop* deve ser aplicado nesse local. Se as operações de varredura exigirem uma origem, o retângulo de máscara deverá cobrir o retângulo de origem. Caso contrário, a função falhará. Se as operações de varredura não exigirem uma origem, o retângulo de máscara deverá abranger o retângulo de destino. Caso contrário, a função falhará.

Se uma transformação de rotação ou distorção estiver em vigor para o contexto do dispositivo de origem quando essa função for chamada, ocorrerá um erro. No entanto, outros tipos de transformações são permitidos.

Se os formatos de cor dos bitmaps de origem, padrão e destino forem diferentes, essa função converterá o padrão ou o formato de origem, ou ambos, para corresponder ao formato de destino. Se o bitmap de máscara não for um bitmap monocromático, ocorrerá um erro. Quando um metarquivo aprimorado estiver sendo gravado, ocorrerá um erro (e a função retornará 0) se o contexto do dispositivo de origem identificar um contexto de dispositivo de metarquivo avançado. Nem todos os dispositivos `MaskBlt`dão suporte. Um aplicativo deve chamar `GetDeviceCaps` para determinar se um dispositivo dá suporte a essa função. Se nenhum bitmap de máscara for fornecido, essa função se comporta exatamente como `BitBlt`, usando o código de operação de varredura em primeiro plano. Os deslocamentos de pixel no bitmap de máscara mapeiam para o ponto (0, 0) no bitmap do contexto do dispositivo de origem. Isso é útil para casos em que um bitmap de máscara contém um conjunto de máscaras; um aplicativo pode facilmente aplicar qualquer um deles a uma tarefa de transferência de bits de máscara ajustando os deslocamentos de pixel e os tamanhos `MaskBlt`de retângulo enviados ao.

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

Altera a transformação mundial para um contexto de dispositivo usando o modo especificado.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a uma estrutura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) usada para modificar a transformação mundial para o contexto de dispositivo fornecido.

*iMode*<br/>
Especifica como os dados de transformação modificam a transformação do mundo atual. Para obter uma lista dos valores que esse parâmetro pode executar, consulte [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valor de retorno

Retorna um valor diferente de zero em caso de êxito.

Retorna 0 em caso de falha.

Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Esse método encapsula a função GDI do Windows [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

##  <a name="moveto"></a>  CDC::MoveTo

Move a posição atual para o ponto especificado por *x* e *y* (ou por *ponto*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da nova posição.

*y*<br/>
Especifica a coordenada y lógica da nova posição.

*point*<br/>
Especifica a nova posição. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

As coordenadas x e y da posição anterior como um `CPoint` objeto.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CRect:: CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

Move a região de recorte do contexto do dispositivo pelos deslocamentos especificados.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica o número de unidades lógicas a serem movidas para a esquerda ou direita.

*y*<br/>
Especifica o número de unidades lógicas a serem movidas para cima ou para baixo.

*size*<br/>
Especifica o valor a ser deslocado.

### <a name="return-value"></a>Valor de retorno

O tipo da nova região. Pode ser qualquer um dos seguintes valores:

- A região de recorte COMPLEXREGION tem bordas sobrepostas.

- O contexto do dispositivo de erro não é válido.

- A região de recorte NULLREGION está vazia.

- A região de recorte SIMPLEREGION não tem bordas sobrepostas.

### <a name="remarks"></a>Comentários

A função move as unidades da região *x* ao longo do eixo x e das unidades *y* ao longo do eixo y.

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

Modifica as coordenadas da origem do visor em relação às coordenadas da origem do visor atual.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*nWidth*<br/>
Especifica o número de unidades de dispositivo a serem adicionadas à coordenada x da origem atual.

*nHeight*<br/>
Especifica o número de unidades de dispositivo a serem adicionadas à coordenada y da origem atual.

### <a name="return-value"></a>Valor de retorno

A origem do visor anterior (em coordenadas do dispositivo) `CPoint` como um objeto.

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

Modifica as coordenadas da origem da janela em relação às coordenadas da origem da janela atual.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*nWidth*<br/>
Especifica o número de unidades lógicas a serem adicionadas à coordenada x da origem atual.

*nHeight*<br/>
Especifica o número de unidades lógicas a serem adicionadas à coordenada y da origem atual.

### <a name="return-value"></a>Valor de retorno

A origem da janela anterior (em coordenadas lógicas) `CPoint` como um objeto.

##  <a name="operator_hdc"></a>CDC:: Operator HDC

Use esse operador para recuperar o identificador de contexto de dispositivo `CDC` do objeto.

```
operator HDC() const;
```

### <a name="return-value"></a>Valor de retorno

Se for bem-sucedido, o identificador do objeto de contexto do dispositivo; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Você pode usar a alça para chamar as APIs do Windows diretamente.

##  <a name="paintrgn"></a>  CDC::PaintRgn

Preenche a região especificada por *pRgn* usando o pincel atual.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Identifica a região a ser preenchida. As coordenadas para a região determinada são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="patblt"></a>  CDC::PatBlt

Cria um padrão de bit no dispositivo.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo que deve receber o padrão.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo que deve receber o padrão.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo que deve receber o padrão.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo que deve receber o padrão.

*dwRop*<br/>
Especifica o código de operação de varredura. Os códigos de operação de rasterização (ROPs) definem como a GDI combina cores nas operações de saída que envolvem um pincel atual, um possível bitmap de origem e um bitmap de destino. Esse parâmetro pode ser um dos seguintes valores:

- PATCOPY copia o padrão para o bitmap de destino.

- PATINVERT combina o bitmap de destino com o padrão usando o operador XOR booliano.

- DSTINVERT inverte o bitmap de destino.

- A BLACKização transforma toda a saída em preto.

- A branco transforma todas as saídas em branco.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O padrão é uma combinação do pincel selecionado e do padrão que já está no dispositivo. O código de operação de varredura especificado por *dwRop* define como os padrões devem ser combinados. As operações de varredura listadas para essa função são um subconjunto limitado dos códigos completos de operação de rasterização de 256 ternário; em particular, um código de operação de varredura que se refere a uma fonte não pode ser usado.

Nem todos os contextos de `PatBlt` dispositivo dão suporte à função. Para determinar se um contexto de dispositivo `PatBlt`dá suporte a `GetDeviceCaps` , chame a função de membro com o índice RASTERCAPS e verifique o valor de retorno para o sinalizador RC_BITBLT.

##  <a name="pie"></a>  CDC::Pie

Desenha uma fatia com formato de pizza desenhando um arco elíptico cujo centro e dois pontos de extremidade são Unidos por linhas.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*Y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*y3*<br/>
Especifica a coordenada y do ponto inicial do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*x4*<br/>
Especifica a coordenada x do ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*Y4*<br/>
Especifica a coordenada y do ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente no arco.

*lpRect*<br/>
Especifica o retângulo delimitador. Você pode passar um `CRect` objeto ou um ponteiro para uma `RECT` estrutura para esse parâmetro.

*ptStart*<br/>
Especifica o ponto inicial do arco. Esse ponto não precisa estar exatamente no arco. Você pode passar uma estrutura de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para esse parâmetro.

*ptEnd*<br/>
Especifica o ponto de extremidade do arco. Esse ponto não precisa estar exatamente no arco. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O centro do arco é o centro do retângulo delimitador especificado por *X1*, *Y1*, *X2*e *Y2* (ou por *lpRect*). Os pontos inicial e final do arco são especificados por *X3*, *y3*, *X4*e *Y4* (ou por *ptStart* e *ptEnd*).

O arco é desenhado com a caneta selecionada, movendo-se uma direção no sentido anti-horário. Duas linhas adicionais são desenhadas de cada ponto de extremidade para o centro do arco. A área em forma de pizza é preenchida com o pincel atual. Se *X3* for igual a *X4* e *y3* for igual a *Y4*, o resultado será uma elipse com uma única linha do centro da elipse até o ponto ( *X3*, *y3*) ou ( *X4*, *Y4*).

A figura desenhada por essa função se estende até, mas não inclui as coordenadas direita e inferior. Isso significa que a altura da figura é *Y2* - *Y1* e a largura da figura é *X2* - *X1*. A largura e a altura do retângulo delimitador devem ser maiores que 2 unidades e menos de 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

Reproduz o conteúdo do metarquivo especificado no contexto do dispositivo.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parâmetros

*hMF*<br/>
Identifica o metarquivo a ser reproduzido.

*hEnhMetaFile*<br/>
Identifica o metarquivo avançado.

*lpBounds*<br/>
Aponta para uma `RECT` estrutura ou um `CRect` objeto que contém as coordenadas do retângulo delimitador usado para exibir a imagem. As coordenadas são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O metarquivo pode ser reproduzido várias vezes.

A segunda versão do `PlayMetaFile` exibe a imagem armazenada no metarquivo de formato avançado fornecido. Quando um aplicativo chama a segunda versão do `PlayMetaFile`, o Windows usa o quadro de imagem no cabeçalho Enhanced-Metafile para mapear a imagem para o retângulo apontado pelo parâmetro *lpBounds* . (Esta imagem pode ser distorceda ou girada definindo a transformação mundial no dispositivo de saída antes de `PlayMetaFile`chamar.) Os pontos ao longo das bordas do retângulo são incluídos na imagem. Uma imagem de metarquivo avançado pode ser recortada definindo a região de recorte no dispositivo de saída antes de reproduzir o metarquivo avançado.

Se um metarquivo avançado contiver uma paleta opcional, um aplicativo poderá obter cores consistentes Configurando uma paleta de cores no dispositivo de saída antes de chamar `PlayMetaFile`a segunda versão do. Para recuperar a paleta opcional, use a `GetEnhMetaFilePaletteEntries` função do Windows. Um metarquivo avançado pode ser inserido em um metarquivo avançado recém-criado chamando a segunda versão do `PlayMetaFile` e reproduzindo o metarquivo avançado de origem no contexto do dispositivo para o novo metarquivo avançado.

Os Estados do contexto do dispositivo de saída são preservados por essa função. Qualquer objeto criado mas não excluído no metarquivo avançado é excluído por essa função. Para interromper essa função, um aplicativo pode chamar a `CancelDC` função do Windows de outro thread para encerrar a operação. Nesse caso, a função retorna zero.

##  <a name="plgblt"></a>  CDC::PlgBlt

Executa uma transferência de bloco de bits dos dados de cor do retângulo especificado no contexto do dispositivo de origem para o paralelogramo especificado no contexto do dispositivo fornecido.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parâmetros

*lpPoint*<br/>
Aponta para uma matriz de três pontos em espaço lógico que identifica três cantos do paralelogramo de destino. O canto superior esquerdo do retângulo de origem é mapeado para o primeiro ponto dessa matriz, o canto superior direito para o segundo ponto nessa matriz e o canto inferior esquerdo para o terceiro ponto. O canto inferior direito do retângulo de origem é mapeado para o quarto ponto implícito no paralelogramo.

*pSrcDC*<br/>
Identifica o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*nWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*maskBitmap*<br/>
Identifica um bitmap monocromático opcional que é usado para mascarar as cores do retângulo de origem.

*xMask*<br/>
Especifica a coordenada x do canto superior esquerdo do bitmap monocromático.

*yMask*<br/>
Especifica a coordenada y do canto superior esquerdo do bitmap monocromático.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se o identificador de bitmask fornecido identificar um bitmap monocromático válido, a função usará esse bitmap para mascarar os bits de dados de cor do retângulo de origem.

O quarto vértice do paralelogramo (D) é definido pelo tratamento dos três primeiros pontos (A, B e C) como vetores e computação D = B + C-A.

Se a bitmask existir, um valor de 1 na máscara indicará que a cor do pixel de origem deve ser copiada para o destino. Um valor de 0 na máscara indica que a cor de pixel de destino não deve ser alterada.

Se o retângulo de máscara for menor do que os retângulos de origem e de destino, a função replicará o padrão de máscara.

As transformações de dimensionamento, tradução e reflexão são permitidas no contexto do dispositivo de origem; no entanto, as transformações de rotação e distorção não são. Se o bitmap de máscara não for um bitmap monocromático, ocorrerá um erro. O modo de alongamento do contexto do dispositivo de destino é usado para determinar como alongar ou compactar os pixels, se necessário. Quando um metarquivo avançado estiver sendo gravado, ocorrerá um erro se o contexto do dispositivo de origem identificar um contexto de dispositivo de metarquivo avançado.

As coordenadas de destino são transformadas de acordo com o contexto do dispositivo de destino; as coordenadas de origem são transformadas de acordo com o contexto do dispositivo de origem. Se a transformação origem tiver uma rotação ou distorção, um erro será retornado. Se os retângulos de destino e de origem não tiverem o mesmo formato de `PlgBlt` cor, o converterá o retângulo de origem para corresponder ao retângulo de destino. Nem todos os dispositivos `PlgBlt`dão suporte. Para obter mais informações, consulte a descrição da funcionalidade de rasterização RC_BITBLT `CDC::GetDeviceCaps` na função membro.

Se os contextos do dispositivo de origem e de destino representarem `PlgBlt` dispositivos incompatíveis, o retornará um erro.

##  <a name="polybezier"></a>  CDC::PolyBezier

Desenha um ou mais Bziers de linha.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas de dados de [ponto](/windows/win32/api/windef/ns-windef-point) que contêm os pontos de extremidade e de controle dos splines.

*nCount*<br/>
Especifica o número de pontos na matriz *lpPoints* . Esse valor deve ser mais de três vezes o número de splines a serem desenhados, porque cada spline Bzier requer dois pontos de controle e um ponto de extremidade, e o spline inicial requer um ponto de partida adicional.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função desenha Bziers cúbicas cúbicos usando os pontos de extremidade e de controle especificados pelo parâmetro *lpPoints* . A primeira spline é desenhada desde o primeiro ponto até o quarto ponto usando o segundo e o terceiro pontos como pontos de controle. Cada spline subsequente na sequência precisa de exatamente mais três pontos: o ponto final da spline anterior é usado como ponto de partida, os dois pontos seguintes na sequência são pontos de controle e o terceiro é o ponto de extremidade.

A posição atual não é usada nem atualizada pela `PolyBezier` função. A figura não está preenchida. Essa função desenha linhas usando a caneta atual.

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

Desenha um ou mais Bziers de linha.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas de dados de [ponto](/windows/win32/api/windef/ns-windef-point) que contém os pontos de extremidade e de controle.

*nCount*<br/>
Especifica o número de pontos na matriz *lpPoints* . Esse valor deve ser três vezes o número de splines a serem desenhadas, porque cada spline Bzier requer dois pontos de controle e um ponto de extremidade.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função desenha as polilinhas cúbicas do Bzier usando os pontos de controle especificados pelo parâmetro *lpPoints* . A primeira spline é desenhada da posição atual para o terceiro ponto usando os dois primeiros pontos como pontos de controle. Para cada spline subsequente, a função precisa de exatamente mais três pontos e usa o ponto de extremidade do spline anterior como o ponto de partida para o próximo. `PolyBezierTo`move a posição atual para o ponto de extremidade do último spline Bzier. A figura não está preenchida. Essa função desenha linhas usando a caneta atual.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: BeginPath](#beginpath).

##  <a name="polydraw"></a>  CDC::PolyDraw

Desenha um conjunto de segmentos de linha e Bzier de linhas.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas de dados de [ponto](/windows/win32/api/windef/ns-windef-point) que contém os pontos de extremidade para cada segmento de linha e os pontos de extremidade e de controle para cada spline Bzier.

*lpTypes*<br/>
Aponta para uma matriz que especifica como cada ponto na matriz *lpPoints* é usado. Os valores podem ser um dos seguintes:

- PT_MOVETO Especifica que esse ponto inicia um valor não contíguo. Esse ponto se torna a nova posição atual.

- PT_LINETO especifica que uma linha deve ser desenhada da posição atual até esse ponto, que então se torna a nova posição atual.

- PT_BEZIERTO Especifica que esse ponto é um ponto de controle ou ponto final para um spline Bzier.

Os tipos PT_BEZIERTO sempre ocorrem em conjuntos de três. A posição atual define o ponto de partida para o spline Bzier. Os dois primeiros pontos PT_BEZIERTO são os pontos de controle, e o terceiro ponto de PT_BEZIERTO é o ponto final. O ponto final se torna a nova posição atual. Se não houver três pontos PT_BEZIERTO consecutivos, ocorrerá um erro.

   Um tipo de PT_LINETO ou PT_BEZIERTO pode ser combinado com a seguinte constante usando o operador bit a bit ou para indicar que o ponto correspondente é o último ponto em uma figura e a figura é fechada:

- PT_CLOSEFIGURE especifica que a figura é fechada automaticamente depois que o tipo PT_LINETO ou PT_BEZIERTO para esse ponto é concluído. Uma linha é desenhada deste ponto para o PT_MOVETO ou `MoveTo` o ponto mais recente.

   Esse sinalizador é combinado com o tipo PT_LINETO para uma linha, ou com o tipo de ponto final PT_BEZIERTO para um spline Bzier, usando **o operador OR** A posição atual é definida como o ponto final da linha de fechamento.

*nCount*<br/>
Especifica o número total de pontos na matriz *lpPoints* , o mesmo que o número de bytes na matriz *lpTypes* .

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função pode ser usada para desenhar números não contíguos no lugar de chamadas consecutivas `CDC::MoveTo`para `CDC::LineTo`funções de `CDC::PolyBezierTo` membro, e. As linhas e as polilinhas são desenhadas usando a caneta atual, e as figuras não são preenchidas. Se houver um caminho ativo iniciado chamando a função de `CDC::BeginPath` membro, `PolyDraw` o adicionará ao caminho. Os pontos contidos na matriz *lpPoints* e em *lpTypes* indicam se cada ponto faz parte de uma `CDC::MoveTo`operação, uma `CDC::LineTo`ou uma. `CDC::BezierTo` Também é possível fechar figuras. Essa função atualiza a posição atual.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: BeginPath](#beginpath).

##  <a name="polygon"></a>  CDC::Polygon

Desenha um polígono que consiste em dois ou mais pontos (vértices) conectados por linhas, usando a caneta atual.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de pontos que especifica os vértices do polígono. Cada ponto na matriz é uma `POINT` estrutura ou um `CPoint` objeto.

*nCount*<br/>
Especifica o número de vértices na matriz.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O sistema fecha o polígono automaticamente, se necessário, desenhando uma linha do último vértice para o primeiro.

O modo de preenchimento de polígono atual pode ser recuperado ou definido usando as `GetPolyFillMode` funções `SetPolyFillMode` de membro e.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

Desenha um conjunto de segmentos de linha conectando os pontos especificados por *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de `POINT` estruturas ou `CPoint` objetos a serem conectados.

*nCount*<br/>
Especifica o número de pontos na matriz. Esse valor deve ser pelo menos 2.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As linhas são desenhadas desde o primeiro ponto até os pontos subsequentes usando a caneta atual. Ao contrário `LineTo` da função membro, `Polyline` a função não usa nem atualiza a posição atual.

Para obter mais informações, consulte [polilinha](/windows/win32/api/wingdi/nf-wingdi-polyline) na SDK do Windows.

##  <a name="polylineto"></a>  CDC::PolylineTo

Desenha uma ou mais linhas retas.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas de dados de [ponto](/windows/win32/api/windef/ns-windef-point) que contém os vértices da linha.

*nCount*<br/>
Especifica o número de pontos na matriz.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Uma linha é desenhada da posição atual até o primeiro ponto especificado pelo parâmetro *lpPoints* usando a caneta atual. Para cada linha adicional, a função desenha a partir do ponto final da linha anterior até o próximo ponto especificado por *lpPoints*. `PolylineTo`move a posição atual para o ponto final da última linha. Se os segmentos de linha desenhados por essa função formarem uma figura fechada, a figura não será preenchida.

##  <a name="polypolygon"></a>  CDC::PolyPolygon

Cria dois ou mais polígonos que são preenchidos usando o modo de preenchimento de polígono atual.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de `POINT` estruturas ou `CPoint` objetos que definem os vértices dos polígonos.

*lpPolyCounts*<br/>
Aponta para uma matriz de inteiros, cada um deles especifica o número de pontos em um dos polígonos na matriz *lpPoints* .

*nCount*<br/>
O número de entradas na matriz *lpPolyCounts* . Esse número especifica o número de polígonos a serem desenhados. Esse valor deve ser pelo menos 2.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os polígonos podem ser não contíguos ou sobrepostos.

Cada polígono especificado em uma chamada para a `PolyPolygon` função deve ser fechado. Ao contrário dos polígonos criados `Polygon` pela função de membro, os polígonos `PolyPolygon` criados por não são fechados automaticamente.

A função cria dois ou mais polígonos. Para criar um único polígono, um aplicativo deve usar a `Polygon` função de membro.

O modo de preenchimento de polígono atual pode ser recuperado ou definido usando as `GetPolyFillMode` funções `SetPolyFillMode` de membro e.

##  <a name="polypolyline"></a>  CDC::PolyPolyline

Desenha várias séries de segmentos de linha conectados.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas que contém os vértices das polilinhas. As polilinhas são especificadas consecutivamente.

*lpPolyPoints*<br/>
Aponta para uma matriz de variáveis especificando o número de pontos na matriz *lpPoints* para o polígono correspondente. Cada entrada deve ser maior ou igual a 2.

*nCount*<br/>
Especifica o número total de contagens na matriz *lpPolyPoints* .

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os segmentos de linha são desenhados usando a caneta atual. As figuras formadas pelos segmentos não são preenchidas. A posição atual não é usada nem atualizada por essa função.

##  <a name="ptvisible"></a>  CDC::PtVisible

Determina se o ponto determinado está dentro da região de recorte do contexto do dispositivo.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto.

*y*<br/>
Especifica a coordenada y lógica do ponto.

*point*<br/>
Especifica o ponto para fazer check-in de coordenadas lógicas. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o ponto especificado estiver dentro da região de recorte; caso contrário, 0.

##  <a name="queryabort"></a>  CDC::QueryAbort

Chama a função Abort instalada pela função membro [SetAbortProc](#setabortproc) para um aplicativo de impressão e consulta se a impressão deve ser encerrada.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valor de retorno

O valor de retorno será diferente de zero se a impressão continuar ou se não houver nenhum procedimento de anulação. Será 0 se o trabalho de impressão deve ser encerrado. O valor de retorno é fornecido pela função Abort.

##  <a name="realizepalette"></a>  CDC::RealizePalette

Mapeia entradas da paleta lógica atual para a paleta do sistema.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valor de retorno

Indica quantas entradas na paleta lógica foram mapeadas para entradas diferentes na paleta do sistema. Isso representa o número de entradas que essa função remapeou para acomodar alterações na paleta do sistema desde que a paleta lógica foi realizada pela última vez.

### <a name="remarks"></a>Comentários

Uma paleta de cores lógicas atua como um buffer entre aplicativos com uso intensivo de cores e o sistema, permitindo que um aplicativo use quantas cores forem necessárias sem interferir em suas próprias cores exibidas ou com cores exibidas por outras janelas.

Quando uma janela tem o foco de entrada e `RealizePalette`as chamadas, o Windows garante que a janela exibirá todas as cores solicitadas, até o número máximo disponível simultaneamente na tela. O Windows também exibe as cores não encontradas na paleta da janela, combinando-as com as cores disponíveis.

Além disso, o Windows corresponde às cores solicitadas por janelas inativas que chamam a função o mais próximo possível das cores disponíveis. Isso reduz significativamente as alterações indesejáveis nas cores exibidas em janelas inativas.

##  <a name="rectangle"></a>  CDC::Rectangle

Desenha um retângulo usando a caneta atual.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo (em unidades lógicas).

*Y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo (em unidades lógicas).

*lpRect*<br/>
Especifica o retângulo em unidades lógicas. Você pode passar um `CRect` objeto ou um ponteiro para uma `RECT` estrutura para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O interior do retângulo é preenchido usando o pincel atual.

O retângulo se estende até, mas não inclui, as coordenadas direita e inferior. Isso significa que a altura do retângulo é *Y2* - *Y1* e a largura do retângulo é *X2* - *X1*. A largura e a altura de um retângulo devem ser maiores que 2 unidades e menos de 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

Determina se qualquer parte do retângulo fornecido está dentro da região de recorte do contexto de exibição.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para uma `RECT` estrutura ou um `CRect` objeto que contém as coordenadas lógicas do retângulo especificado.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se alguma parte do retângulo fornecido estiver dentro da região de recorte; caso contrário, 0.

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

Chame essa função de membro para `m_hAttribDC` definir como NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Comentários

Isso não causa a ocorrência `Detach` de um. Somente o contexto do dispositivo de saída é anexado `CDC` ao objeto e somente ele pode ser desanexado.

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

Chame essa função de membro para definir `m_hDC` o membro como nulo.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Comentários

Esta função de membro não pode ser chamada quando o contexto do dispositivo de saída `CDC` é anexado ao objeto. Use a `Detach` função membro para desanexar o contexto do dispositivo de saída.

##  <a name="resetdc"></a>  CDC::ResetDC

Chame essa função de membro para atualizar o contexto do dispositivo encapsulado pelo `CDC` objeto.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parâmetros

*lpDevMode*<br/>
Um ponteiro para uma estrutura `DEVMODE` do Windows.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo é atualizado a partir das informações especificadas na `DEVMODE` estrutura do Windows. Essa função de membro apenas redefine o contexto do dispositivo de atributo.

Normalmente, um aplicativo usará `ResetDC` a função membro quando uma janela processar `WM_DEVMODECHANGE` uma mensagem. Você também pode usar essa função de membro para alterar a orientação do papel ou os compartimentos do papel ao imprimir um documento.

Você não pode usar essa função de membro para alterar o nome do driver, o nome do dispositivo ou a porta de saída. Quando o usuário altera a conexão de porta ou o nome do dispositivo, você deve excluir o contexto do dispositivo original e criar um novo contexto de dispositivo com as novas informações.

Antes de chamar essa função de membro, você deve garantir que todos os objetos (exceto os objetos de estoque) selecionados no contexto do dispositivo tenham sido selecionados.

##  <a name="restoredc"></a>  CDC::RestoreDC

Restaura o contexto do dispositivo para o estado anterior identificado por *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parâmetros

*nSavedDC*<br/>
Especifica o contexto do dispositivo a ser restaurado. Pode ser um valor retornado por uma chamada de `SaveDC` função anterior. Se *nSavedDC* for-1, o contexto de dispositivo salvo mais recentemente será restaurado.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o contexto especificado tiver sido restaurado; caso contrário, 0.

### <a name="remarks"></a>Comentários

`RestoreDC`restaura o contexto do dispositivo exibindo informações de estado de uma pilha criada por chamadas anteriores para a função `SaveDC` de membro.

A pilha pode conter as informações de estado para vários contextos de dispositivo. Se o contexto especificado por *nSavedDC* não estiver no topo da pilha, `RestoreDC` o excluirá todas as informações de estado entre o contexto do dispositivo especificado por *nSavedDC* e a parte superior da pilha. As informações excluídas são perdidas.

##  <a name="roundrect"></a>  CDC::RoundRect

Desenha um retângulo com cantos arredondados usando a caneta atual.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo (em unidades lógicas).

*Y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo (em unidades lógicas).

*x3*<br/>
Especifica a largura da elipse usada para desenhar os cantos arredondados (em unidades lógicas).

*y3*<br/>
Especifica a altura da elipse usada para desenhar os cantos arredondados (em unidades lógicas).

*lpRect*<br/>
Especifica o retângulo delimitador em unidades lógicas. Você pode passar um `CRect` objeto ou um ponteiro para uma `RECT` estrutura para esse parâmetro.

*point*<br/>
A coordenada x de *ponto* especifica a largura da elipse para desenhar os cantos arredondados (em unidades lógicas). A coordenada y do *ponto* especifica a altura da elipse para desenhar os cantos arredondados (em unidades lógicas). Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O interior do retângulo é preenchido usando o pincel atual.

A figura que a função desenha estende até, mas não inclui as coordenadas direita e inferior. Isso significa que a altura da figura é *Y2* - *Y1* e a largura da figura é *X2* - *X1*. A altura e a largura do retângulo delimitador devem ser maiores que 2 unidades e menos de 32.767 unidades.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

Salva o estado atual do contexto do dispositivo copiando informações de estado (como região de recorte, objetos selecionados e modo de mapeamento) para uma pilha de contexto mantida pelo Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valor de retorno

Um inteiro que identifica o contexto do dispositivo salvo. Será 0 se ocorrer um erro. Esse valor de retorno pode ser usado para restaurar o contexto do dispositivo `RestoreDC`chamando.

### <a name="remarks"></a>Comentários

O contexto do dispositivo salvo pode ser restaurado posteriormente `RestoreDC`usando.

`SaveDC`pode ser usado várias vezes para salvar qualquer número de Estados de contexto de dispositivo.

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

Modifica as extensões do visor relativas aos valores atuais.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parâmetros

*xNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão x atual.

*xDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão x atual pelo valor do parâmetro *xNum* .

*yNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão y atual.

*yDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão y atual pelo valor do parâmetro *yNum* .

### <a name="return-value"></a>Valor de retorno

As extensões do visor anteriores (em unidades do dispositivo) como `CSize` um objeto.

### <a name="remarks"></a>Comentários

As fórmulas são escritas da seguinte maneira:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

As novas extensões do visor são calculadas multiplicando as extensões atuais pelo numerador fornecido e, em seguida, dividindo pelo denominador especificado.

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

Modifica as extensões de janela relativas aos valores atuais.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parâmetros

*xNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão x atual.

*xDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão x atual pelo valor do parâmetro *xNum* .

*yNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão y atual.

*yDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação da extensão y atual pelo valor do parâmetro *yNum* .

### <a name="return-value"></a>Valor de retorno

As extensões de janela anteriores (em unidades lógicas) como `CSize` um objeto.

### <a name="remarks"></a>Comentários

As fórmulas são escritas da seguinte maneira:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

As novas extensões de janela são calculadas multiplicando as extensões atuais pelo numerador fornecido e, em seguida, dividindo pelo denominador especificado.

##  <a name="scrolldc"></a>  CDC::ScrollDC

Rola um retângulo de bits horizontal e verticalmente.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parâmetros

*dx*<br/>
Especifica o número de unidades de rolagem horizontal.

*dy*<br/>
Especifica o número de unidades de rolagem vertical.

*lpRectScroll*<br/>
Aponta para a `RECT` estrutura ou `CRect` o objeto que contém as coordenadas do retângulo de rolagem.

*lpRectClip*<br/>
Aponta para a `RECT` estrutura ou `CRect` o objeto que contém as coordenadas do retângulo de recorte. Quando esse retângulo é menor do que o original apontado por *lpRectScroll*, a rolagem ocorre apenas no retângulo menor.

*pRgnUpdate*<br/>
Identifica a região descoberta pelo processo de rolagem. A `ScrollDC` função define essa região; ela não é necessariamente um retângulo.

*lpRectUpdate*<br/>
Aponta para a `RECT` estrutura ou `CRect` o objeto que recebe as coordenadas do retângulo que limita a região de atualização de rolagem. Essa é a maior área retangular que requer repintura. Os valores na estrutura ou no objeto quando a função retorna estão em coordenadas de cliente, independentemente do modo de mapeamento para o contexto de dispositivo fornecido.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a rolagem for executada; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se *lpRectUpdate* for nulo, o Windows não computará o retângulo de atualização. Se *prgnUpdate* e *lpRectUpdate* forem nulos, o Windows não computará a região de atualização. Se *prgnUpdate* não for NULL, o Windows pressupõe que ele contém um ponteiro válido para a região descoberta pelo processo de rolagem (definido pela função de `ScrollDC` membro). A região de atualização retornada em *lpRectUpdate* pode ser passada `CWnd::InvalidateRgn` para, se necessário.

Um aplicativo deve usar a `ScrollWindow` função de membro da `CWnd` classe quando for necessário rolar toda a área do cliente de uma janela. Caso contrário, ele deve `ScrollDC`usar.

##  <a name="selectclippath"></a>  CDC::SelectClipPath

Seleciona o caminho atual como uma região de recorte para o contexto do dispositivo, combinando a nova região com qualquer região de recorte existente usando o modo especificado.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parâmetros

*nMode*<br/>
Especifica a maneira de usar o caminho. Os seguintes valores são permitidos:

- RGN_AND a nova região de recorte inclui a interseção (áreas sobrepostas) da região de recorte atual e o caminho atual.

- RGN_COPY a nova região de recorte é o caminho atual.

- RGN_DIFF a nova região de recorte inclui as áreas da região de recorte atual e as do caminho atual são excluídas.

- RGN_OR a nova região de recorte inclui a União (áreas combinadas) da região de recorte atual e o caminho atual.

- RGN_XOR a nova região de recorte inclui a União da região de recorte atual e o caminho atual, mas sem as áreas sobrepostas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo identificado deve conter um caminho fechado.

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

Seleciona a região especificada como a região de recorte atual para o contexto do dispositivo.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Identifica a região a ser selecionada.

- Para a primeira versão dessa função, se esse valor for NULL, toda a área do cliente será selecionada e a saída ainda será recortada na janela.

- Para a segunda versão dessa função, esse identificador pode ser nulo somente quando o modo RGN_COPY é especificado.

*nMode*<br/>
Especifica a operação a ser executada. Deve ser um dos seguintes valores:

- RGN_AND a nova região de recorte combina as áreas sobrepostas da região de recorte atual e a região identificada por *pRgn*.

- RGN_COPY a nova região de recorte é uma cópia da região identificada por *pRgn*. Essa funcionalidade é idêntica à primeira versão do `SelectClipRgn`. Se a região identificada por *pRgn* for nula, a nova região de recorte se tornará a região de recorte padrão (uma região nula).

- RGN_DIFF a nova região de recorte combina as áreas da região de recorte atual com as áreas excluídas da região identificada por *pRgn*.

- RGN_OR a nova região de recorte combina a região de recorte atual e a região identificada por *pRgn*.

- RGN_XOR a nova região de recorte combina a região de recorte atual e a região identificada por *pRgn* , mas exclui todas as áreas sobrepostas.

### <a name="return-value"></a>Valor de retorno

O tipo da região. Pode ser qualquer um dos seguintes valores:

- COMPLEXREGION nova região de recorte tem bordas sobrepostas.

- O contexto ou a região do dispositivo de erro não é válido.

- NULLREGION nova região de recorte está vazia.

- SIMPLEREGION Nova região de recorte não tem bordas sobrepostas.

### <a name="remarks"></a>Comentários

Somente uma cópia da região selecionada é usada. A própria região pode ser selecionada para qualquer número de outros contextos de dispositivo ou pode ser excluída.

A função pressupõe que as coordenadas para a região determinada são especificadas nas unidades do dispositivo. Alguns dispositivos de impressora dão suporte à saída de texto em uma resolução mais alta que a saída de gráficos para manter a precisão necessária para expressar métricas de texto. Esses dispositivos relatam unidades de dispositivo na resolução mais alta, ou seja, em unidades de texto. Em seguida, esses dispositivos dimensionam coordenadas para gráficos para que várias unidades de dispositivo relatadas sejam mapeadas para apenas 1 unidade gráfica. Você sempre deve chamar a `SelectClipRgn` função usando unidades de texto.

Os aplicativos que devem assumir a escala de objetos gráficos no GDI podem usar o escape de impressora GETSCALINGFACTOR para determinar o fator de dimensionamento. Esse fator de dimensionamento afeta o recorte. Se uma região for usada para recortar gráficos, o GDI dividirá as coordenadas pelo fator de dimensionamento. Se a região for usada para recortar o texto, o GDI não fará nenhum ajuste de dimensionamento. Um fator de dimensionamento 1 faz com que as coordenadas sejam divididas por 2; um fator de dimensionamento 2 faz com que as coordenadas sejam divididas por 4; e assim por diante.

##  <a name="selectobject"></a>  CDC::SelectObject

Seleciona um objeto no contexto do dispositivo.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parâmetros

*pPen*<br/>
Um ponteiro para um objeto [CPen](../../mfc/reference/cpen-class.md) a ser selecionado.

*pBrush*<br/>
Um ponteiro para um objeto [CBrush](../../mfc/reference/cbrush-class.md) a ser selecionado.

*pFont*<br/>
Um ponteiro para um objeto [CFont](../../mfc/reference/cfont-class.md) a ser selecionado.

*pBitmap*<br/>
Um ponteiro para um objeto [CBitmap](../../mfc/reference/cbitmap-class.md) a ser selecionado.

*pRgn*<br/>
Um ponteiro para um objeto [CRgn](../../mfc/reference/crgn-class.md) a ser selecionado.

*pObject*<br/>
Um ponteiro para um objeto [CGdiObject](../../mfc/reference/cgdiobject-class.md) a ser selecionado.

### <a name="return-value"></a>Valor de retorno

Um ponteiro para o objeto que está sendo substituído. Esse é um ponteiro para um objeto de uma das classes derivadas de `CGdiObject`, `CPen`como, dependendo de qual versão da função é usada. O valor de retorno será nulo se houver um erro. Essa função pode retornar um ponteiro para um objeto temporário. Esse objeto temporário só é válido durante o processamento de uma mensagem do Windows. Para obter mais informações, consulte `CGdiObject::FromHandle`.

A versão da função de membro que usa um parâmetro de região executa a mesma tarefa que `SelectClipRgn` a função de membro. Seu valor de retorno pode ser qualquer um dos seguintes:

- COMPLEXREGION nova região de recorte tem bordas sobrepostas.

- O contexto ou a região do dispositivo de erro não é válido.

- NULLREGION nova região de recorte está vazia.

- SIMPLEREGION Nova região de recorte não tem bordas sobrepostas.

### <a name="remarks"></a>Comentários

A `CDC` classe fornece cinco versões especializadas para tipos específicos de objetos GDI, incluindo canetas, pincéis, fontes, bitmaps e regiões. O objeto recentemente selecionado substitui o objeto anterior do mesmo tipo. Por exemplo, se *pObject* da versão geral de `SelectObject` aponta para um objeto [CPen](../../mfc/reference/cpen-class.md) , a função substituirá a caneta atual pela caneta especificada por *pObject*.

Um aplicativo pode selecionar um bitmap somente em contextos de dispositivo de memória e em um único contexto de dispositivo de memória por vez. O formato do bitmap deve ser monocromático ou compatível com o contexto do dispositivo; Se não for, `SelectObject` retornará um erro.

Para o Windows 3,1 e posterior, `SelectObject` a função retorna o mesmo valor, independentemente de ser usada em um metarquivo ou não. Em versões anteriores do Windows, `SelectObject` retornou um valor diferente de zero para êxito e 0 para falha quando ele foi usado em um metarquivo.

##  <a name="selectpalette"></a>  CDC::SelectPalette

Seleciona a paleta lógica especificada por *pPalette* como o objeto de paleta selecionado do contexto do dispositivo.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parâmetros

*pPalette*<br/>
Identifica a paleta lógica a ser selecionada. Esta paleta já deve ter sido criada com a `CPalette`função de membro [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Especifica se a paleta lógica é forçada a ser uma paleta de plano de fundo. Se *bForceBackground* for diferente de zero, a paleta selecionada será sempre uma paleta de plano de fundo, independentemente de a janela ter o foco de entrada. Se *bForceBackground* for 0 e o contexto do dispositivo for anexado a uma janela, a paleta lógica será uma paleta de primeiro plano quando a janela tiver o foco de entrada.

### <a name="return-value"></a>Valor de retorno

Um ponteiro para um `CPalette` objeto que identifica a paleta lógica substituída pela paleta especificada por *pPalette*. Será nulo se houver um erro.

### <a name="remarks"></a>Comentários

A nova paleta torna-se o objeto Palette usado pelo GDI para controlar as cores exibidas no contexto do dispositivo e substitui a paleta anterior.

Um aplicativo pode selecionar uma paleta lógica em mais de um contexto de dispositivo. No entanto, as alterações em uma paleta lógica afetarão todos os contextos de dispositivo para os quais ele está selecionado. Se um aplicativo selecionar uma paleta em mais de um contexto de dispositivo, os contextos de dispositivo deverão pertencer ao mesmo dispositivo físico.

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

Seleciona um objeto [CGdiObject](../../mfc/reference/cgdiobject-class.md) que corresponde a uma das canetas, pincéis ou fontes de ações predefinidas.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parâmetros

*nIndex*<br/>
Especifica o tipo de objeto de estoque desejado. Pode ser um dos seguintes valores:

- Pincel preto BLACK_BRUSH.

- Pincel cinza escuro DKGRAY_BRUSH.

- Pincel cinza GRAY_BRUSH.

- Pincel vazado HOLLOW_BRUSH.

- Pincel cinza-claro LTGRAY_BRUSH.

- Pincel nulo NULL_BRUSH.

- Pincel branco WHITE_BRUSH.

- Caneta preta BLACK_PEN.

- Caneta NULL_PEN nula.

- Caneta branca WHITE_PEN.

- Fonte de sistema fixa ANSI_FIXED_FONT ANSI.

- Fonte do sistema de variáveis ANSI ANSI_VAR_FONT.

- Fonte dependente do dispositivo DEVICE_DEFAULT_FONT.

- Fonte fixa dependente do OEM_FIXED_FONT OEM.

- SYSTEM_FONT a fonte do sistema. Por padrão, o Windows usa a fonte do sistema para desenhar menus, controles de caixa de diálogo e outro texto. No entanto, é melhor não confiar em SYSTEM_FONT para obter a fonte usada por caixas de diálogo e janelas. Em vez disso, `SystemParametersInfo` use a função com o parâmetro SPI_GETNONCLIENTMETRICS para recuperar a fonte atual. `SystemParametersInfo`leva em conta o tema atual e fornece informações sobre fontes para legendas, menus e caixas de diálogo de mensagens.

- SYSTEM_FIXED_FONT a fonte do sistema de largura fixa usada no Windows antes da versão 3,0. Esse objeto está disponível para compatibilidade com versões anteriores do Windows.

- DEFAULT_PALETTE paleta de cores padrão. Essa paleta consiste em 20 cores estáticas na paleta do sistema.

### <a name="return-value"></a>Valor de retorno

Um ponteiro para o `CGdiObject` objeto que foi substituído se a função for bem-sucedida. O objeto real apontado é um objeto [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md)ou [CFont](../../mfc/reference/cfont-class.md) . Se a chamada não for bem-sucedida, o valor de retorno será nulo.

##  <a name="setabortproc"></a>  CDC::SetAbortProc

Instala o procedimento Abort para o trabalho de impressão.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parâmetros

*lpfn*<br/>
Um ponteiro para a função Abort a ser instalado como o procedimento Abort. Para obter mais informações sobre a função de retorno de chamada, consulte [função de retorno de chamada para CDC:: SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valor de retorno

Especifica o resultado da `SetAbortProc` função. Alguns dos valores a seguir são mais prováveis do que outros, mas todos são possíveis.

- Erro geral de SP_ERROR.

- SP_OUTOFDISK espaço em disco insuficiente atualmente está disponível para o spool e não haverá mais espaço disponível.

- SP_OUTOFMEMORY não há memória suficiente disponível para o spool.

- O usuário SP_USERABORT finalizou o trabalho por meio do Gerenciador de impressão.

### <a name="remarks"></a>Comentários

Se um aplicativo for permitir que o trabalho de impressão seja cancelado durante o spool, ele deverá definir a função Abort antes que o trabalho de impressão seja iniciado com a função de membro [StartDoc](#startdoc) . O Gerenciador de impressão chama a função Abort durante o spool para permitir que o aplicativo cancele o trabalho de impressão ou processe condições de espaço em disco insuficientes. Se nenhuma função Abort for definida, o trabalho de impressão falhará se não houver espaço em disco suficiente para o spooling.

Observe que os recursos do Microsoft Visual C++ simplificam a criação da função de retorno de `SetAbortProc`chamada passada para. O endereço passado para a `EnumObjects` função membro é um ponteiro para uma função exportada com `__declspec(dllexport)` e `__stdcall` com a Convenção de chamada.

Você também não precisa exportar o nome da função em uma instrução **Exports** no arquivo de definição de módulo do aplicativo. Em vez disso, você pode usar o modificador da função de **exportação** , como em

**exportação de retorno de chamada bool** AFunction ( **HDC**, `int` **);**

para fazer com que o compilador emita o registro de exportação adequado para exportação por nome sem alias. Isso funciona para a maioria das necessidades. Para alguns casos especiais, como a exportação de uma função por ordinal ou alias da exportação, você ainda precisa usar uma instrução **Exports** em um arquivo de definição de módulo.

As interfaces de registro de retorno de chamada agora são de tipo seguro (você deve passar um ponteiro de função que aponta para o tipo certo de função para o retorno de chamada específico).

Observe também que todas as funções de retorno de chamada devem interceptar exceções do Microsoft Foundation antes de retornar ao Windows, pois as exceções não podem ser lançadas em limites de retorno de chamada Para obter mais informações sobre exceções, consulte o artigo [exceções](../../mfc/exception-handling-in-mfc.md).

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

Define a direção do desenho a ser usada para as funções Arc e Rectangle.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parâmetros

*nArcDirection*<br/>
Especifica a nova direção do arco. Esse parâmetro pode ser um dos seguintes valores:

- AD_COUNTERCLOCKWISE figuras desenhadas no sentido anti-horário.

- AD_CLOCKWISE figuras desenhadas no sentido horário.

### <a name="return-value"></a>Valor de retorno

Especifica a direção do arco antiga, se for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A direção padrão é anti-horário. A `SetArcDirection` função especifica a direção na qual as seguintes funções são desenhadas:

|Arco|Pizza|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

Chame essa função para definir o contexto do dispositivo de `m_hAttribDC`atributo,.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Um contexto de dispositivo do Windows.

### <a name="remarks"></a>Comentários

Essa função de membro não anexa o contexto do dispositivo ao `CDC` objeto. Somente o contexto do dispositivo de saída é anexado `CDC` a um objeto.

##  <a name="setbkcolor"></a>  CDC::SetBkColor

Define a cor do plano de fundo atual como a cor especificada.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a nova cor do plano de fundo.

### <a name="return-value"></a>Valor de retorno

A cor do plano de fundo anterior como um valor de cor RGB. Se ocorrer um erro, o valor de retorno será 0x80000000.

### <a name="remarks"></a>Comentários

Se o modo em segundo plano for opaco, o sistema usará a cor do plano de fundo para preencher as lacunas nas linhas com estilo, as lacunas entre linhas hachuradas em pincéis e o plano de fundo em células de caracteres. O sistema também usa a cor do plano de fundo ao converter bitmaps entre contextos de dispositivo de cor e monocromático.

Se o dispositivo não puder exibir a cor especificada, o sistema definirá a cor da tela de fundo como a cor física mais próxima.

##  <a name="setbkmode"></a>  CDC::SetBkMode

Define o modo de segundo plano.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parâmetros

*nBkMode*<br/>
Especifica o modo a ser definido. Esse parâmetro pode ser um dos seguintes valores:

- O plano de fundo opaco é preenchido com a cor do plano de fundo atual antes do texto, do pincel hachurado ou da caneta ser desenhada. Esse é o modo padrão em segundo plano.

- O plano de fundo transparente não é alterado antes do desenho.

### <a name="return-value"></a>Valor de retorno

O modo de segundo plano anterior.

### <a name="remarks"></a>Comentários

O modo em segundo plano define se o sistema remove as cores de plano de fundo existentes na superfície de desenho antes de desenhar texto, pincéis hachurados ou qualquer estilo de caneta que não seja uma linha sólida.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CWnd:: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

Controla a acumulação de informações de retângulo delimitador para o contexto de dispositivo especificado.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parâmetros

*lpRectBounds*<br/>
Aponta para uma `RECT` estrutura ou `CRect` objeto que é usado para definir o retângulo delimitador. As dimensões de retângulo são dadas em coordenadas lógicas. Esse parâmetro pode ser nulo.

*flags*<br/>
Especifica como o novo retângulo será combinado com o retângulo acumulado. Esse parâmetro pode ser uma combinação dos seguintes valores:

- DCB_ACCUMULATE adicione o retângulo especificado por *lpRectBounds* ao retângulo delimitador (usando uma operação Rectangle-Union).

- DCB_DISABLE desativar acumulação de limites.

- DCB_ENABLE ativar acumulação de limites. (A configuração padrão para acumulação de limites está desabilitada.)

### <a name="return-value"></a>Valor de retorno

O estado atual do retângulo delimitador, se a função for bem-sucedida. Como os *sinalizadores*, o valor de retorno pode ser uma combinação de valores de **DCB_** :

- DCB_ACCUMULATE o retângulo delimitador não está vazio. Esse valor sempre será definido.

- A acumulação de limites de DCB_DISABLE está desativada.

- A acumulação de limites de DCB_ENABLE está ativada.

### <a name="remarks"></a>Comentários

O Windows pode manter um retângulo delimitador para todas as operações de desenho. Esse retângulo pode ser consultado e redefinido pelo aplicativo. Os limites de desenho são úteis para invalidar caches de bitmap.

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

Especifica a origem que o GDI atribuirá ao próximo pincel que o aplicativo seleciona no contexto do dispositivo.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades de dispositivo) da nova origem. Esse valor deve estar no intervalo de 0-7.

*y*<br/>
Especifica a coordenada y (em unidades de dispositivo) da nova origem. Esse valor deve estar no intervalo de 0-7.

*point*<br/>
Especifica as coordenadas x e y da nova origem. Cada valor deve estar no intervalo de 0-7. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

A origem anterior do pincel nas unidades do dispositivo.

### <a name="remarks"></a>Comentários

As coordenadas padrão para a origem do pincel são (0, 0). Para alterar a origem de um pincel, chame a `UnrealizeObject` função para o `CBrush` objeto, chame `SetBrushOrg`e, em seguida, `SelectObject` chame a função Member para selecionar o pincel no contexto do dispositivo.

Não use `SetBrushOrg` com objetos Stock `CBrush` .

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

Define os valores de ajuste de cor para o contexto do dispositivo usando os valores especificados.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parâmetros

*lpColorAdjust*<br/>
Aponta para uma estrutura de dados [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) que contém os valores de ajuste de cor.

### <a name="return-value"></a>Valor de retorno

Diferente de zero, se for bem-sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os valores de ajuste de cor são usados para ajustar a cor de entrada do bitmap de origem para `CDC::StretchBlt` chamadas para a função de membro quando o modo de meio-tom é definido.

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

Define a cor do pincel do contexto do dispositivo atual (DC) como o valor de cor especificado.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a nova cor do pincel.

### <a name="return-value"></a>Valor de retorno

Se a função for realizada com sucesso, o valor de retorno especificará a cor anterior do pincel do DC como um valor COLORREF.

Se a função falhar, o valor de retorno será CLR_INVALID.

### <a name="remarks"></a>Comentários

Esse método emula a funcionalidade da função [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), conforme descrito na SDK do Windows.

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

Define a cor da caneta do contexto do dispositivo atual (DC) como o valor de cor especificado.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a nova cor da caneta.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função de membro utiliza a função [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor)do Win32, conforme descrito na SDK do Windows.

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

Define o modo gráfico para o contexto do dispositivo especificado.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parâmetros

*iMode*<br/>
Especifica o modo gráfico. Para obter uma lista dos valores que esse parâmetro pode executar, consulte [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valor de retorno

Retorna o modo de gráficos antigo em caso de sucesso.

Retorna 0 em caso de falha. Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Esse método encapsula a função GDI do Windows [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

##  <a name="setlayout"></a>  CDC::SetLayout

Chame essa função de membro para alterar o layout do texto e dos gráficos de um contexto de dispositivo para a direita para a esquerda, o layout padrão para culturas como árabe e Hebraico.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parâmetros

*dwLayout*<br/>
Layout de contexto de dispositivo e sinalizadores de controle de bitmap. Pode ser uma combinação dos valores a seguir.

|Valor|Significado|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Desabilita qualquer reflexão para chamadas para [CDC:: BitBlt](#bitblt) e [CDC:: StretchBlt](#stretchblt).|
|LAYOUT_RTL|Define o layout horizontal padrão como da direita para a esquerda.|
|LAYOUT_LTR|Define o layout padrão como da esquerda para a direita.|

### <a name="return-value"></a>Valor de retorno

Se for bem-sucedido, o layout anterior do contexto do dispositivo.

Se não for bem-sucedida, GDI_ERROR. Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Normalmente, você não chamaria `SetLayout` uma janela. Em vez disso, você controla o layout da direita para a esquerda em uma janela definindo os [estilos de janela estendidos](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) , como WS_EX_RTLREADING. Um contexto de dispositivo, como uma impressora ou um metarquivo, não herda esse layout. A única maneira de definir o contexto do dispositivo para um layout da direita para a esquerda é chamando `SetLayout`.

Se você chamar **SetLayout (LAYOUT_RTL** ), `SetLayout` o alterará automaticamente o modo de mapeamento para MM_ISOTROPIC. Como resultado, uma chamada subsequente para [GetMapMode](#getmapmode) retornará MM_ISOTROPIC em vez de MM_TEXT.

Em alguns casos, como com muitos bitmaps, talvez você queira preservar o layout da esquerda para a direita. Nesses casos, processe a imagem chamando `BitBlt` ou `StretchBlt`, em seguida, defina o sinalizador de controle bitmap para *dwLayout* como LAYOUT_BITMAPORIENTATIONPRESERVED.

Depois de alterar o layout com o sinalizador LAYOUT_RTL, os sinalizadores normalmente que especificam a direita ou esquerda são invertidos. Para evitar confusão, talvez você queira definir nomes alternativos para os sinalizadores padrão. Para obter uma lista de nomes de sinalizadores alternativos sugeridos, consulte [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) na SDK do Windows.

##  <a name="setmapmode"></a>  CDC::SetMapMode

Define o modo de mapeamento.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parâmetros

*nMapMode*<br/>
Especifica o novo modo de mapeamento. Pode ser qualquer um dos seguintes valores:

- As unidades lógicas MM_ANISOTROPIC são convertidas em unidades arbitrárias com eixos de escala arbitrariamente. Definir o modo de mapeamento para MM_ANISOTROPIC não altera as configurações atuais da janela ou do visor. Para alterar as unidades, a orientação e o dimensionamento, chame as funções de membro [SetWindowExt](#setwindowext) e [SetViewportExt](#setviewportext) .

- MM_HIENGLISH Cada unidade lógica é convertida em 0, 1 polegada. X positivo está à direita; y positivo está ativo.

- MM_HIMETRIC Cada unidade lógica é convertida em 0, 1 milímetros. X positivo está à direita; y positivo está ativo.

- As unidades lógicas MM_ISOTROPIC são convertidas em unidades arbitrárias com eixos igualmente dimensionados; ou seja, 1 unidade ao longo do eixo x é igual a 1 unidade ao longo do eixo y. Use as `SetWindowExt` funções `SetViewportExt` de membro e para especificar as unidades desejadas e a orientação dos eixos. O GDI faz ajustes conforme necessário para garantir que as unidades x e y permaneçam com o mesmo tamanho.

- MM_LOENGLISH cada unidade lógica é convertida em 0, 1 polegada. X positivo está à direita; y positivo está ativo.

- MM_LOMETRIC cada unidade lógica é convertida em 0,1 milímetros. X positivo está à direita; y positivo está ativo.

- MM_TEXT cada unidade lógica é convertida em 1 pixel do dispositivo. X positivo está à direita; y positivo está inoperante.

- MM_TWIPS cada unidade lógica é convertida em 1/20 de um ponto. (Como um ponto é de 1/72 polegadas, um twip é de 1/1440 polegadas.) X positivo está à direita; y positivo está ativo.

### <a name="return-value"></a>Valor de retorno

O modo de mapeamento anterior.

### <a name="remarks"></a>Comentários

O modo de mapeamento define a unidade de medida usada para converter unidades lógicas em unidades de dispositivo; Ele também define a orientação dos eixos x e y do dispositivo. O GDI usa o modo de mapeamento para converter coordenadas lógicas nas coordenadas apropriadas do dispositivo. O modo MM_TEXT permite que os aplicativos funcionem em pixels de dispositivo, em que 1 unidade é igual a 1 pixel. O tamanho físico de um pixel varia de dispositivo para dispositivo.

Os modos MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC e MM_TWIPS são úteis para aplicativos que devem desenhar em unidades fisicamente significativas (como polegadas ou milímetros). O modo MM_ISOTROPIC garante uma taxa de proporção de 1:1, que é útil quando é importante preservar a forma exata de uma imagem. O modo MM_ANISOTROPIC permite que as coordenadas x e y sejam ajustadas de forma independente.

> [!NOTE]
>  Se você chamar [SetLayout](#setlayout) para alterar o controlador de domínio (contexto do dispositivo) para o layout da direita `SetLayout` para a esquerda, o alterará automaticamente o modo de mapeamento para MM_ISOTROPIC.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [cvisualização:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

Altera o método usado pelo mapeador de fontes quando ele converte uma fonte lógica em uma fonte física.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parâmetros

*dwFlag*<br/>
Especifica se o mapeador de fontes tenta corresponder a uma altura e largura de proporção de uma fonte para o dispositivo. Quando esse valor é ASPECT_FILTERING, o mapeador seleciona apenas as fontes cujo aspecto x e aspecto y correspondem exatamente às do dispositivo especificado.

### <a name="return-value"></a>Valor de retorno

O valor anterior do sinalizador Font-Mapper.

### <a name="remarks"></a>Comentários

Um aplicativo pode usar `SetMapperFlags` o para fazer com que o mapeador de fontes tente escolher apenas uma fonte física que corresponda exatamente à taxa de proporção do dispositivo especificado.

Um aplicativo que usa apenas fontes de varredura pode usar `SetMapperFlags` a função para garantir que a fonte selecionada pelo mapeador de fontes seja atraente e legível no dispositivo especificado. Os aplicativos que usam fontes escalonáveis (TrueType) normalmente não `SetMapperFlags`usam.

Se nenhuma fonte física tiver uma taxa de proporção que corresponda à especificação na fonte lógica, o GDI escolherá uma nova taxa de proporção e selecionará uma fonte que corresponda a essa nova taxa de proporção.

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

Define o limite para o comprimento de junções de Mitre para o contexto do dispositivo.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parâmetros

*fMiterLimit*<br/>
Especifica o novo limite de mitra para o contexto do dispositivo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O comprimento de Mitre é definido como a distância da interseção das paredes de linha no interior da junção com a interseção das paredes de linha no exterior da junção. O limite de Mitre é a proporção máxima permitida do comprimento de Mitre para a largura da linha. O limite de Mitre padrão é 10,0.

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

Chame essa função de membro para definir o contexto do dispositivo `m_hDC`de saída,.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Um contexto de dispositivo do Windows.

### <a name="remarks"></a>Comentários

Essa função de membro só pode ser chamada quando um contexto de dispositivo não foi anexado ao `CDC` objeto. Essa função `m_hDC` `CDC` de membro define, mas não anexa o contexto do dispositivo ao objeto.

##  <a name="setpixel"></a>  CDC::SetPixel

Define o pixel no ponto especificado para a aproximação mais próxima da cor especificada por *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto a ser definido.

*y*<br/>
Especifica a coordenada y lógica do ponto a ser definido.

*crColor*<br/>
Um valor RGB COLORREF que especifica a cor usada para pintar o ponto. Consulte [COLORREF](/windows/win32/gdi/colorref) no SDK do Windows para obter uma descrição desse valor.

*point*<br/>
Especifica as coordenadas x e y lógicas do ponto a ser definido. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Um valor RGB para a cor em que o ponto é realmente pintado. Esse valor pode ser diferente do especificado por *crColor* se uma aproximação dessa cor for usada. Se a função falhar (se o ponto estiver fora da região de recorte), o valor de retorno será-1.

### <a name="remarks"></a>Comentários

O ponto deve estar na região de recorte. Se o ponto não estiver na região de recorte, a função não fará nada.

Nem todos os dispositivos oferecem suporte à função `SetPixel`. Para determinar se um dispositivo dá `SetPixel`suporte a, `GetDeviceCaps` chame a função de membro com o índice RASTERCAPS e verifique o valor de retorno para o sinalizador RC_BITBLT.

##  <a name="setpixelv"></a>  CDC::SetPixelV

Define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x, em unidades lógicas, do ponto a ser definido.

*y*<br/>
Especifica a coordenada y, em unidades lógicas, do ponto a ser definido.

*crColor*<br/>
Especifica a cor a ser usada para pintar o ponto.

*point*<br/>
Especifica as coordenadas x e y lógicas do ponto a ser definido. Você pode passar uma estrutura de dados de [ponto](/windows/win32/api/windef/ns-windef-point) ou um objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O ponto deve estar na região de recorte e na parte visível da superfície do dispositivo. Nem todos os dispositivos dão suporte à função de membro. Para obter mais informações, consulte o recurso RC_BITBLT na `CDC::GetDeviceCaps` função membro. `SetPixelV`é mais rápido `SetPixel` do que porque não precisa retornar o valor de cor do ponto realmente pintado.

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

Define o modo de preenchimento de polígono.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parâmetros

*nPolyFillMode*<br/>
Especifica o novo modo de preenchimento. Esse valor pode ser alternativo ou de vento. O modo padrão definido no Windows é alternativo.

### <a name="return-value"></a>Valor de retorno

O modo de preenchimento anterior, se bem-sucedido; caso contrário, 0.

### <a name="remarks"></a>Comentários

Quando o modo de preenchimento de polígono é alternativo, o sistema preenche a área entre os lados de polígono numerados e ímpares em cada linha de digitalização. Ou seja, o sistema preenche a área entre o primeiro e o segundo lado, entre o terceiro e o quarto lado, e assim por diante. Esse modo é o padrão.

Quando o modo de preenchimento de polígono estiver enrolando, o sistema usará a direção em que uma figura foi desenhada para determinar se deve preencher uma área. Cada segmento de linha em um polígono é desenhado em uma direção no sentido horário ou no sentido anti-horário. Sempre que uma linha imaginária desenhada de uma área fechada para fora de uma figura passa por um segmento de linha no sentido horário, uma contagem é incrementada. Quando a linha passa por um segmento de linha no sentido anti-horário, a contagem é diminuída. A área será preenchida se a contagem for diferente de zero quando a linha atingir o fora da figura.

##  <a name="setrop2"></a>  CDC::SetROP2

Define o modo de desenho atual.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parâmetros

*nDrawMode*<br/>
Especifica o novo modo de desenho. Pode ser qualquer um dos seguintes valores:

- R2_BLACK pixel é sempre preto.

- R2_WHITE pixel é sempre branco.

- R2_NOP pixel permanece inalterado.

- R2_NOT pixel é o inverso da cor da tela.

- R2_COPYPEN pixel é a cor da caneta.

- R2_NOTCOPYPEN Pixel é o inverso da cor da caneta.

- R2_MERGEPENNOT pixel é uma combinação da cor da caneta e o inverso da cor da tela (pixel final = (não o pixel da tela) ou a caneta).

- O R2_MASKPENNOT pixel é uma combinação das cores comuns à caneta e ao inverso da tela (pixel final = (não o pixel da tela) e a caneta).

- R2_MERGENOTPEN pixel é uma combinação da cor da tela e o inverso da cor da caneta (pixel final = (não caneta) ou pixel da tela).

- O R2_MASKNOTPEN Pixel é uma combinação das cores comuns à tela e ao inverso da caneta (pixel final = (não à caneta) e ao pixel da tela).

- R2_MERGEPEN Pixel é uma combinação da cor da caneta e da cor da tela (pixel final = caneta ou pixel da tela).

- R2_NOTMERGEPEN pixel é o inverso da cor de R2_MERGEPEN (pixel final = NOT (caneta ou pixel de tela)).

- R2_MASKPEN pixel é uma combinação das cores comuns à caneta e à tela (pixel final = caneta e pixel da tela).

- R2_NOTMASKPEN pixel é o inverso da cor do R2_MASKPEN (pixel final = NOT (caneta e pixel da tela)).

- O pixel R2_XORPEN é uma combinação das cores que estão na caneta ou na tela, mas não nos dois (pixel final = pixel da tela XOR).

- R2_NOTXORPEN pixel é o inverso da cor do R2_XORPEN (pixel final = NOT (pixel da tela XOR da caneta)).

### <a name="return-value"></a>Valor de retorno

O modo de desenho anterior.

Pode ser qualquer um dos valores fornecidos na SDK do Windows.

### <a name="remarks"></a>Comentários

O modo de desenho especifica como as cores da caneta e o interior dos objetos preenchidos são combinados com a cor já na superfície de exibição.

O modo de desenho é somente para dispositivos de varredura; Ele não se aplica a dispositivos de vetor. Os modos de desenho são códigos de operação de rasterização binários que representam todas as combinações booleanas possíveis de duas variáveis, usando os operadores binários AND, OR e XOR (Exclusive ou), e a operação unário não.

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

Define o modo de alongamento de bitmaps para a função de `StretchBlt` membro.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parâmetros

*nStretchMode*<br/>
Especifica o modo de alongamento. Pode ser qualquer um dos seguintes valores:

|Valor|Descrição|
|-----------|-----------------|
|BLACKONWHITE|Executa um booliano e uma operação usando os valores de cor para os pixels eliminados e existentes. Se o bitmap for um bitmap monocromático, esse modo preservará os pixels pretos às custas de pixels brancos.|
|COLORONCOLOR|Exclui os pixels. Esse modo exclui todas as linhas de pixels eliminadas sem tentar preservar suas informações.|
|PROJE|Mapeia pixels do retângulo de origem em blocos de pixels no retângulo de destino. A cor média sobre o bloco de destino de pixels aproxima a cor dos pixels de origem.|
||Depois de definir o modo de alongamento de meio-tom, um aplicativo deve chamar a função [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) do Win32 para definir a origem do pincel. Se ele não conseguir fazer isso, ocorrerá um desalinhamento do pincel.|
|STRETCH_ANDSCANS|**Windows 95/98**: O mesmo que BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: O mesmo que COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Mesmo que meio-tom.|
|STRETCH_ORSCANS|**Windows 95/98**: O mesmo que WHITEONBLACK|
|WHITEONBLACK|Executa um booliano ou uma operação usando os valores de cor para os pixels eliminados e existentes. Se o bitmap for um bitmap monocromático, esse modo preservará os pixels brancos às custas de pixels pretos.|

### <a name="return-value"></a>Valor de retorno

O modo de alongamento anterior. Pode ser STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS.

### <a name="remarks"></a>Comentários

O modo de alongamento de bitmap define como as informações são removidas dos bitmaps compactados usando a função.

Os modos BLACKONWHITE (STRETCH_ANDSCANS) e WHITEONBLACK (STRETCH_ORSCANS) normalmente são usados para preservar pixels em primeiro plano em bitmaps monocromáticos. O modo COLORONCOLOR (STRETCH_DELETESCANS) normalmente é usado para preservar a cor em bitmaps de cores.

O modo de meio-tom requer mais processamento da imagem de origem do que os outros três modos; Ele é mais lento do que os outros, mas produz imagens de qualidade superior. Observe também que `SetBrushOrgEx` deve ser chamado depois de definir o modo de meio-tom para evitar o desalinhamento do pincel.

Modos de alargamento adicionais também podem estar disponíveis dependendo dos recursos do driver de dispositivo.

##  <a name="settextalign"></a>  CDC::SetTextAlign

Define os sinalizadores de alinhamento de texto.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parâmetros

*nFlags*<br/>
Especifica sinalizadores de alinhamento de texto. Os sinalizadores especificam a relação entre um ponto e um retângulo que limita o texto. O ponto pode ser a posição atual ou as coordenadas especificadas por uma função de saída de texto. O retângulo que limita o texto é definido pelas células de caracteres adjacentes na cadeia de texto. O parâmetro *nFlags* pode ser um ou mais sinalizadores das três categorias a seguir. Escolha apenas um sinalizador de cada categoria. A primeira categoria afeta o alinhamento de texto na direção x:

- TA_CENTER alinha o ponto ao centro horizontal do retângulo delimitador.

- TA_LEFT alinha o ponto ao lado esquerdo do retângulo delimitador. Essa é a configuração padrão.

- TA_RIGHT Alinha o ponto ao lado direito do retângulo delimitador.

A segunda categoria afeta o alinhamento de texto na direção y:

- TA_BASELINE alinha o ponto com a linha base da fonte escolhida.

- TA_BOTTOM alinha o ponto à parte inferior do retângulo delimitador.

- TA_TOP alinha o ponto à parte superior do retângulo delimitador. Essa é a configuração padrão.

A terceira categoria determina se a posição atual é atualizada quando o texto é gravado:

- TA_NOUPDATECP não atualiza a posição atual após cada chamada para uma função de saída de texto. Essa é a configuração padrão.

- TA_UPDATECP atualiza a posição x atual após cada chamada para uma função de saída de texto. A nova posição está no lado direito do retângulo delimitador do texto. Quando esse sinalizador é definido, as coordenadas especificadas em chamadas para a `TextOut` função de membro são ignoradas.

### <a name="return-value"></a>Valor de retorno

A configuração de alinhamento de texto anterior, se for bem-sucedida. O byte de ordem inferior contém a configuração horizontal e o byte de ordem superior contém a configuração vertical; caso contrário, 0.

### <a name="remarks"></a>Comentários

As `TextOut` funções `ExtTextOut` de membro e usam esses sinalizadores ao posicionar uma cadeia de caracteres de texto em uma exibição ou dispositivo. Os sinalizadores especificam a relação entre um ponto específico e um retângulo que limita o texto. As coordenadas desse ponto são passadas como parâmetros para a `TextOut` função membro. O retângulo que limita o texto é formado pelas células de caractere adjacentes na cadeia de texto.

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

Define a quantidade de espaçamento entre caracteres.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parâmetros

*nCharExtra*<br/>
Especifica a quantidade de espaço extra (em unidades lógicas) a ser adicionada a cada caractere. Se o modo de mapeamento atual não `MM_TEXT`for, *nCharExtra* será transformado e arredondado para o pixel mais próximo.

### <a name="return-value"></a>Valor de retorno

A quantidade do espaçamento entre caracteres anterior.

### <a name="remarks"></a>Comentários

O GDI adiciona esse espaçamento a cada caractere, incluindo caracteres de quebra, quando grava uma linha de texto no contexto do dispositivo. O valor padrão para a quantidade de espaçamento entre caracteres é 0.

##  <a name="settextcolor"></a>  CDC::SetTextColor

Define a cor do texto para a cor especificada.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a cor do texto como um valor de cor RGB.

### <a name="return-value"></a>Valor de retorno

Um valor RGB para a cor do texto anterior.

### <a name="remarks"></a>Comentários

O sistema usará essa cor de texto ao gravar texto nesse contexto de dispositivo e também ao converter bitmaps entre contextos de dispositivo de cor e monocromático.

Se o dispositivo não puder representar a cor especificada, o sistema definirá a cor do texto como a cor física mais próxima. A cor do plano de fundo de um caractere é `SetBkColor` especificada `SetBkMode` pelas funções de membro e.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [CWnd:: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="settextjustification"></a>  CDC::SetTextJustification

Adiciona espaço aos caracteres de quebra em uma cadeia de caracteres.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parâmetros

*nBreakExtra*<br/>
Especifica o espaço extra total a ser adicionado à linha de texto (em unidades lógicas). Se o modo de mapeamento atual não `MM_TEXT`for, o valor fornecido por esse parâmetro será convertido no modo de mapeamento atual e arredondado para a unidade de dispositivo mais próxima.

*nBreakCount*<br/>
Especifica o número de caracteres de quebra na linha.

### <a name="return-value"></a>Valor de retorno

Um se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um aplicativo pode usar as `GetTextMetrics` funções de membro para recuperar o caractere de quebra de uma fonte.

Depois que `SetTextJustification` a função de membro é chamada, uma chamada para uma função de saída de texto `TextOut`(como) distribui o espaço extra especificado uniformemente entre o número especificado de caracteres de quebra. O caractere de quebra geralmente é o caractere de espaço (ASCII 32), mas pode ser definido por uma fonte como outro caractere.

A função `GetTextExtent` de membro normalmente é usada `SetTextJustification`com o. `GetTextExtent`computa a largura de uma determinada linha antes do alinhamento. Um aplicativo pode determinar quanto espaço deve ser especificado no parâmetro *nBreakExtra* subtraindo o valor retornado pela `GetTextExtent` largura da cadeia de caracteres após o alinhamento.

A `SetTextJustification` função pode ser usada para alinhar uma linha que contém várias execuções em diferentes fontes. Nesse caso, a linha deve ser criada gradativamente com o alinhamento e a gravação de cada execução separadamente.

Como os erros de arredondamento podem ocorrer durante o alinhamento, o sistema mantém uma condição de erro em execução que define o erro atual. Ao alinhar uma linha que contém várias execuções `GetTextExtent` , o usa automaticamente esse termo de erro quando computa a extensão da próxima execução. Isso permite que a função de saída de texto misture o erro na nova execução.

Depois que cada linha é alinhada, esse termo de erro deve ser limpo para impedir que ele seja incorporado à próxima linha. O termo pode ser limpo chamando `SetTextJustification` with *nBreakExtra* definido como 0.

##  <a name="setviewportext"></a>  CDC::SetViewportExt

Define as extensões x e y do visor do contexto do dispositivo.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*cx*<br/>
Especifica a extensão x do visor (em unidades de dispositivo).

*cy*<br/>
Especifica a extensão y do visor (em unidades de dispositivo).

*size*<br/>
Especifica as extensões x e y do visor (em unidades de dispositivo).

### <a name="return-value"></a>Valor de retorno

As extensões anteriores do visor como um objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) . Quando ocorre um erro, as coordenadas x e y do objeto retornado `CSize` são definidas como 0.

### <a name="remarks"></a>Comentários

O visor, junto com a janela de contexto do dispositivo, define como o GDI mapeia pontos no sistema lógico de coordenadas para pontos no sistema de coordenadas do dispositivo real. Em outras palavras, eles definem como o GDI converte coordenadas lógicas em coordenadas do dispositivo.

Quando os modos de mapeamento a seguir são definidos, `SetWindowExt` as `SetViewportExt` chamadas para e são ignoradas:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Quando o modo MM_ISOTROPIC é definido, um aplicativo deve chamar `SetWindowExt` a função de membro antes `SetViewportExt`de chamar.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [cvisualização:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

Define a origem do visor do contexto do dispositivo.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades de dispositivo) da origem do visor. O valor deve estar dentro do intervalo do sistema de coordenadas do dispositivo.

*y*<br/>
Especifica a coordenada y (em unidades de dispositivo) da origem do visor. O valor deve estar dentro do intervalo do sistema de coordenadas do dispositivo.

*point*<br/>
Especifica a origem do visor. Os valores devem estar dentro do intervalo do sistema de coordenadas do dispositivo. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

A origem anterior do visor (em coordenadas do dispositivo) como um `CPoint` objeto.

### <a name="remarks"></a>Comentários

O visor, junto com a janela de contexto do dispositivo, define como o GDI mapeia pontos no sistema lógico de coordenadas para pontos no sistema de coordenadas do dispositivo real. Em outras palavras, eles definem como o GDI converte coordenadas lógicas em coordenadas do dispositivo.

A origem do visor marca o ponto no sistema de coordenadas do dispositivo para o qual o GDI mapeia a origem da janela, um ponto no sistema de `SetWindowOrg` coordenadas lógica especificado pela função de membro. O GDI mapeia todos os outros pontos seguindo o mesmo processo necessário para mapear a origem da janela para a origem do visor. Por exemplo, todos os pontos em um círculo em volta do ponto na origem da janela estarão em um círculo em volta do ponto na origem do visor. Da mesma forma, todos os pontos em uma linha que passam pela origem da janela estarão em uma linha que passa pela origem do visor.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [cvisualização:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindowext"></a>  CDC::SetWindowExt

Define as extensões x e y da janela associada ao contexto do dispositivo.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*cx*<br/>
Especifica a extensão x (em unidades lógicas) da janela.

*cy*<br/>
Especifica a extensão y (em unidades lógicas) da janela.

*size*<br/>
Especifica as extensões x e y (em unidades lógicas) da janela.

### <a name="return-value"></a>Valor de retorno

As extensões anteriores da janela (em unidades lógicas) como um `CSize` objeto. Se ocorrer um erro, as coordenadas x e y do objeto retornado `CSize` serão definidas como 0.

### <a name="remarks"></a>Comentários

A janela, junto com o visor de contexto de dispositivo, define como o GDI mapeia pontos no sistema lógico de coordenadas para pontos no sistema de coordenadas do dispositivo.

Quando os modos de mapeamento a seguir são definidos, `SetWindowExt` as `SetViewportExt` chamadas para e funções são ignoradas:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Quando o modo MM_ISOTROPIC é definido, um aplicativo deve chamar `SetWindowExt` a função de membro `SetViewportExt`antes de chamar.

### <a name="example"></a>Exemplo

  Consulte o exemplo de [cvisualização:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

Define a origem da janela do contexto do dispositivo.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da nova origem da janela.

*y*<br/>
Especifica a coordenada y lógica da nova origem da janela.

*point*<br/>
Especifica as coordenadas lógicas da nova origem da janela. Você pode passar uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

A origem anterior da janela como um `CPoint` objeto.

### <a name="remarks"></a>Comentários

A janela, junto com o visor de contexto de dispositivo, define como o GDI mapeia pontos no sistema lógico de coordenadas para pontos no sistema de coordenadas do dispositivo.

A origem da janela marca o ponto no sistema de coordenadas lógica a partir do qual o GDI mapeia a origem do visor, um ponto no sistema de `SetWindowOrg` coordenadas do dispositivo especificado pela função. O GDI mapeia todos os outros pontos seguindo o mesmo processo necessário para mapear a origem da janela para a origem do visor. Por exemplo, todos os pontos em um círculo em volta do ponto na origem da janela estarão em um círculo em volta do ponto na origem do visor. Da mesma forma, todos os pontos em uma linha que passam pela origem da janela estarão em uma linha que passa pela origem do visor.

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

Define uma transformação linear bidimensional entre o espaço mundial e o espaço da página para o contexto do dispositivo especificado. Essa transformação pode ser usada para dimensionar, girar, distorcer ou traduzir a saída de gráficos.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a uma estrutura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) que contém os dados de transformação.

### <a name="return-value"></a>Valor de retorno

Retorna um valor diferente de zero em caso de êxito.

Retorna 0 em caso de falha.

Para obter informações de erro estendidas, chame [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Comentários

Esse método encapsula a função GDI do Windows [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

##  <a name="startdoc"></a>  CDC::StartDoc

Informa ao driver de dispositivo que um novo trabalho de impressão está iniciando e que todos os `StartPage` subseqüentes e `EndPage` chamadas devem ser colocados em spool no mesmo `EndDoc` trabalho até que ocorra uma chamada.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parâmetros

*lpDocInfo*<br/>
Aponta para uma estrutura [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) que contém o nome do arquivo de documento e o nome do arquivo de saída.

*lpszDocName*<br/>
Ponteiro para uma cadeia de caracteres que contém o nome do arquivo de documento.

### <a name="return-value"></a>Valor de retorno

Se a função for realizada com sucesso, o valor de retorno será maior que zero. Esse valor é o identificador do trabalho de impressão para o documento.

Se a função falhar, o valor de retorno será menor ou igual a zero.

### <a name="remarks"></a>Comentários

Isso garante que os documentos com mais de uma página não serão intercalados com outros trabalhos.

Para as versões 3,1 e posteriores do Windows, essa função substitui o escape de impressora STARTDOC. O uso dessa função garante que os documentos que contêm mais de uma página não sejam intercalados com outros trabalhos de impressão.

`StartDoc`Não deve ser usado dentro de metaarquivos.

### <a name="example"></a>Exemplo

Esse fragmento de código obtém a impressora padrão, abre um trabalho de impressão e coloca em spool uma página com "Olá, mundo!" nele. Como o texto impresso por esse código não é dimensionado para as unidades lógicas da impressora, o texto de saída pode estar em letras pequenas que o resultado é ilegível. As funções de dimensionamento CDC, `SetMapMode` `SetViewportOrg`como, e `SetWindowExt`, podem ser usadas para corrigir o dimensionamento.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

Chame essa função de membro para preparar o driver de impressora para receber dados.

```
int StartPage();
```

### <a name="return-value"></a>Valor de retorno

Maior ou igual a 0 se a função for bem-sucedida ou um valor negativo se ocorrer um erro.

### <a name="remarks"></a>Comentários

`StartPage`substitui os escapes NEWFRAME e BANDINFO.

Para obter uma visão geral da sequência de chamadas de impressão, consulte a função membro [StartDoc](#startdoc) .

O sistema desabilita a função de `ResetDC` membro entre chamadas para `StartPage` e `EndPage`.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: StartDoc](#startdoc).

##  <a name="stretchblt"></a>  CDC::StretchBlt

Copia um bitmap de um retângulo de origem em um retângulo de destino, alongando-o ou compactando-o, se necessário, para ajustá-lo às dimensões do retângulo de destino.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades lógicas) do canto esquerdo superior do retângulo de destino.

*y*<br/>
Especifica a coordenada y (em unidades lógicas) do canto esquerdo superior do retângulo de destino.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de destino.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de destino.

*pSrcDC*<br/>
Especifica o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x (em unidades lógicas) do canto esquerdo superior do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y (em unidades lógicas) do canto esquerdo superior do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de origem.

*dwRop*<br/>
Especifica a operação de varredura a ser executada. Os códigos da operação de varredura definem como a GDI combina cores nas operações de saída que envolvem um pincel, um possível bitmap de origem e um bitmap de destino. Esse parâmetro pode ser um dos seguintes valores:

- A BLACKização transforma toda a saída em preto.

- DSTINVERT inverte o bitmap de destino.

- MERGECOPY combina o padrão e o bitmap de origem usando o operador booleano e.

- MERGEPAINT combina o bitmap de origem invertido com o bitmap de destino usando o operador booleano ou.

- NOTSRCCOPY copia o bitmap de origem invertido para o destino.

- NOTSRCERASE inverte o resultado da combinação dos bitmaps de origem e destino usando o operador OR booliano.

- PATCOPY copia o padrão para o bitmap de destino.

- PATINVERT combina o bitmap de destino com o padrão usando o operador de XOR booliano.

- PATPAINT combina o bitmap de origem invertido com o padrão usando o operador booleano ou. Combina o resultado dessa operação com o bitmap de destino usando o operador OR booliano.

- SRCAND combina pixels dos bitmaps de origem e destino usando o operador booleano e.

- SRCCOPY copia o bitmap de origem para o bitmap de destino.

- SRCERASE inverte o bitmap de destino e combina o resultado com o bitmap de origem usando o operador booleano e.

- SRCINVERT combina pixels dos bitmaps de origem e destino usando o operador XOR booliano.

- SRCPAINT combina pixels dos bitmaps de origem e destino usando o operador OR booliano.

- A branco transforma todas as saídas em branco.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o bitmap for desenhado; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função usa o modo de alongamento do contexto do dispositivo de destino (definido por `SetStretchBltMode`) para determinar como alongar ou compactar o bitmap.

A `StretchBlt` função move o bitmap do dispositivo de origem fornecido pelo *pSrcDC* para o dispositivo de destino representado pelo objeto de contexto do dispositivo cuja função de membro está sendo chamada. Os parâmetros *xSrc*, *ySrc*, *nSrcWidth*e *nSrcHeight* definem o canto superior esquerdo e as dimensões do retângulo de origem. Os parâmetros *x*, *y*, *nWidth*e *nHeight* fornecem o canto superior esquerdo e as dimensões do retângulo de destino. A operação de varredura especificada por *dwRop* define como o bitmap de origem e os bits que já estão no dispositivo de destino são combinados.

A `StretchBlt` função cria uma imagem espelho de um bitmap se os sinais dos parâmetros *nSrcWidth* e *nWidth* ou *nSrcHeight* e *nHeight* forem diferentes. Se *nSrcWidth* e *nWidth* tiverem sinais diferentes, a função criará uma imagem espelho do bitmap ao longo do eixo x. Se *nSrcHeight* e *nHeight* tiverem sinais diferentes, a função criará uma imagem espelho do bitmap ao longo do eixo y.

A função `StretchBlt` alonga ou compacta o bitmap de origem na memória e copia o resultado no destino. Se um padrão deve ser mesclado com o resultado, ele não será mesclado até que o bitmap de origem alongado seja copiado no destino. Se um pincel for usado, é o pincel selecionado no contexto do dispositivo de destino. As coordenadas de destino são transformadas de acordo com o contexto do dispositivo de destino; as coordenadas de origem são transformadas de acordo com o contexto do dispositivo de origem.

Se os bitmaps de destino, origem e padrão não tiverem o mesmo formato de cor, `StretchBlt` converterá os bitmaps de origem e padrão para correspondência com os bitmaps de destino. As cores do primeiro plano e do plano de fundo do contexto do dispositivo de destino são usadas na conversão.

Se `StretchBlt` precisar converter um bitmap monocromático em colorido, ele definirá bits brancos (1) para a cor do plano de fundo e bits pretos (0) para a cor do primeiro plano. Para converter o colorido em monocromático, ele define pixels que correspondam à cor do plano de fundo para branco (1) e define todos os outros pixels para preto (0). As cores do primeiro plano e do plano de fundo do contexto do dispositivo com cor são usadas.

Nem todos os dispositivos oferecem suporte à função `StretchBlt`. Para determinar se um dispositivo dá `StretchBlt`suporte a, `GetDeviceCaps` chame a função de membro com o índice RASTERCAPS e verifique o valor de retorno para o sinalizador RC_STRETCHBLT.

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

Fecha as figuras abertas em um caminho, traça o contorno do caminho usando a caneta atual e preenche seu interior usando o pincel atual.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado. A `StrokeAndFillPath` função membro tem o mesmo efeito que fechar todas as figuras abertas no caminho e traçar e preencher o caminho separadamente, exceto que a região preenchida não se sobreporá à região cortada, mesmo que a caneta seja larga.

##  <a name="strokepath"></a>  CDC::StrokePath

Renderiza o caminho especificado usando a caneta atual.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado.

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

Chame essa função de membro para gravar uma cadeia de caracteres no local especificado, expandindo as guias para os valores especificados na matriz de posições de parada de tabulação.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto inicial da cadeia de caracteres.

*y*<br/>
Especifica a coordenada y lógica do ponto inicial da cadeia de caracteres.

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhada. Você pode passar um ponteiro para uma matriz de caracteres ou um objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para esse parâmetro.

*nCount*<br/>
Especifica o [comprimento da cadeia de caracteres](/windows/win32/gdi/specifying-length-of-text-output-string) apontada por *lpszString*.

*nTabPositions*<br/>
Especifica o número de valores na matriz de posições de parada de tabulação.

*lpnTabStopPositions*<br/>
Aponta para uma matriz que contém as posições de parada de tabulação (em unidades lógicas). As paradas de tabulação devem ser classificadas em ordem crescente; o menor valor x deve ser o primeiro item na matriz.

*nTabOrigin*<br/>
Especifica a coordenada x da posição inicial a partir da qual as guias são expandidas (em unidades lógicas).

*str*<br/>
Um `CString` objeto que contém os caracteres especificados.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) `CSize` como um objeto.

### <a name="remarks"></a>Comentários

O texto é gravado na fonte atualmente selecionada. Se *nTabPositions* for 0 e *lpnTabStopPositions* for NULL, as guias serão expandidas para oito vezes a largura média do caractere.

Se *nTabPositions* for 1, as paradas de tabulação serão separadas pela distância especificada pelo primeiro valor na matriz *lpnTabStopPositions* . Se a matriz *lpnTabStopPositions* contiver mais de um valor, uma parada de tabulação será definida para cada valor na matriz, até o número especificado por *nTabPositions*. O parâmetro *nTabOrigin* permite que um aplicativo chame a `TabbedTextOut` função várias vezes para uma única linha. Se o aplicativo chamar a função mais de uma vez com o *nTabOrigin* definido como o mesmo valor a cada vez, a função expandirá todas as guias relativas à posição especificada por *nTabOrigin*.

Por padrão, a posição atual não é usada nem atualizada pela função. Se um aplicativo precisar atualizar a posição atual ao chamar a função, o aplicativo poderá chamar a função de membro [SetTextAlign](#settextalign) com *NFLAGS* definido como TA_UPDATECP. Quando esse sinalizador é definido, o Windows ignora os parâmetros *x* e *y* nas chamadas subsequentes `TabbedTextOut`para, usando a posição atual em vez disso.

##  <a name="textout"></a>  CDC::TextOut

Grava uma cadeia de caracteres no local especificado usando a fonte selecionada no momento.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto de partida do texto.

*y*<br/>
Especifica a coordenada y lógica do ponto de partida do texto.

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhada.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*str*<br/>
Um objeto `CString` que contém os caracteres a serem desenhados.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As origens do caractere estão no canto superior esquerdo da célula do caractere. Por padrão, a posição atual não é usada nem atualizada pela função.

Se um aplicativo precisar atualizar a posição atual quando ele chamar `TextOut`, o aplicativo poderá chamar a função de `SetTextAlign` membro com *nFlags* definido como TA_UPDATECP. Quando esse sinalizador é definido, o Windows ignora os parâmetros *x* e *y* nas chamadas subsequentes `TextOut`para, usando a posição atual em vez disso.

### <a name="example"></a>Exemplo

  Consulte o exemplo para [CDC:: BeginPath](#beginpath).

##  <a name="transparentblt"></a>  CDC::TransparentBlt

Chame essa função de membro para transferir um bloco de bits dos dados de cor, que corresponde a um retângulo de pixels do contexto do dispositivo de origem especificado, em um contexto de dispositivo de destino.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parâmetros

*xDest*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*yDest*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*nDestWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino.

*nDestHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino.

*pSrcDC*<br/>
Ponteiro para o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*clrTransparent*<br/>
A cor RGB no bitmap de origem para tratar como transparente.

### <a name="return-value"></a>Valor de retorno

Verdadeiro se for bem-sucedido; caso contrário, FALSE.

### <a name="remarks"></a>Comentários

`TransparentBlt`permite transparência; ou seja, a cor RGB indicada por *clrTransparent* é processada transparente para a transferência.

Para obter mais informações, consulte [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) no SDK do Windows.

##  <a name="updatecolors"></a>  CDC::UpdateColors

Atualiza a área do cliente do contexto do dispositivo, combinando as cores atuais na área do cliente para a paleta do sistema em uma base de pixel por pixel.

```
void UpdateColors();
```

### <a name="remarks"></a>Comentários

Uma janela inativa com uma paleta lógica realizada pode chamar `UpdateColors` como uma alternativa para redesenhar sua área de cliente quando a paleta do sistema é alterada.

Para obter mais informações sobre como usar paletas de cores, consulte [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) no SDK do Windows.

A `UpdateColors` função de membro normalmente atualiza uma área de cliente mais rapidamente do que redesenhar a área. No entanto, como a função executa a tradução de cores com base na cor de cada pixel antes da alteração da paleta do sistema, cada chamada para essa função resulta na perda de alguma precisão de cor.

##  <a name="widenpath"></a>  CDC::WidenPath

Redefine o caminho atual como a área que seria pintada se o caminho tivesse sido traçado usando a caneta atualmente selecionada no contexto do dispositivo.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função será bem-sucedida somente se a caneta atual for uma caneta geométrica criada pela segunda versão da `CreatePen` função de membro ou se a caneta for criada com a primeira versão do `CreatePen` e tiver uma largura, em unidades de dispositivo, de maior que 1. O contexto do dispositivo deve conter um caminho fechado. Todas as curvas Bzier no caminho são convertidas em sequências de linhas retas aproximar as curvas alargadas. Como tal, nenhuma curva Bzier permanece no caminho depois `WidenPath` que é chamada.

## <a name="see-also"></a>Consulte também

[Classe CObject](../../mfc/reference/cobject-class.md)<br/>
[Gráfico da hierarquia](../../mfc/hierarchy-chart.md)<br/>
[Classe CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Classe CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Classe CClientDC](../../mfc/reference/cclientdc-class.md)<br/>
[Classe CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)
